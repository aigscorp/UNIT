(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Quagga"] = factory();
	else
		root["Quagga"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 67);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(19);

var assertThisInitialized = __webpack_require__(1);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(140);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(36),
  create: __webpack_require__(37),
  clone: __webpack_require__(72),
  fromValues: __webpack_require__(73),
  copy: __webpack_require__(74),
  set: __webpack_require__(75),
  equals: __webpack_require__(76),
  exactEquals: __webpack_require__(77),
  add: __webpack_require__(78),
  subtract: __webpack_require__(38),
  sub: __webpack_require__(79),
  multiply: __webpack_require__(39),
  mul: __webpack_require__(80),
  divide: __webpack_require__(40),
  div: __webpack_require__(81),
  inverse: __webpack_require__(82),
  min: __webpack_require__(83),
  max: __webpack_require__(84),
  rotate: __webpack_require__(85),
  floor: __webpack_require__(86),
  ceil: __webpack_require__(87),
  round: __webpack_require__(88),
  scale: __webpack_require__(89),
  scaleAndAdd: __webpack_require__(90),
  distance: __webpack_require__(41),
  dist: __webpack_require__(91),
  squaredDistance: __webpack_require__(42),
  sqrDist: __webpack_require__(92),
  length: __webpack_require__(43),
  len: __webpack_require__(93),
  squaredLength: __webpack_require__(44),
  sqrLen: __webpack_require__(94),
  negate: __webpack_require__(95),
  normalize: __webpack_require__(96),
  dot: __webpack_require__(97),
  cross: __webpack_require__(98),
  lerp: __webpack_require__(99),
  random: __webpack_require__(100),
  transformMat2: __webpack_require__(101),
  transformMat2d: __webpack_require__(102),
  transformMat3: __webpack_require__(103),
  transformMat4: __webpack_require__(104),
  forEach: __webpack_require__(105),
  limit: __webpack_require__(106)
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "imageRef", function() { return /* binding */ imageRef; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage2", function() { return /* binding */ computeIntegralImage2; });
__webpack_require__.d(__webpack_exports__, "computeIntegralImage", function() { return /* binding */ computeIntegralImage; });
__webpack_require__.d(__webpack_exports__, "thresholdImage", function() { return /* binding */ thresholdImage; });
__webpack_require__.d(__webpack_exports__, "computeHistogram", function() { return /* binding */ computeHistogram; });
__webpack_require__.d(__webpack_exports__, "sharpenLine", function() { return /* binding */ sharpenLine; });
__webpack_require__.d(__webpack_exports__, "determineOtsuThreshold", function() { return /* binding */ determineOtsuThreshold; });
__webpack_require__.d(__webpack_exports__, "otsuThreshold", function() { return /* binding */ otsuThreshold; });
__webpack_require__.d(__webpack_exports__, "computeBinaryImage", function() { return /* binding */ computeBinaryImage; });
__webpack_require__.d(__webpack_exports__, "cluster", function() { return /* binding */ cv_utils_cluster; });
__webpack_require__.d(__webpack_exports__, "Tracer", function() { return /* binding */ Tracer; });
__webpack_require__.d(__webpack_exports__, "DILATE", function() { return /* binding */ DILATE; });
__webpack_require__.d(__webpack_exports__, "ERODE", function() { return /* binding */ ERODE; });
__webpack_require__.d(__webpack_exports__, "dilate", function() { return /* binding */ dilate; });
__webpack_require__.d(__webpack_exports__, "erode", function() { return /* binding */ erode; });
__webpack_require__.d(__webpack_exports__, "subtract", function() { return /* binding */ subtract; });
__webpack_require__.d(__webpack_exports__, "bitwiseOr", function() { return /* binding */ bitwiseOr; });
__webpack_require__.d(__webpack_exports__, "countNonZero", function() { return /* binding */ countNonZero; });
__webpack_require__.d(__webpack_exports__, "topGeneric", function() { return /* binding */ topGeneric; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromImage", function() { return /* binding */ grayArrayFromImage; });
__webpack_require__.d(__webpack_exports__, "grayArrayFromContext", function() { return /* binding */ grayArrayFromContext; });
__webpack_require__.d(__webpack_exports__, "grayAndHalfSampleFromCanvasData", function() { return /* binding */ grayAndHalfSampleFromCanvasData; });
__webpack_require__.d(__webpack_exports__, "computeGray", function() { return /* binding */ computeGray; });
__webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return /* binding */ loadImageArray; });
__webpack_require__.d(__webpack_exports__, "halfSample", function() { return /* binding */ halfSample; });
__webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return /* binding */ hsv2rgb; });
__webpack_require__.d(__webpack_exports__, "_computeDivisors", function() { return /* binding */ _computeDivisors; });
__webpack_require__.d(__webpack_exports__, "calculatePatchSize", function() { return /* binding */ calculatePatchSize; });
__webpack_require__.d(__webpack_exports__, "_parseCSSDimensionValues", function() { return /* binding */ _parseCSSDimensionValues; });
__webpack_require__.d(__webpack_exports__, "_dimensionsConverters", function() { return /* binding */ _dimensionsConverters; });
__webpack_require__.d(__webpack_exports__, "computeImageArea", function() { return /* binding */ computeImageArea; });

// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// EXTERNAL MODULE: ./node_modules/gl-vec3/index.js
var gl_vec3 = __webpack_require__(63);

// CONCATENATED MODULE: ./src/common/cluster.js
// TODO: cluster.js and cv_utils.js are pretty tightly intertwined, making for a complex conversion
// into typescript. be warned. :-)

var vec2 = {
  clone: gl_vec2["clone"],
  dot: gl_vec2["dot"]
};
/**
 * Creates a cluster for grouping similar orientations of datapoints
 */

/* harmony default export */ var cluster = ({
  create: function create(point, threshold) {
    var points = [];
    var center = {
      rad: 0,
      vec: vec2.clone([0, 0])
    };
    var pointMap = {};

    function _add(pointToAdd) {
      pointMap[pointToAdd.id] = pointToAdd;
      points.push(pointToAdd);
    }

    function updateCenter() {
      var i;
      var sum = 0;

      for (i = 0; i < points.length; i++) {
        sum += points[i].rad;
      }

      center.rad = sum / points.length;
      center.vec = vec2.clone([Math.cos(center.rad), Math.sin(center.rad)]);
    }

    function init() {
      _add(point);

      updateCenter();
    }

    init();
    return {
      add: function add(pointToAdd) {
        if (!pointMap[pointToAdd.id]) {
          _add(pointToAdd);

          updateCenter();
        }
      },
      fits: function fits(otherPoint) {
        // check cosine similarity to center-angle
        var similarity = Math.abs(vec2.dot(otherPoint.point.vec, center.vec));

        if (similarity > threshold) {
          return true;
        }

        return false;
      },
      getPoints: function getPoints() {
        return points;
      },
      getCenter: function getCenter() {
        return center;
      }
    };
  },
  createPoint: function createPoint(newPoint, id, property) {
    return {
      rad: newPoint[property],
      point: newPoint,
      id: id
    };
  }
});
// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/common/cv_utils.js
/* eslint-disable no-mixed-operators */

/* eslint-disable no-bitwise */




var cv_utils_vec2 = {
  clone: gl_vec2["clone"]
};
var vec3 = {
  clone: gl_vec3["clone"]
};
/**
 * @param x x-coordinate
 * @param y y-coordinate
 * @return ImageReference {x,y} Coordinate
 */

function imageRef(x, y) {
  var that = {
    x: x,
    y: y,
    toVec2: function toVec2() {
      return cv_utils_vec2.clone([this.x, this.y]);
    },
    toVec3: function toVec3() {
      return vec3.clone([this.x, this.y, 1]);
    },
    round: function round() {
      this.x = this.x > 0.0 ? Math.floor(this.x + 0.5) : Math.floor(this.x - 0.5);
      this.y = this.y > 0.0 ? Math.floor(this.y + 0.5) : Math.floor(this.y - 0.5);
      return this;
    }
  };
  return that;
}
/**
 * Computes an integral image of a given grayscale image.
 * @param imageDataContainer {ImageDataContainer} the image to be integrated
 */

function computeIntegralImage2(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var posA = 0;
  var posB = 0;
  var posC = 0;
  var posD = 0;
  var x;
  var y; // sum up first column

  posB = width;
  sum = 0;

  for (y = 1; y < height; y++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA += width;
    posB += width;
  }

  posA = 0;
  posB = 1;
  sum = 0;

  for (x = 1; x < width; x++) {
    sum += imageData[posA];
    integralImageData[posB] += sum;
    posA++;
    posB++;
  }

  for (y = 1; y < height; y++) {
    posA = y * width + 1;
    posB = (y - 1) * width + 1;
    posC = y * width;
    posD = (y - 1) * width;

    for (x = 1; x < width; x++) {
      integralImageData[posA] += imageData[posA] + integralImageData[posB] + integralImageData[posC] - integralImageData[posD];
      posA++;
      posB++;
      posC++;
      posD++;
    }
  }
}
function computeIntegralImage(imageWrapper, integralWrapper) {
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0; // sum up first row

  for (var i = 0; i < width; i++) {
    sum += imageData[i];
    integralImageData[i] = sum;
  }

  for (var v = 1; v < height; v++) {
    sum = 0;

    for (var u = 0; u < width; u++) {
      sum += imageData[v * width + u];
      integralImageData[v * width + u] = sum + integralImageData[(v - 1) * width + u];
    }
  }
}
function thresholdImage(imageWrapper, threshold, targetWrapper) {
  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var targetData = targetWrapper.data;

  while (length--) {
    targetData[length] = imageData[length] < threshold ? 1 : 0;
  }
}
function computeHistogram(imageWrapper, bitsPerPixel) {
  if (!bitsPerPixel) {
    // eslint-disable-next-line no-param-reassign
    bitsPerPixel = 8;
  }

  var imageData = imageWrapper.data;
  var length = imageData.length;
  var bitShift = 8 - bitsPerPixel;
  var bucketCnt = 1 << bitsPerPixel;
  var hist = new Int32Array(bucketCnt);

  while (length--) {
    hist[imageData[length] >> bitShift]++;
  }

  return hist;
}
function sharpenLine(line) {
  var i;
  var length = line.length;
  var left = line[0];
  var center = line[1];
  var right;

  for (i = 1; i < length - 1; i++) {
    right = line[i + 1]; //  -1 4 -1 kernel
    // eslint-disable-next-line no-param-reassign

    line[i - 1] = center * 2 - left - right & 255;
    left = center;
    center = right;
  }

  return line;
}
function determineOtsuThreshold(imageWrapper) {
  var bitsPerPixel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var hist;
  var bitShift = 8 - bitsPerPixel;

  function px(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += hist[i];
    }

    return sum;
  }

  function mx(init, end) {
    var sum = 0;

    for (var i = init; i <= end; i++) {
      sum += i * hist[i];
    }

    return sum;
  }

  function determineThreshold() {
    var vet = [0];
    var p1;
    var p2;
    var p12;
    var m1;
    var m2;
    var m12;
    var max = (1 << bitsPerPixel) - 1;
    hist = computeHistogram(imageWrapper, bitsPerPixel);

    for (var k = 1; k < max; k++) {
      p1 = px(0, k);
      p2 = px(k + 1, max);
      p12 = p1 * p2;

      if (p12 === 0) {
        p12 = 1;
      }

      m1 = mx(0, k) * p2;
      m2 = mx(k + 1, max) * p1;
      m12 = m1 - m2;
      vet[k] = m12 * m12 / p12;
    }

    return array_helper["a" /* default */].maxIndex(vet);
  }

  var threshold = determineThreshold();
  return threshold << bitShift;
}
function otsuThreshold(imageWrapper, targetWrapper) {
  var threshold = determineOtsuThreshold(imageWrapper);
  thresholdImage(imageWrapper, threshold, targetWrapper);
  return threshold;
} // local thresholding

function computeBinaryImage(imageWrapper, integralWrapper, targetWrapper) {
  computeIntegralImage(imageWrapper, integralWrapper);

  if (!targetWrapper) {
    // eslint-disable-next-line no-param-reassign
    targetWrapper = imageWrapper;
  }

  var imageData = imageWrapper.data;
  var targetData = targetWrapper.data;
  var width = imageWrapper.size.x;
  var height = imageWrapper.size.y;
  var integralImageData = integralWrapper.data;
  var sum = 0;
  var v;
  var u;
  var kernel = 3;
  var A;
  var B;
  var C;
  var D;
  var avg;
  var size = (kernel * 2 + 1) * (kernel * 2 + 1); // clear out top & bottom-border

  for (v = 0; v <= kernel; v++) {
    for (u = 0; u < width; u++) {
      targetData[v * width + u] = 0;
      targetData[(height - 1 - v) * width + u] = 0;
    }
  } // clear out left & right border


  for (v = kernel; v < height - kernel; v++) {
    for (u = 0; u <= kernel; u++) {
      targetData[v * width + u] = 0;
      targetData[v * width + (width - 1 - u)] = 0;
    }
  }

  for (v = kernel + 1; v < height - kernel - 1; v++) {
    for (u = kernel + 1; u < width - kernel; u++) {
      A = integralImageData[(v - kernel - 1) * width + (u - kernel - 1)];
      B = integralImageData[(v - kernel - 1) * width + (u + kernel)];
      C = integralImageData[(v + kernel) * width + (u - kernel - 1)];
      D = integralImageData[(v + kernel) * width + (u + kernel)];
      sum = D - C - B + A;
      avg = sum / size;
      targetData[v * width + u] = imageData[v * width + u] > avg + 5 ? 0 : 1;
    }
  }
}
function cv_utils_cluster(points, threshold, property) {
  var i;
  var k;
  var thisCluster;
  var point;
  var clusters = [];

  if (!property) {
    // eslint-disable-next-line no-param-reassign
    property = 'rad';
  }

  function addToCluster(newPoint) {
    var found = false;

    for (k = 0; k < clusters.length; k++) {
      thisCluster = clusters[k];

      if (thisCluster.fits(newPoint)) {
        thisCluster.add(newPoint);
        found = true;
      }
    }

    return found;
  } // iterate over each cloud


  for (i = 0; i < points.length; i++) {
    point = cluster.createPoint(points[i], i, property);

    if (!addToCluster(point)) {
      clusters.push(cluster.create(point, threshold));
    }
  }

  return clusters;
}
var Tracer = {
  trace: function trace(points, vec) {
    var iteration;
    var maxIterations = 10;
    var top = [];
    var result = [];
    var centerPos = 0;
    var currentPos = 0;

    function trace(idx, forward) {
      var to;
      var toIdx;
      var predictedPos;
      var thresholdX = 1;
      var thresholdY = Math.abs(vec[1] / 10);
      var found = false;

      function match(pos, predicted) {
        if (pos.x > predicted.x - thresholdX && pos.x < predicted.x + thresholdX && pos.y > predicted.y - thresholdY && pos.y < predicted.y + thresholdY) {
          return true;
        }

        return false;
      } // check if the next index is within the vec specifications
      // if not, check as long as the threshold is met


      var from = points[idx];

      if (forward) {
        predictedPos = {
          x: from.x + vec[0],
          y: from.y + vec[1]
        };
      } else {
        predictedPos = {
          x: from.x - vec[0],
          y: from.y - vec[1]
        };
      }

      toIdx = forward ? idx + 1 : idx - 1;
      to = points[toIdx]; // eslint-disable-next-line no-cond-assign

      while (to && (found = match(to, predictedPos)) !== true && Math.abs(to.y - from.y) < vec[1]) {
        toIdx = forward ? toIdx + 1 : toIdx - 1;
        to = points[toIdx];
      }

      return found ? toIdx : null;
    }

    for (iteration = 0; iteration < maxIterations; iteration++) {
      // randomly select point to start with
      centerPos = Math.floor(Math.random() * points.length); // trace forward

      top = [];
      currentPos = centerPos;
      top.push(points[currentPos]); // eslint-disable-next-line no-cond-assign

      while ((currentPos = trace(currentPos, true)) !== null) {
        top.push(points[currentPos]);
      }

      if (centerPos > 0) {
        currentPos = centerPos; // eslint-disable-next-line no-cond-assign

        while ((currentPos = trace(currentPos, false)) !== null) {
          top.push(points[currentPos]);
        }
      }

      if (top.length > result.length) {
        result = top;
      }
    }

    return result;
  }
};
var DILATE = 1;
var ERODE = 2;
function dilate(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum > 0 ? 1 : 0;
    }
  }
}
function erode(inImageWrapper, outImageWrapper) {
  var v;
  var u;
  var inImageData = inImageWrapper.data;
  var outImageData = outImageWrapper.data;
  var height = inImageWrapper.size.y;
  var width = inImageWrapper.size.x;
  var sum;
  var yStart1;
  var yStart2;
  var xStart1;
  var xStart2;

  for (v = 1; v < height - 1; v++) {
    for (u = 1; u < width - 1; u++) {
      yStart1 = v - 1;
      yStart2 = v + 1;
      xStart1 = u - 1;
      xStart2 = u + 1;
      sum = inImageData[yStart1 * width + xStart1] + inImageData[yStart1 * width + xStart2] + inImageData[v * width + u] + inImageData[yStart2 * width + xStart1] + inImageData[yStart2 * width + xStart2];
      outImageData[v * width + u] = sum === 5 ? 1 : 0;
    }
  }
}
function subtract(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] - bImageData[length];
  }
}
function bitwiseOr(aImageWrapper, bImageWrapper, resultImageWrapper) {
  if (!resultImageWrapper) {
    // eslint-disable-next-line no-param-reassign
    resultImageWrapper = aImageWrapper;
  }

  var length = aImageWrapper.data.length;
  var aImageData = aImageWrapper.data;
  var bImageData = bImageWrapper.data;
  var cImageData = resultImageWrapper.data;

  while (length--) {
    cImageData[length] = aImageData[length] || bImageData[length];
  }
}
function countNonZero(imageWrapper) {
  var length = imageWrapper.data.length;
  var data = imageWrapper.data;
  var sum = 0;

  while (length--) {
    sum += data[length];
  }

  return sum;
}
function topGeneric(list, top, scoreFunc) {
  var i;
  var minIdx = 0;
  var min = 0;
  var queue = [];
  var score;
  var hit;
  var pos;

  for (i = 0; i < top; i++) {
    queue[i] = {
      score: 0,
      item: null
    };
  }

  for (i = 0; i < list.length; i++) {
    score = scoreFunc.apply(this, [list[i]]);

    if (score > min) {
      hit = queue[minIdx];
      hit.score = score;
      hit.item = list[i];
      min = Number.MAX_VALUE;

      for (pos = 0; pos < top; pos++) {
        if (queue[pos].score < min) {
          min = queue[pos].score;
          minIdx = pos;
        }
      }
    }
  }

  return queue;
}
function grayArrayFromImage(htmlImage, offsetX, ctx, array) {
  ctx.drawImage(htmlImage, offsetX, 0, htmlImage.width, htmlImage.height);
  var ctxData = ctx.getImageData(offsetX, 0, htmlImage.width, htmlImage.height).data;
  computeGray(ctxData, array);
}
function grayArrayFromContext(ctx, size, offset, array) {
  var ctxData = ctx.getImageData(offset.x, offset.y, size.x, size.y).data;
  computeGray(ctxData, array);
}
function grayAndHalfSampleFromCanvasData(canvasData, size, outArray) {
  var topRowIdx = 0;
  var bottomRowIdx = size.x;
  var endIdx = Math.floor(canvasData.length / 4);
  var outWidth = size.x / 2;
  var outImgIdx = 0;
  var inWidth = size.x;
  var i;

  while (bottomRowIdx < endIdx) {
    for (i = 0; i < outWidth; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[outImgIdx] = (0.299 * canvasData[topRowIdx * 4 + 0] + 0.587 * canvasData[topRowIdx * 4 + 1] + 0.114 * canvasData[topRowIdx * 4 + 2] + (0.299 * canvasData[(topRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(topRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(topRowIdx + 1) * 4 + 2]) + (0.299 * canvasData[bottomRowIdx * 4 + 0] + 0.587 * canvasData[bottomRowIdx * 4 + 1] + 0.114 * canvasData[bottomRowIdx * 4 + 2]) + (0.299 * canvasData[(bottomRowIdx + 1) * 4 + 0] + 0.587 * canvasData[(bottomRowIdx + 1) * 4 + 1] + 0.114 * canvasData[(bottomRowIdx + 1) * 4 + 2])) / 4;
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function computeGray(imageData, outArray, config) {
  var l = imageData.length / 4 | 0;
  var singleChannel = config && config.singleChannel === true;

  if (singleChannel) {
    for (var i = 0; i < l; i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[i] = imageData[i * 4 + 0];
    }
  } else {
    for (var _i = 0; _i < l; _i++) {
      // eslint-disable-next-line no-param-reassign
      outArray[_i] = 0.299 * imageData[_i * 4 + 0] + 0.587 * imageData[_i * 4 + 1] + 0.114 * imageData[_i * 4 + 2];
    }
  }
}
function loadImageArray(src, callback) {
  var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document && document.createElement('canvas');
  var img = new Image();
  img.callback = callback;

  img.onload = function () {
    // eslint-disable-next-line no-param-reassign
    canvas.width = this.width; // eslint-disable-next-line no-param-reassign

    canvas.height = this.height;
    var ctx = canvas.getContext('2d');
    ctx.drawImage(this, 0, 0);
    var array = new Uint8Array(this.width * this.height);
    ctx.drawImage(this, 0, 0);

    var _ctx$getImageData = ctx.getImageData(0, 0, this.width, this.height),
        data = _ctx$getImageData.data;

    computeGray(data, array);
    this.callback(array, {
      x: this.width,
      y: this.height
    }, this);
  };

  img.src = src;
}
/**
 * @param inImg {ImageWrapper} input image to be sampled
 * @param outImg {ImageWrapper} to be stored in
 */

function halfSample(inImgWrapper, outImgWrapper) {
  var inImg = inImgWrapper.data;
  var inWidth = inImgWrapper.size.x;
  var outImg = outImgWrapper.data;
  var topRowIdx = 0;
  var bottomRowIdx = inWidth;
  var endIdx = inImg.length;
  var outWidth = inWidth / 2;
  var outImgIdx = 0;

  while (bottomRowIdx < endIdx) {
    for (var i = 0; i < outWidth; i++) {
      outImg[outImgIdx] = Math.floor((inImg[topRowIdx] + inImg[topRowIdx + 1] + inImg[bottomRowIdx] + inImg[bottomRowIdx + 1]) / 4);
      outImgIdx++;
      topRowIdx += 2;
      bottomRowIdx += 2;
    }

    topRowIdx += inWidth;
    bottomRowIdx += inWidth;
  }
}
function hsv2rgb(hsv) {
  var rgb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
  var h = hsv[0];
  var s = hsv[1];
  var v = hsv[2];
  var c = v * s;
  var x = c * (1 - Math.abs(h / 60 % 2 - 1));
  var m = v - c;
  var r = 0;
  var g = 0;
  var b = 0;

  if (h < 60) {
    r = c;
    g = x;
  } else if (h < 120) {
    r = x;
    g = c;
  } else if (h < 180) {
    g = c;
    b = x;
  } else if (h < 240) {
    g = x;
    b = c;
  } else if (h < 300) {
    r = x;
    b = c;
  } else if (h < 360) {
    r = c;
    b = x;
  } // eslint-disable-next-line no-param-reassign


  rgb[0] = (r + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[1] = (g + m) * 255 | 0; // eslint-disable-next-line no-param-reassign

  rgb[2] = (b + m) * 255 | 0;
  return rgb;
}
function _computeDivisors(n) {
  var largeDivisors = [];
  var divisors = [];

  for (var i = 1; i < Math.sqrt(n) + 1; i++) {
    if (n % i === 0) {
      divisors.push(i);

      if (i !== n / i) {
        largeDivisors.unshift(Math.floor(n / i));
      }
    }
  }

  return divisors.concat(largeDivisors);
}

function _computeIntersection(arr1, arr2) {
  var i = 0;
  var j = 0;
  var result = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] === arr2[j]) {
      result.push(arr1[i]);
      i++;
      j++;
    } else if (arr1[i] > arr2[j]) {
      j++;
    } else {
      i++;
    }
  }

  return result;
}

function calculatePatchSize(patchSize, imgSize) {
  var divisorsX = _computeDivisors(imgSize.x);

  var divisorsY = _computeDivisors(imgSize.y);

  var wideSide = Math.max(imgSize.x, imgSize.y);

  var common = _computeIntersection(divisorsX, divisorsY);

  var nrOfPatchesList = [8, 10, 15, 20, 32, 60, 80];
  var nrOfPatchesMap = {
    'x-small': 5,
    small: 4,
    medium: 3,
    large: 2,
    'x-large': 1
  };
  var nrOfPatchesIdx = nrOfPatchesMap[patchSize] || nrOfPatchesMap.medium;
  var nrOfPatches = nrOfPatchesList[nrOfPatchesIdx];
  var desiredPatchSize = Math.floor(wideSide / nrOfPatches);
  var optimalPatchSize;

  function findPatchSizeForDivisors(divisors) {
    var i = 0;
    var found = divisors[Math.floor(divisors.length / 2)];

    while (i < divisors.length - 1 && divisors[i] < desiredPatchSize) {
      i++;
    }

    if (i > 0) {
      if (Math.abs(divisors[i] - desiredPatchSize) > Math.abs(divisors[i - 1] - desiredPatchSize)) {
        found = divisors[i - 1];
      } else {
        found = divisors[i];
      }
    }

    if (desiredPatchSize / found < nrOfPatchesList[nrOfPatchesIdx + 1] / nrOfPatchesList[nrOfPatchesIdx] && desiredPatchSize / found > nrOfPatchesList[nrOfPatchesIdx - 1] / nrOfPatchesList[nrOfPatchesIdx]) {
      return {
        x: found,
        y: found
      };
    }

    return null;
  }

  optimalPatchSize = findPatchSizeForDivisors(common);

  if (!optimalPatchSize) {
    optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(wideSide));

    if (!optimalPatchSize) {
      optimalPatchSize = findPatchSizeForDivisors(_computeDivisors(desiredPatchSize * nrOfPatches));
    }
  }

  return optimalPatchSize;
}
function _parseCSSDimensionValues(value) {
  var dimension = {
    value: parseFloat(value),
    unit: value.indexOf('%') === value.length - 1 ? '%' : '%'
  };
  return dimension;
}
var _dimensionsConverters = {
  top: function top(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height * (dimension.value / 100)) : null;
  },
  right: function right(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width - context.width * (dimension.value / 100)) : null;
  },
  bottom: function bottom(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.height - context.height * (dimension.value / 100)) : null;
  },
  left: function left(dimension, context) {
    return dimension.unit === '%' ? Math.floor(context.width * (dimension.value / 100)) : null;
  }
};
function computeImageArea(inputWidth, inputHeight, area) {
  var context = {
    width: inputWidth,
    height: inputHeight
  };
  var parsedArea = Object.keys(area).reduce(function (result, key) {
    var value = area[key];

    var parsed = _parseCSSDimensionValues(value);

    var calculated = _dimensionsConverters[key](parsed, context); // eslint-disable-next-line no-param-reassign


    result[key] = calculated;
    return result;
  }, {});
  return {
    sx: parsedArea.left,
    sy: parsedArea.top,
    sw: parsedArea.right - parsedArea.left,
    sh: parsedArea.bottom - parsedArea.top
  };
}

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// TODO: XYPosition should be an XYObject, but that breaks XYDefinition, which breaks drawPath() below.
// XYDefinition tells us which component of a given array or object is the "X" and which is the "Y".
// Usually this is 0 for X and 1 for Y, but might be used as 'x' for x and 'y' for Y.
/* harmony default export */ __webpack_exports__["a"] = ({
  drawRect: function drawRect(pos, size, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth || 1;
    ctx.beginPath();
    ctx.strokeRect(pos.x, pos.y, size.x, size.y);
  },
  drawPath: function drawPath(path, def, ctx, style) {
    ctx.strokeStyle = style.color;
    ctx.fillStyle = style.color;
    ctx.lineWidth = style.lineWidth;
    ctx.beginPath();
    ctx.moveTo(path[0][def.x], path[0][def.y]);

    for (var j = 1; j < path.length; j++) {
      ctx.lineTo(path[j][def.x], path[j][def.y]);
    }

    ctx.closePath();
    ctx.stroke();
  },
  drawImage: function drawImage(imageData, size, ctx) {
    var canvasData = ctx.getImageData(0, 0, size.x, size.y);
    var data = canvasData.data;
    var canvasDataPos = data.length;
    var imageDataPos = imageData.length;

    if (canvasDataPos / imageDataPos !== 4) {
      return false;
    }

    while (imageDataPos--) {
      var value = imageData[imageDataPos];
      data[--canvasDataPos] = 255;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
      data[--canvasDataPos] = value;
    }

    ctx.putImageData(canvasData, 0, 0);
    return true;
  }
});

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(arr, val) {
    // arr.fill(val);
    var l = arr.length;

    while (l--) {
      arr[l] = val;
    }
  },

  /**
   * Shuffles the content of an array
   */
  shuffle: function shuffle(arr) {
    var i = arr.length - 1;

    for (i; i >= 0; i--) {
      var j = Math.floor(Math.random() * i);
      var x = arr[i];
      arr[i] = arr[j];
      arr[j] = x;
    }

    return arr;
  },
  toPointList: function toPointList(arr) {
    var rows = arr.reduce(function (p, n) {
      var row = "[".concat(n.join(','), "]");
      p.push(row);
      return p;
    }, []);
    return "[".concat(rows.join(',\r\n'), "]");
  },

  /**
   * returns the elements which's score is bigger than the threshold
   */
  threshold: function threshold(arr, _threshold, scoreFunc) {
    var queue = arr.reduce(function (prev, next) {
      if (scoreFunc.apply(arr, [next]) >= _threshold) {
        prev.push(next);
      }

      return prev;
    }, []);
    return queue;
  },
  maxIndex: function maxIndex(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > arr[max]) {
        max = i;
      }
    }

    return max;
  },
  max: function max(arr) {
    var max = 0;

    for (var i = 0; i < arr.length; i++) {
      if (arr[i] > max) {
        max = arr[i];
      }
    }

    return max;
  },
  sum: function sum(arr) {
    var length = arr.length;
    var sum = 0;

    while (length--) {
      sum += arr[length];
    }

    return sum;
  }
});

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(0);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _cv_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8);
/* harmony import */ var _array_helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);







var vec2 = {
  clone: gl_vec2__WEBPACK_IMPORTED_MODULE_4__["clone"]
};

function assertNumberPositive(val) {
  if (val < 0) {
    throw new Error("expected positive number, received ".concat(val));
  }
}

var ImageWrapper = /*#__PURE__*/function () {
  // Represents a basic image combining the data and size. In addition, some methods for
  // manipulation are contained within.
  function ImageWrapper(size, data) {
    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Uint8Array;
    var initialize = arguments.length > 3 ? arguments[3] : undefined;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, ImageWrapper);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "data", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "size", void 0);

    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_3___default()(this, "indexMapping", void 0);

    if (!data) {
      this.data = new ArrayType(size.x * size.y);

      if (initialize) {
        _array_helper__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].init(this.data, 0);
      }
    } else {
      this.data = data;
    }

    this.size = size;
  } // tests if a position is within the image, extended out by a border on each side


  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(ImageWrapper, [{
    key: "inImageWithBorder",
    value: function inImageWithBorder(imgRef) {
      var border = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      assertNumberPositive(border); // TODO: code_128 starts failing miserably when i only allow imgRef to contain positive numbers.
      // TODO: this doesn't make much sense to me, why does it go negative?  Tests are not affected by
      // returning false, but the whole code_128 reader blows up when i throw on negative imgRef.
      // assertNumberPositive(imgRef.x);
      // assertNumberPositive(imgRef.y);

      return imgRef.x >= 0 && imgRef.y >= 0 && imgRef.x < this.size.x + border * 2 && imgRef.y < this.size.y + border * 2;
    } // Copy from THIS ImageWrapper to the new imageWrapper parameter, starting at from, stopping at
    // end of new imageWrapper size.

  }, {
    key: "subImageAsCopy",
    value: function subImageAsCopy(imageWrapper, from) {
      assertNumberPositive(from.x);
      assertNumberPositive(from.y);
      var _imageWrapper$size = imageWrapper.size,
          sizeX = _imageWrapper$size.x,
          sizeY = _imageWrapper$size.y;

      for (var x = 0; x < sizeX; x++) {
        for (var y = 0; y < sizeY; y++) {
          // eslint-disable-next-line no-param-reassign
          imageWrapper.data[y * sizeX + x] = this.data[(from.y + y) * this.size.x + from.x + x];
        }
      }

      return imageWrapper; // TODO: this function really probably should call into ImageWrapper somewhere to make
      // sure that all of it's parameters are set properly, something like
      // ImageWrapper.UpdateFrom()
      // that might take a provided data and size, and make sure there's no invalid indexMapping
      // hanging around, and such.
    } // Retrieve a grayscale value at the given pixel position of the image

  }, {
    key: "get",
    value: function get(x, y) {
      return this.data[y * this.size.x + x];
    } // Retrieve a grayscale value at the given pixel position of the image (safe, whatever that
    // means)

  }, {
    key: "getSafe",
    value: function getSafe(x, y) {
      // cache indexMapping because if we're using it once, we'll probably need it a bunch more
      // too
      if (!this.indexMapping) {
        this.indexMapping = {
          x: [],
          y: []
        };

        for (var i = 0; i < this.size.x; i++) {
          this.indexMapping.x[i] = i;
          this.indexMapping.x[i + this.size.x] = i;
        }

        for (var _i = 0; _i < this.size.y; _i++) {
          this.indexMapping.y[_i] = _i;
          this.indexMapping.y[_i + this.size.y] = _i;
        }
      }

      return this.data[this.indexMapping.y[y + this.size.y] * this.size.x + this.indexMapping.x[x + this.size.x]];
    } // Sets a given pixel position in the image to the given grayscale value

  }, {
    key: "set",
    value: function set(x, y, value) {
      this.data[y * this.size.x + x] = value;
      delete this.indexMapping;
      return this;
    } // Sets the border of the image (1 pixel) to zero

  }, {
    key: "zeroBorder",
    value: function zeroBorder() {
      var _this$size = this.size,
          width = _this$size.x,
          height = _this$size.y;

      for (var i = 0; i < width; i++) {
        // eslint-disable-next-line no-multi-assign
        this.data[i] = this.data[(height - 1) * width + i] = 0;
      }

      for (var _i2 = 1; _i2 < height - 1; _i2++) {
        // eslint-disable-next-line no-multi-assign
        this.data[_i2 * width] = this.data[_i2 * width + (width - 1)] = 0;
      }

      delete this.indexMapping;
      return this;
    } // TODO: this function is entirely too large for me to reason out right at this moment that i'm handling
    // all the rest of it, so this is a verbatim copy of the javascript source, with only tweaks
    // necessary to get it to run, no thought put into it yet.

  }, {
    key: "moments",
    value: function moments(labelCount) {
      var data = this.data;
      var x;
      var y;
      var height = this.size.y;
      var width = this.size.x;
      var val;
      var ysq;
      var labelSum = [];
      var i;
      var label;
      var mu11;
      var mu02;
      var mu20;
      var x_;
      var y_;
      var tmp;
      var result = [];
      var PI = Math.PI;
      var PI_4 = PI / 4;

      if (labelCount <= 0) {
        return result;
      }

      for (i = 0; i < labelCount; i++) {
        labelSum[i] = {
          m00: 0,
          m01: 0,
          m10: 0,
          m11: 0,
          m02: 0,
          m20: 0,
          theta: 0,
          rad: 0
        };
      }

      for (y = 0; y < height; y++) {
        ysq = y * y;

        for (x = 0; x < width; x++) {
          val = data[y * width + x];

          if (val > 0) {
            label = labelSum[val - 1];
            label.m00 += 1;
            label.m01 += y;
            label.m10 += x;
            label.m11 += x * y;
            label.m02 += ysq;
            label.m20 += x * x;
          }
        }
      }

      for (i = 0; i < labelCount; i++) {
        label = labelSum[i]; // eslint-disable-next-line no-restricted-globals

        if (!isNaN(label.m00) && label.m00 !== 0) {
          x_ = label.m10 / label.m00;
          y_ = label.m01 / label.m00;
          mu11 = label.m11 / label.m00 - x_ * y_;
          mu02 = label.m02 / label.m00 - y_ * y_;
          mu20 = label.m20 / label.m00 - x_ * x_;
          tmp = (mu02 - mu20) / (2 * mu11);
          tmp = 0.5 * Math.atan(tmp) + (mu11 >= 0 ? PI_4 : -PI_4) + PI; // eslint-disable-next-line no-mixed-operators

          label.theta = (tmp * 180 / PI + 90) % 180 - 90;

          if (label.theta < 0) {
            label.theta += 180;
          }

          label.rad = tmp > PI ? tmp - PI : tmp;
          label.vec = vec2.clone([Math.cos(tmp), Math.sin(tmp)]);
          result.push(label);
        }
      }

      return result;
    } // return a Uint8ClampedArray containing this grayscale image converted to RGBA form

  }, {
    key: "getAsRGBA",
    value: function getAsRGBA() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var ret = new Uint8ClampedArray(4 * this.size.x * this.size.y);

      for (var y = 0; y < this.size.y; y++) {
        for (var x = 0; x < this.size.x; x++) {
          var pixel = y * this.size.x + x;
          var current = this.get(x, y) * scale;
          ret[pixel * 4 + 0] = current;
          ret[pixel * 4 + 1] = current;
          ret[pixel * 4 + 2] = current;
          ret[pixel * 4 + 3] = 255;
        }
      }

      return ret;
    } // Display this ImageWrapper in a given Canvas element at the specified scale

  }, {
    key: "show",
    value: function show(canvas) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var data = this.getAsRGBA(scale); // eslint-disable-next-line no-param-reassign

      canvas.width = this.size.x; // eslint-disable-next-line no-param-reassign

      canvas.height = this.size.y;
      var newFrame = new ImageData(data, frame.width, frame.height);
      ctx.putImageData(newFrame, 0, 0);
    } // Displays a specified SubImage area in a given canvas. This differs drastically from
    // creating a new SubImage and using it's show() method. Why? I don't have the answer to that
    // yet.  I suspect the HSV/RGB operations involved here are making it significantly different,
    // but until I can visualize these functions side by side, I'm just going to copy the existing
    // implementation.

  }, {
    key: "overlay",
    value: function overlay(canvas, inScale, from) {
      var adjustedScale = inScale < 0 || inScale > 360 ? 360 : inScale;
      var hsv = [0, 1, 1];
      var rgb = [0, 0, 0];
      var whiteRgb = [255, 255, 255];
      var blackRgb = [0, 0, 0];
      var result = [];
      var ctx = canvas.getContext('2d');

      if (!ctx) {
        throw new Error('Unable to get canvas context');
      }

      var frame = ctx.getImageData(from.x, from.y, this.size.x, this.size.y);
      var data = frame.data;
      var length = this.data.length;

      while (length--) {
        hsv[0] = this.data[length] * adjustedScale; // eslint-disable-next-line no-nested-ternary

        result = hsv[0] <= 0 ? whiteRgb : hsv[0] >= 360 ? blackRgb : Object(_cv_utils__WEBPACK_IMPORTED_MODULE_5__["hsv2rgb"])(hsv, rgb);
        var pos = length * 4;
        var _result = result;

        var _result2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_result, 3);

        data[pos] = _result2[0];
        data[pos + 1] = _result2[1];
        data[pos + 2] = _result2[2];
        data[pos + 3] = 255;
      }

      ctx.putImageData(frame, from.x, from.y);
    }
  }]);

  return ImageWrapper;
}();

/* harmony default export */ __webpack_exports__["a"] = (ImageWrapper);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.15';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof global=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&typeof module=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// with lookup (in case of e.g. prototype pollution), and strip newlines if any.
// A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/[\r\n]/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
// Like with sourceURL, we take care to not check the option's prototype,
// as this configuration is a code injection vector.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13), __webpack_require__(141)(module)))

/***/ }),
/* 13 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 14 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

var Readable = __webpack_require__(57);

var Writable = __webpack_require__(33);

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var superPropBase = __webpack_require__(145);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(146);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),
/* 19 */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */
var Tracer = {
  searchDirections: [[0, 1], [1, 1], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0], [-1, 1]],
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var searchDirections = this.searchDirections;
    var width = imageWrapper.size.x;
    var pos;

    function _trace(current, color, label, edgelabel) {
      var i;
      var y;
      var x;

      for (i = 0; i < 7; i++) {
        y = current.cy + searchDirections[current.dir][0];
        x = current.cx + searchDirections[current.dir][1];
        pos = y * width + x;

        if (imageData[pos] === color && (labelData[pos] === 0 || labelData[pos] === label)) {
          labelData[pos] = label;
          current.cy = y;
          current.cx = x;
          return true;
        }

        if (labelData[pos] === 0) {
          labelData[pos] = edgelabel;
        }

        current.dir = (current.dir + 1) % 8;
      }

      return false;
    }

    function vertex2D(x, y, dir) {
      return {
        dir: dir,
        x: x,
        y: y,
        next: null,
        prev: null
      };
    }

    function _contourTracing(sy, sx, label, color, edgelabel) {
      var Fv = null;
      var Cv;
      var P;
      var ldir;
      var current = {
        cx: sx,
        cy: sy,
        dir: 0
      };

      if (_trace(current, color, label, edgelabel)) {
        Fv = vertex2D(sx, sy, current.dir);
        Cv = Fv;
        ldir = current.dir;
        P = vertex2D(current.cx, current.cy, 0);
        P.prev = Cv;
        Cv.next = P;
        P.next = null;
        Cv = P;

        do {
          current.dir = (current.dir + 6) % 8;

          _trace(current, color, label, edgelabel);

          if (ldir !== current.dir) {
            Cv.dir = current.dir;
            P = vertex2D(current.cx, current.cy, 0);
            P.prev = Cv;
            Cv.next = P;
            P.next = null;
            Cv = P;
          } else {
            Cv.dir = ldir;
            Cv.x = current.cx;
            Cv.y = current.cy;
          }

          ldir = current.dir;
        } while (current.cx !== sx || current.cy !== sy);

        Fv.prev = Cv.prev;
        Cv.prev.next = Fv;
      }

      return Fv;
    }

    return {
      trace: function trace(current, color, label, edgelabel) {
        return _trace(current, color, label, edgelabel);
      },
      contourTracing: function contourTracing(sy, sx, label, color, edgelabel) {
        return _contourTracing(sy, sx, label, color, edgelabel);
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Tracer);

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(159);

var ieee754 = __webpack_require__(160);

var isArray = __webpack_require__(161);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function () {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(21).Buffer))

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var gl_vec2__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gl_vec2__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var gl_mat2__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(gl_mat2__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11);
/* harmony import */ var _common_cv_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _common_array_helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _common_image_debug__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _rasterizer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(64);
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20);
/* harmony import */ var _skeletonizer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(65);










var _config;

var _currentImageWrapper;

var _skelImageWrapper;

var _subImageWrapper;

var _labelImageWrapper;

var _patchGrid;

var _patchLabelGrid;

var _imageToPatchGrid;

var _binaryImageWrapper;

var _patchSize;

var _canvasContainer = {
  ctx: {
    binary: null
  },
  dom: {
    binary: null
  }
};
var _numPatches = {
  x: 0,
  y: 0
};

var _inputImageWrapper;

var _skeletonizer;

function initBuffers() {
  if (_config.halfSample) {
    _currentImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
      // eslint-disable-next-line no-bitwise
      x: _inputImageWrapper.size.x / 2 | 0,
      // eslint-disable-next-line no-bitwise
      y: _inputImageWrapper.size.y / 2 | 0
    });
  } else {
    _currentImageWrapper = _inputImageWrapper;
  }

  _patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(_config.patchSize, _currentImageWrapper.size); // eslint-disable-next-line no-bitwise

  _numPatches.x = _currentImageWrapper.size.x / _patchSize.x | 0; // eslint-disable-next-line no-bitwise

  _numPatches.y = _currentImageWrapper.size.y / _patchSize.y | 0;
  _binaryImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_currentImageWrapper.size, undefined, Uint8Array, false);
  _labelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, undefined, Array, true);
  var skeletonImageData = new ArrayBuffer(64 * 1024);
  _subImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, 0, _patchSize.x * _patchSize.y));
  _skelImageWrapper = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_patchSize, new Uint8Array(skeletonImageData, _patchSize.x * _patchSize.y * 3, _patchSize.x * _patchSize.y), undefined, true);
  _skeletonizer = Object(_skeletonizer__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])(typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, {
    size: _patchSize.x
  }, skeletonImageData);
  _imageToPatchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]({
    // eslint-disable-next-line no-bitwise
    x: _currentImageWrapper.size.x / _subImageWrapper.size.x | 0,
    // eslint-disable-next-line no-bitwise
    y: _currentImageWrapper.size.y / _subImageWrapper.size.y | 0
  }, undefined, Array, true);
  _patchGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, undefined, true);
  _patchLabelGrid = new _common_image_wrapper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](_imageToPatchGrid.size, undefined, Int32Array, true);
}

function initCanvas() {
  if (_config.useWorker || typeof document === 'undefined') {
    return;
  }

  _canvasContainer.dom.binary = document.createElement('canvas');
  _canvasContainer.dom.binary.className = 'binaryBuffer';

  if ( true && _config.debug.showCanvas === true) {
    document.querySelector('#debug').appendChild(_canvasContainer.dom.binary);
  }

  _canvasContainer.ctx.binary = _canvasContainer.dom.binary.getContext('2d');
  _canvasContainer.dom.binary.width = _binaryImageWrapper.size.x;
  _canvasContainer.dom.binary.height = _binaryImageWrapper.size.y;
}
/**
 * Creates a bounding box which encloses all the given patches
 * @returns {Array} The minimal bounding box
 */


function boxFromPatches(patches) {
  var overAvg;
  var i;
  var j;
  var patch;
  var transMat;
  var minx = _binaryImageWrapper.size.x;
  var miny = _binaryImageWrapper.size.y;
  var maxx = -_binaryImageWrapper.size.x;
  var maxy = -_binaryImageWrapper.size.y;
  var box;
  var scale; // draw all patches which are to be taken into consideration

  overAvg = 0;

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];
    overAvg += patch.rad;

    if ( true && _config.debug.showPatches) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: 'red'
      });
    }
  }

  overAvg /= patches.length;
  overAvg = (overAvg * 180 / Math.PI + 90) % 180 - 90;

  if (overAvg < 0) {
    overAvg += 180;
  }

  overAvg = (180 - overAvg) * Math.PI / 180;
  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["copy"](gl_mat2__WEBPACK_IMPORTED_MODULE_1__["create"](), [Math.cos(overAvg), Math.sin(overAvg), -Math.sin(overAvg), Math.cos(overAvg)]); // iterate over patches and rotate by angle

  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](patch.box[j], patch.box[j], transMat);
    }

    if ( true && _config.debug.boxFromPatches.showTransformed) {
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(patch.box, {
        x: 0,
        y: 1
      }, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  } // find bounding box


  for (i = 0; i < patches.length; i++) {
    patch = patches[i];

    for (j = 0; j < 4; j++) {
      if (patch.box[j][0] < minx) {
        minx = patch.box[j][0];
      }

      if (patch.box[j][0] > maxx) {
        maxx = patch.box[j][0];
      }

      if (patch.box[j][1] < miny) {
        miny = patch.box[j][1];
      }

      if (patch.box[j][1] > maxy) {
        maxy = patch.box[j][1];
      }
    }
  }

  box = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];

  if ( true && _config.debug.boxFromPatches.showTransformedBox) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  scale = _config.halfSample ? 2 : 1; // reverse rotation;

  transMat = gl_mat2__WEBPACK_IMPORTED_MODULE_1__["invert"](transMat, transMat);

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["transformMat2"](box[j], box[j], transMat);
  }

  if ( true && _config.debug.boxFromPatches.showBB) {
    _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawPath(box, {
      x: 0,
      y: 1
    }, _canvasContainer.ctx.binary, {
      color: '#ff0000',
      lineWidth: 2
    });
  }

  for (j = 0; j < 4; j++) {
    gl_vec2__WEBPACK_IMPORTED_MODULE_0__["scale"](box[j], box[j], scale);
  }

  return box;
}
/**
 * Creates a binary image of the current image
 */


function binarizeImage() {
  Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["otsuThreshold"])(_currentImageWrapper, _binaryImageWrapper);

  _binaryImageWrapper.zeroBorder();

  if ( true && _config.debug.showCanvas) {
    _binaryImageWrapper.show(_canvasContainer.dom.binary, 255);
  }
}
/**
 * Iterate over the entire image
 * extract patches
 */


function findPatches() {
  var i;
  var j;
  var x;
  var y;
  var moments;
  var patchesFound = [];
  var rasterizer;
  var rasterResult;
  var patch;

  for (i = 0; i < _numPatches.x; i++) {
    for (j = 0; j < _numPatches.y; j++) {
      x = _subImageWrapper.size.x * i;
      y = _subImageWrapper.size.y * j; // seperate parts

      skeletonize(x, y); // Rasterize, find individual bars

      _skelImageWrapper.zeroBorder();

      _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_labelImageWrapper.data, 0);
      rasterizer = _rasterizer__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].create(_skelImageWrapper, _labelImageWrapper);
      rasterResult = rasterizer.rasterize(0);

      if ( true && _config.debug.showLabels) {
        _labelImageWrapper.overlay(_canvasContainer.dom.binary, Math.floor(360 / rasterResult.count), {
          x: x,
          y: y
        });
      } // calculate moments from the skeletonized patch


      moments = _labelImageWrapper.moments(rasterResult.count); // extract eligible patches

      patchesFound = patchesFound.concat(describePatch(moments, [i, j], x, y));
    }
  }

  if ( true && _config.debug.showFoundPatches) {
    for (i = 0; i < patchesFound.length; i++) {
      patch = patchesFound[i];
      _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
        color: '#99ff00',
        lineWidth: 2
      });
    }
  }

  return patchesFound;
}
/**
 * Finds those connected areas which contain at least 6 patches
 * and returns them ordered DESC by the number of contained patches
 * @param {Number} maxLabel
 */


function findBiggestConnectedAreas(maxLabel) {
  var i;
  var sum;
  var labelHist = [];
  var topLabels = [];

  for (i = 0; i < maxLabel; i++) {
    labelHist.push(0);
  }

  sum = _patchLabelGrid.data.length;

  while (sum--) {
    if (_patchLabelGrid.data[sum] > 0) {
      labelHist[_patchLabelGrid.data[sum] - 1]++;
    }
  }

  labelHist = labelHist.map(function (val, idx) {
    return {
      val: val,
      label: idx + 1
    };
  });
  labelHist.sort(function (a, b) {
    return b.val - a.val;
  }); // extract top areas with at least 6 patches present

  topLabels = labelHist.filter(function (el) {
    return el.val >= 5;
  });
  return topLabels;
}
/**
 *
 */


function findBoxes(topLabels, maxLabel) {
  var i;
  var j;
  var sum;
  var patches = [];
  var patch;
  var box;
  var boxes = [];
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  for (i = 0; i < topLabels.length; i++) {
    sum = _patchLabelGrid.data.length;
    patches.length = 0;

    while (sum--) {
      if (_patchLabelGrid.data[sum] === topLabels[i].label) {
        patch = _imageToPatchGrid.data[sum];
        patches.push(patch);
      }
    }

    box = boxFromPatches(patches);

    if (box) {
      boxes.push(box); // draw patch-labels if requested

      if ( true && _config.debug.showRemainingPatchLabels) {
        for (j = 0; j < patches.length; j++) {
          patch = patches[j];
          hsv[0] = topLabels[i].label / (maxLabel + 1) * 360;
          Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
          _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
            color: "rgb(".concat(rgb.join(','), ")"),
            lineWidth: 2
          });
        }
      }
    }
  }

  return boxes;
}
/**
 * Find similar moments (via cluster)
 * @param {Object} moments
 */


function similarMoments(moments) {
  var clusters = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["cluster"])(moments, 0.90);
  var topCluster = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["topGeneric"])(clusters, 1, function (e) {
    return e.getPoints().length;
  });
  var points = [];
  var result = [];

  if (topCluster.length === 1) {
    points = topCluster[0].item.getPoints();

    for (var i = 0; i < points.length; i++) {
      result.push(points[i].point);
    }
  }

  return result;
}

function skeletonize(x, y) {
  _binaryImageWrapper.subImageAsCopy(_subImageWrapper, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));

  _skeletonizer.skeletonize(); // Show skeleton if requested


  if ( true && _config.debug.showSkeleton) {
    _skelImageWrapper.overlay(_canvasContainer.dom.binary, 360, Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["imageRef"])(x, y));
  }
}
/**
 * Extracts and describes those patches which seem to contain a barcode pattern
 * @param {Array} moments
 * @param {Object} patchPos,
 * @param {Number} x
 * @param {Number} y
 * @returns {Array} list of patches
 */


function describePatch(moments, patchPos, x, y) {
  var k;
  var avg;
  var eligibleMoments = [];
  var matchingMoments;
  var patch;
  var patchesFound = [];
  var minComponentWeight = Math.ceil(_patchSize.x / 3);

  if (moments.length >= 2) {
    // only collect moments which's area covers at least minComponentWeight pixels.
    for (k = 0; k < moments.length; k++) {
      if (moments[k].m00 > minComponentWeight) {
        eligibleMoments.push(moments[k]);
      }
    } // if at least 2 moments are found which have at least minComponentWeights covered


    if (eligibleMoments.length >= 2) {
      matchingMoments = similarMoments(eligibleMoments);
      avg = 0; // determine the similarity of the moments

      for (k = 0; k < matchingMoments.length; k++) {
        avg += matchingMoments[k].rad;
      } // Only two of the moments are allowed not to fit into the equation
      // add the patch to the set


      if (matchingMoments.length > 1 && matchingMoments.length >= eligibleMoments.length / 4 * 3 && matchingMoments.length > moments.length / 4) {
        avg /= matchingMoments.length;
        patch = {
          index: patchPos[1] * _numPatches.x + patchPos[0],
          pos: {
            x: x,
            y: y
          },
          box: [gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x + _subImageWrapper.size.x, y + _subImageWrapper.size.y]), gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([x, y + _subImageWrapper.size.y])],
          moments: matchingMoments,
          rad: avg,
          vec: gl_vec2__WEBPACK_IMPORTED_MODULE_0__["clone"]([Math.cos(avg), Math.sin(avg)])
        };
        patchesFound.push(patch);
      }
    }
  }

  return patchesFound;
}
/**
 * finds patches which are connected and share the same orientation
 * @param {Object} patchesFound
 */


function rasterizeAngularSimilarity(patchesFound) {
  var label = 0;
  var threshold = 0.95;
  var currIdx = 0;
  var j;
  var patch;
  var hsv = [0, 1, 1];
  var rgb = [0, 0, 0];

  function notYetProcessed() {
    var i;

    for (i = 0; i < _patchLabelGrid.data.length; i++) {
      if (_patchLabelGrid.data[i] === 0 && _patchGrid.data[i] === 1) {
        return i;
      }
    }

    return _patchLabelGrid.length;
  }

  function trace(currentIdx) {
    var x;
    var y;
    var currentPatch;
    var idx;
    var dir;
    var current = {
      x: currentIdx % _patchLabelGrid.size.x,
      y: currentIdx / _patchLabelGrid.size.x | 0
    };
    var similarity;

    if (currentIdx < _patchLabelGrid.data.length) {
      currentPatch = _imageToPatchGrid.data[currentIdx]; // assign label

      _patchLabelGrid.data[currentIdx] = label;

      for (dir = 0; dir < _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections.length; dir++) {
        y = current.y + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][0];
        x = current.x + _tracer__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].searchDirections[dir][1];
        idx = y * _patchLabelGrid.size.x + x; // continue if patch empty

        if (_patchGrid.data[idx] === 0) {
          _patchLabelGrid.data[idx] = Number.MAX_VALUE; // eslint-disable-next-line no-continue

          continue;
        }

        if (_patchLabelGrid.data[idx] === 0) {
          similarity = Math.abs(gl_vec2__WEBPACK_IMPORTED_MODULE_0__["dot"](_imageToPatchGrid.data[idx].vec, currentPatch.vec));

          if (similarity > threshold) {
            trace(idx);
          }
        }
      }
    }
  } // prepare for finding the right patches


  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_patchLabelGrid.data, 0);
  _common_array_helper__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].init(_imageToPatchGrid.data, null);

  for (j = 0; j < patchesFound.length; j++) {
    patch = patchesFound[j];
    _imageToPatchGrid.data[patch.index] = patch;
    _patchGrid.data[patch.index] = 1;
  } // rasterize the patches found to determine area


  _patchGrid.zeroBorder(); // eslint-disable-next-line no-cond-assign


  while ((currIdx = notYetProcessed()) < _patchLabelGrid.data.length) {
    label++;
    trace(currIdx);
  } // draw patch-labels if requested


  if ( true && _config.debug.showPatchLabels) {
    for (j = 0; j < _patchLabelGrid.data.length; j++) {
      if (_patchLabelGrid.data[j] > 0 && _patchLabelGrid.data[j] <= label) {
        patch = _imageToPatchGrid.data[j];
        hsv[0] = _patchLabelGrid.data[j] / (label + 1) * 360;
        Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["hsv2rgb"])(hsv, rgb);
        _common_image_debug__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].drawRect(patch.pos, _subImageWrapper.size, _canvasContainer.ctx.binary, {
          color: "rgb(".concat(rgb.join(','), ")"),
          lineWidth: 2
        });
      }
    }
  }

  return label;
}

/* harmony default export */ __webpack_exports__["a"] = ({
  init: function init(inputImageWrapper, config) {
    _config = config;
    _inputImageWrapper = inputImageWrapper;
    initBuffers();
    initCanvas();
  },
  locate: function locate() {
    if (_config.halfSample) {
      Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["halfSample"])(_inputImageWrapper, _currentImageWrapper);
    }

    binarizeImage();
    var patchesFound = findPatches(); // return unless 5% or more patches are found

    if (patchesFound.length < _numPatches.x * _numPatches.y * 0.05) {
      return null;
    } // rasterrize area by comparing angular similarity;


    var maxLabel = rasterizeAngularSimilarity(patchesFound);

    if (maxLabel < 1) {
      return null;
    } // search for area with the most patches (biggest connected area)


    var topLabels = findBiggestConnectedAreas(maxLabel);

    if (topLabels.length === 0) {
      return null;
    }

    var boxes = findBoxes(topLabels, maxLabel);
    return boxes;
  },
  checkImageConstraints: function checkImageConstraints(inputStream, config) {
    var patchSize;
    var width = inputStream.getWidth();
    var height = inputStream.getHeight();
    var thisHalfSample = config.halfSample ? 0.5 : 1;
    var area; // calculate width and height based on area

    if (inputStream.getConfig().area) {
      area = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["computeImageArea"])(width, height, inputStream.getConfig().area);
      inputStream.setTopRight({
        x: area.sx,
        y: area.sy
      });
      inputStream.setCanvasSize({
        x: width,
        y: height
      });
      width = area.sw;
      height = area.sh;
    }

    var size = {
      x: Math.floor(width * thisHalfSample),
      y: Math.floor(height * thisHalfSample)
    };
    patchSize = Object(_common_cv_utils__WEBPACK_IMPORTED_MODULE_3__["calculatePatchSize"])(config.patchSize, size);

    if (true) {
      console.log("Patch-Size: ".concat(JSON.stringify(patchSize)));
    }

    inputStream.setWidth(Math.floor(Math.floor(size.x / patchSize.x) * (1 / thisHalfSample) * patchSize.x));
    inputStream.setHeight(Math.floor(Math.floor(size.y / patchSize.y) * (1 / thisHalfSample) * patchSize.y));

    if (inputStream.getWidth() % patchSize.x === 0 && inputStream.getHeight() % patchSize.y === 0) {
      return true;
    }

    throw new Error("Image dimensions do not comply with the current settings: Width (".concat(width, " )and height (").concat(height, ") must a multiple of ").concat(patchSize.x));
  }
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);

    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(69);

var iterableToArrayLimit = __webpack_require__(70);

var unsupportedIterableToArray = __webpack_require__(34);

var nonIterableRest = __webpack_require__(71);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(142);

var iterableToArray = __webpack_require__(143);

var unsupportedIterableToArray = __webpack_require__(34);

var nonIterableSpread = __webpack_require__(144);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  determinant: __webpack_require__(147),
  transpose: __webpack_require__(148),
  multiply: __webpack_require__(149),
  identity: __webpack_require__(150),
  adjoint: __webpack_require__(151),
  rotate: __webpack_require__(152),
  invert: __webpack_require__(153),
  create: __webpack_require__(154),
  scale: __webpack_require__(155),
  copy: __webpack_require__(156),
  frob: __webpack_require__(157),
  ldu: __webpack_require__(158)
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var iota = __webpack_require__(163);

var isBuffer = __webpack_require__(164);

var hasTypedArrays = typeof Float64Array !== "undefined";

function compare1st(a, b) {
  return a[0] - b[0];
}

function order() {
  var stride = this.stride;
  var terms = new Array(stride.length);
  var i;

  for (i = 0; i < terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i];
  }

  terms.sort(compare1st);
  var result = new Array(terms.length);

  for (i = 0; i < result.length; ++i) {
    result[i] = terms[i][1];
  }

  return result;
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("");

  if (dimension < 0) {
    className = "View_Nil" + dtype;
  }

  var useGetters = dtype === "generic";

  if (dimension === -1) {
    //Special case for trivial arrays
    var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
    var procedure = new Function(code);
    return procedure();
  } else if (dimension === 0) {
    //Special case for 0d arrays
    var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
    var procedure = new Function("TrivialArray", code);
    return procedure(CACHED_CONSTRUCTORS[dtype][0]);
  }

  var code = ["'use strict'"]; //Create constructor for view

  var indices = iota(dimension);
  var args = indices.map(function (i) {
    return "i" + i;
  });
  var index_str = "this.offset+" + indices.map(function (i) {
    return "this.stride[" + i + "]*i" + i;
  }).join("+");
  var shapeArg = indices.map(function (i) {
    return "b" + i;
  }).join(",");
  var strideArg = indices.map(function (i) {
    return "c" + i;
  }).join(",");
  code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension); //view.size:

  code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function (i) {
    return "this.shape[" + i + "]";
  }).join("*"), "}})"); //view.order:

  if (dimension === 1) {
    code.push("proto.order=[0]");
  } else {
    code.push("Object.defineProperty(proto,'order',{get:");

    if (dimension < 4) {
      code.push("function " + className + "_order(){");

      if (dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
      } else if (dimension === 3) {
        code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
      }
    } else {
      code.push("ORDER})");
    }
  } //view.set(i0, ..., v):


  code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");

  if (useGetters) {
    code.push("return this.data.set(" + index_str + ",v)}");
  } else {
    code.push("return this.data[" + index_str + "]=v}");
  } //view.get(i0, ...):


  code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");

  if (useGetters) {
    code.push("return this.data.get(" + index_str + ")}");
  } else {
    code.push("return this.data[" + index_str + "]}");
  } //view.index:


  code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}"); //view.hi():

  code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function (i) {
    return ["(typeof i", i, "!=='number'||i", i, "<0)?this.shape[", i, "]:i", i, "|0"].join("");
  }).join(",") + "," + indices.map(function (i) {
    return "this.stride[" + i + "]";
  }).join(",") + ",this.offset)}"); //view.lo():

  var a_vars = indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  });
  var c_vars = indices.map(function (i) {
    return "c" + i + "=this.stride[" + i + "]";
  });
  code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
  }

  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "c" + i;
  }).join(",") + ",b)}"); //view.step():

  code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function (i) {
    return "a" + i + "=this.shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i + "=this.stride[" + i + "]";
  }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
  }

  code.push("return new " + className + "(this.data," + indices.map(function (i) {
    return "a" + i;
  }).join(",") + "," + indices.map(function (i) {
    return "b" + i;
  }).join(",") + ",c)}"); //view.transpose():

  var tShape = new Array(dimension);
  var tStride = new Array(dimension);

  for (var i = 0; i < dimension; ++i) {
    tShape[i] = "a[i" + i + "]";
    tStride[i] = "b[i" + i + "]";
  }

  code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function (n, idx) {
    return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
  }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}"); //view.pick():

  code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");

  for (var i = 0; i < dimension; ++i) {
    code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
  }

  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"); //Add return statement

  code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function (i) {
    return "shape[" + i + "]";
  }).join(",") + "," + indices.map(function (i) {
    return "stride[" + i + "]";
  }).join(",") + ",offset)}"); //Compile procedure

  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
  return procedure(CACHED_CONSTRUCTORS[dtype], order);
}

function arrayDType(data) {
  if (isBuffer(data)) {
    return "buffer";
  }

  if (hasTypedArrays) {
    switch (Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64";

      case "[object Float32Array]":
        return "float32";

      case "[object Int8Array]":
        return "int8";

      case "[object Int16Array]":
        return "int16";

      case "[object Int32Array]":
        return "int32";

      case "[object Uint8Array]":
        return "uint8";

      case "[object Uint16Array]":
        return "uint16";

      case "[object Uint32Array]":
        return "uint32";

      case "[object Uint8ClampedArray]":
        return "uint8_clamped";

      case "[object BigInt64Array]":
        return "bigint64";

      case "[object BigUint64Array]":
        return "biguint64";
    }
  }

  if (Array.isArray(data)) {
    return "array";
  }

  return "generic";
}

var CACHED_CONSTRUCTORS = {
  "float32": [],
  "float64": [],
  "int8": [],
  "int16": [],
  "int32": [],
  "uint8": [],
  "uint16": [],
  "uint32": [],
  "array": [],
  "uint8_clamped": [],
  "bigint64": [],
  "biguint64": [],
  "buffer": [],
  "generic": []
};

(function () {
  for (var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if (data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0];
    return ctor([]);
  } else if (typeof data === "number") {
    data = [data];
  }

  if (shape === undefined) {
    shape = [data.length];
  }

  var d = shape.length;

  if (stride === undefined) {
    stride = new Array(d);

    for (var i = d - 1, sz = 1; i >= 0; --i) {
      stride[i] = sz;
      sz *= shape[i];
    }
  }

  if (offset === undefined) {
    offset = 0;

    for (var i = 0; i < d; ++i) {
      if (stride[i] < 0) {
        offset -= (shape[i] - 1) * stride[i];
      }
    }
  }

  var dtype = arrayDType(data);
  var ctor_list = CACHED_CONSTRUCTORS[dtype];

  while (ctor_list.length <= d + 1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
  }

  var ctor = ctor_list[d + 1];
  return ctor(data, shape, stride, offset);
}

module.exports = wrappedNDArrayCtor;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) copy[i] = arr[i];

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(57);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(33);
exports.Duplex = __webpack_require__(15);
exports.Transform = __webpack_require__(61);
exports.PassThrough = __webpack_require__(182);

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(21);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(180)
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(58);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(32).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__(59);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(15);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(15); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14), __webpack_require__(178).setImmediate, __webpack_require__(13)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(35);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 35 */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new Float32Array(2);
  out[0] = 0;
  out[1] = 0;
  return out;
}

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = 0.000001;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new Float32Array(3);
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new Float32Array(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }

  return out;
}

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = subtract;
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = divide;
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/***/ }),
/* 53 */
/***/ (function(module, exports) {

module.exports = distance;
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 54 */
/***/ (function(module, exports) {

module.exports = squaredDistance;
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1],
      z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 55 */
/***/ (function(module, exports) {

module.exports = length;
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = squaredLength;
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  return x * x + y * y + z * z;
}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__(174);
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__(30).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(58);
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__(32).Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__(175);

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


var BufferList = __webpack_require__(176);

var destroyImpl = __webpack_require__(59);

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(15);
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(60).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(15);
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(60).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13), __webpack_require__(14)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(30).EventEmitter;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__(24);
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__(181).Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__(15);
/*<replacement>*/


var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

var CVUtils = __webpack_require__(8);

var Ndarray = __webpack_require__(29);

var Interp2D = __webpack_require__(188).d2;

var FrameGrabber = {};

FrameGrabber.create = function (inputStream) {
  var _that = {};

  var _videoSize = CVUtils.imageRef(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = CVUtils.imageRef(inputStream.getWidth(), inputStream.getHeight());

  var _topRight = inputStream.getTopRight();

  var _data = new Uint8Array(_size.x * _size.y);

  var _grayData = new Uint8Array(_videoSize.x * _videoSize.y);

  var _canvasData = new Uint8Array(_canvasSize.x * _canvasSize.y);
  /* eslint-disable new-cap */


  var _grayImageArray = Ndarray(_grayData, [_videoSize.y, _videoSize.x]).transpose(1, 0);

  var _canvasImageArray = Ndarray(_canvasData, [_canvasSize.y, _canvasSize.x]).transpose(1, 0);

  var _targetImageArray = _canvasImageArray.hi(_topRight.x + _size.x, _topRight.y + _size.y).lo(_topRight.x, _topRight.y);

  var _stepSizeX = _videoSize.x / _canvasSize.x;

  var _stepSizeY = _videoSize.y / _canvasSize.y;

  if (true) {
    console.log('FrameGrabber', JSON.stringify({
      videoSize: _grayImageArray.shape,
      canvasSize: _canvasImageArray.shape,
      stepSize: [_stepSizeX, _stepSizeY],
      size: _targetImageArray.shape,
      topRight: _topRight
    }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var frame = inputStream.getFrame();

    if (frame) {
      this.scaleAndCrop(frame);
      return true;
    }

    return false;
  }; // eslint-disable-next-line


  _that.scaleAndCrop = function (frame) {
    // 1. compute full-sized gray image
    CVUtils.computeGray(frame.data, _grayData); // 2. interpolate

    for (var y = 0; y < _canvasSize.y; y++) {
      for (var x = 0; x < _canvasSize.x; x++) {
        // eslint-disable-next-line no-bitwise
        _canvasImageArray.set(x, y, Interp2D(_grayImageArray, x * _stepSizeX, y * _stepSizeY) | 0);
      }
    } // targetImageArray must be equal to targetSize


    if (_targetImageArray.shape[0] !== _size.x || _targetImageArray.shape[1] !== _size.y) {
      throw new Error('Shapes do not match!');
    } // 3. crop


    for (var _y = 0; _y < _size.y; _y++) {
      for (var _x = 0; _x < _size.x; _x++) {
        _data[_y * _size.x + _x] = _targetImageArray.get(_x, _y);
      }
    }
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

module.exports = FrameGrabber;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  EPSILON: __webpack_require__(45),
  create: __webpack_require__(46),
  clone: __webpack_require__(107),
  angle: __webpack_require__(108),
  fromValues: __webpack_require__(47),
  copy: __webpack_require__(109),
  set: __webpack_require__(110),
  equals: __webpack_require__(111),
  exactEquals: __webpack_require__(112),
  add: __webpack_require__(113),
  subtract: __webpack_require__(50),
  sub: __webpack_require__(114),
  multiply: __webpack_require__(51),
  mul: __webpack_require__(115),
  divide: __webpack_require__(52),
  div: __webpack_require__(116),
  min: __webpack_require__(117),
  max: __webpack_require__(118),
  floor: __webpack_require__(119),
  ceil: __webpack_require__(120),
  round: __webpack_require__(121),
  scale: __webpack_require__(122),
  scaleAndAdd: __webpack_require__(123),
  distance: __webpack_require__(53),
  dist: __webpack_require__(124),
  squaredDistance: __webpack_require__(54),
  sqrDist: __webpack_require__(125),
  length: __webpack_require__(55),
  len: __webpack_require__(126),
  squaredLength: __webpack_require__(56),
  sqrLen: __webpack_require__(127),
  negate: __webpack_require__(128),
  inverse: __webpack_require__(129),
  normalize: __webpack_require__(48),
  dot: __webpack_require__(49),
  cross: __webpack_require__(130),
  lerp: __webpack_require__(131),
  random: __webpack_require__(132),
  transformMat4: __webpack_require__(133),
  transformMat3: __webpack_require__(134),
  transformQuat: __webpack_require__(135),
  rotateX: __webpack_require__(136),
  rotateY: __webpack_require__(137),
  rotateZ: __webpack_require__(138),
  forEach: __webpack_require__(139)
};

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _tracer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

/**
 * http://www.codeproject.com/Tips/407172/Connected-Component-Labeling-and-Vectorization
 */

var Rasterizer = {
  createContour2D: function createContour2D() {
    return {
      dir: null,
      index: null,
      firstVertex: null,
      insideContours: null,
      nextpeer: null,
      prevpeer: null
    };
  },
  CONTOUR_DIR: {
    CW_DIR: 0,
    CCW_DIR: 1,
    UNKNOWN_DIR: 2
  },
  DIR: {
    OUTSIDE_EDGE: -32767,
    INSIDE_EDGE: -32766
  },
  create: function create(imageWrapper, labelWrapper) {
    var imageData = imageWrapper.data;
    var labelData = labelWrapper.data;
    var width = imageWrapper.size.x;
    var height = imageWrapper.size.y;
    var tracer = _tracer__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].create(imageWrapper, labelWrapper);
    return {
      rasterize: function rasterize(depthlabel) {
        var color;
        var bc;
        var lc;
        var labelindex;
        var cx;
        var cy;
        var colorMap = [];
        var vertex;
        var p;
        var cc;
        var sc;
        var pos;
        var connectedCount = 0;
        var i;

        for (i = 0; i < 400; i++) {
          colorMap[i] = 0;
        }

        colorMap[0] = imageData[0];
        cc = null;

        for (cy = 1; cy < height - 1; cy++) {
          labelindex = 0;
          bc = colorMap[0];

          for (cx = 1; cx < width - 1; cx++) {
            pos = cy * width + cx;

            if (labelData[pos] === 0) {
              color = imageData[pos];

              if (color !== bc) {
                if (labelindex === 0) {
                  lc = connectedCount + 1;
                  colorMap[lc] = color;
                  bc = color;
                  vertex = tracer.contourTracing(cy, cx, lc, color, Rasterizer.DIR.OUTSIDE_EDGE);

                  if (vertex !== null) {
                    connectedCount++;
                    labelindex = lc;
                    p = Rasterizer.createContour2D();
                    p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    p.index = labelindex;
                    p.firstVertex = vertex;
                    p.nextpeer = cc;
                    p.insideContours = null;

                    if (cc !== null) {
                      cc.prevpeer = p;
                    }

                    cc = p;
                  }
                } else {
                  vertex = tracer.contourTracing(cy, cx, Rasterizer.DIR.INSIDE_EDGE, color, labelindex);

                  if (vertex !== null) {
                    p = Rasterizer.createContour2D();
                    p.firstVertex = vertex;
                    p.insideContours = null;

                    if (depthlabel === 0) {
                      p.dir = Rasterizer.CONTOUR_DIR.CCW_DIR;
                    } else {
                      p.dir = Rasterizer.CONTOUR_DIR.CW_DIR;
                    }

                    p.index = depthlabel;
                    sc = cc;

                    while (sc !== null && sc.index !== labelindex) {
                      sc = sc.nextpeer;
                    }

                    if (sc !== null) {
                      p.nextpeer = sc.insideContours;

                      if (sc.insideContours !== null) {
                        sc.insideContours.prevpeer = p;
                      }

                      sc.insideContours = p;
                    }
                  }
                }
              } else {
                labelData[pos] = labelindex;
              }
            } else if (labelData[pos] === Rasterizer.DIR.OUTSIDE_EDGE || labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
              labelindex = 0;

              if (labelData[pos] === Rasterizer.DIR.INSIDE_EDGE) {
                bc = imageData[pos];
              } else {
                bc = colorMap[0];
              }
            } else {
              labelindex = labelData[pos];
              bc = colorMap[labelindex];
            }
          }
        }

        sc = cc;

        while (sc !== null) {
          sc.index = depthlabel;
          sc = sc.nextpeer;
        }

        return {
          cc: cc,
          count: connectedCount
        };
      },
      debug: {
        drawContour: function drawContour(canvas, firstContour) {
          var ctx = canvas.getContext('2d');
          var pq = firstContour;
          var iq;
          var q;
          var p;
          ctx.strokeStyle = 'red';
          ctx.fillStyle = 'red';
          ctx.lineWidth = 1;

          if (pq !== null) {
            iq = pq.insideContours;
          } else {
            iq = null;
          }

          while (pq !== null) {
            if (iq !== null) {
              q = iq;
              iq = iq.nextpeer;
            } else {
              q = pq;
              pq = pq.nextpeer;

              if (pq !== null) {
                iq = pq.insideContours;
              } else {
                iq = null;
              }
            }

            switch (q.dir) {
              case Rasterizer.CONTOUR_DIR.CW_DIR:
                ctx.strokeStyle = 'red';
                break;

              case Rasterizer.CONTOUR_DIR.CCW_DIR:
                ctx.strokeStyle = 'blue';
                break;

              case Rasterizer.CONTOUR_DIR.UNKNOWN_DIR:
                ctx.strokeStyle = 'green';
                break;
            }

            p = q.firstVertex;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);

            do {
              p = p.next;
              ctx.lineTo(p.x, p.y);
            } while (p !== q.firstVertex);

            ctx.stroke();
          }
        }
      }
    };
  }
};
/* harmony default export */ __webpack_exports__["a"] = (Rasterizer);

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* eslint-disable no-param-reassign */

/* eslint-disable no-bitwise */

/* eslint-disable eqeqeq */

/* @preserve ASM BEGIN */
function Skeletonizer(stdlib, foreign, buffer) {
  'use asm';

  var images = new stdlib.Uint8Array(buffer);
  var size = foreign.size | 0;
  var imul = stdlib.Math.imul;

  function erode(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) == (5 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function subtract(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = (images[aImagePtr + length | 0] | 0) - (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function bitwiseOr(aImagePtr, bImagePtr, outImagePtr) {
    aImagePtr |= 0;
    bImagePtr |= 0;
    outImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[outImagePtr + length | 0] = images[aImagePtr + length | 0] | 0 | (images[bImagePtr + length | 0] | 0) | 0;
    }
  }

  function countNonZero(imagePtr) {
    imagePtr |= 0;
    var sum = 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      sum = (sum | 0) + (images[imagePtr + length | 0] | 0) | 0;
    }

    return sum | 0;
  }

  function init(imagePtr, value) {
    imagePtr |= 0;
    value |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[imagePtr + length | 0] = value;
    }
  }

  function dilate(inImagePtr, outImagePtr) {
    inImagePtr |= 0;
    outImagePtr |= 0;
    var v = 0;
    var u = 0;
    var sum = 0;
    var yStart1 = 0;
    var yStart2 = 0;
    var xStart1 = 0;
    var xStart2 = 0;
    var offset = 0;

    for (v = 1; (v | 0) < (size - 1 | 0); v = v + 1 | 0) {
      offset = offset + size | 0;

      for (u = 1; (u | 0) < (size - 1 | 0); u = u + 1 | 0) {
        yStart1 = offset - size | 0;
        yStart2 = offset + size | 0;
        xStart1 = u - 1 | 0;
        xStart2 = u + 1 | 0;
        sum = (images[inImagePtr + yStart1 + xStart1 | 0] | 0) + (images[inImagePtr + yStart1 + xStart2 | 0] | 0) + (images[inImagePtr + offset + u | 0] | 0) + (images[inImagePtr + yStart2 + xStart1 | 0] | 0) + (images[inImagePtr + yStart2 + xStart2 | 0] | 0) | 0;

        if ((sum | 0) > (0 | 0)) {
          images[outImagePtr + offset + u | 0] = 1;
        } else {
          images[outImagePtr + offset + u | 0] = 0;
        }
      }
    }
  }

  function memcpy(srcImagePtr, dstImagePtr) {
    srcImagePtr |= 0;
    dstImagePtr |= 0;
    var length = 0;
    length = imul(size, size) | 0;

    while ((length | 0) > 0) {
      length = length - 1 | 0;
      images[dstImagePtr + length | 0] = images[srcImagePtr + length | 0] | 0;
    }
  }

  function zeroBorder(imagePtr) {
    imagePtr |= 0;
    var x = 0;
    var y = 0;

    for (x = 0; (x | 0) < (size - 1 | 0); x = x + 1 | 0) {
      images[imagePtr + x | 0] = 0;
      images[imagePtr + y | 0] = 0;
      y = y + size - 1 | 0;
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }

    for (x = 0; (x | 0) < (size | 0); x = x + 1 | 0) {
      images[imagePtr + y | 0] = 0;
      y = y + 1 | 0;
    }
  }

  function skeletonize() {
    var subImagePtr = 0;
    var erodedImagePtr = 0;
    var tempImagePtr = 0;
    var skelImagePtr = 0;
    var sum = 0;
    var done = 0;
    erodedImagePtr = imul(size, size) | 0;
    tempImagePtr = erodedImagePtr + erodedImagePtr | 0;
    skelImagePtr = tempImagePtr + erodedImagePtr | 0; // init skel-image

    init(skelImagePtr, 0);
    zeroBorder(subImagePtr);

    do {
      erode(subImagePtr, erodedImagePtr);
      dilate(erodedImagePtr, tempImagePtr);
      subtract(subImagePtr, tempImagePtr, tempImagePtr);
      bitwiseOr(skelImagePtr, tempImagePtr, skelImagePtr);
      memcpy(erodedImagePtr, subImagePtr);
      sum = countNonZero(subImagePtr) | 0;
      done = (sum | 0) == 0 | 0;
    } while (!done);
  }

  return {
    skeletonize: skeletonize
  };
}
/* @preserve ASM END */


/* harmony default export */ __webpack_exports__["a"] = (Skeletonizer);
/* eslint-enable eqeqeq */

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, Buffer) {

var path = __webpack_require__(162);

var ndarray = __webpack_require__(29);

var GifReader = __webpack_require__(165).GifReader;

var pack = __webpack_require__(166);

var through = __webpack_require__(172);

var parseDataURI = __webpack_require__(187);

function defaultImage(url, cb) {
  var img = new Image();
  img.crossOrigin = "Anonymous";

  img.onload = function () {
    var canvas = document.createElement('canvas');
    canvas.width = img.width;
    canvas.height = img.height;
    var context = canvas.getContext('2d');
    context.drawImage(img, 0, 0);
    var pixels = context.getImageData(0, 0, img.width, img.height);
    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4 * img.width, 1], 0));
  };

  img.onerror = function (err) {
    cb(err);
  };

  img.src = url;
} //Animated gif loading


function handleGif(data, cb) {
  var reader;

  try {
    reader = new GifReader(data);
  } catch (err) {
    cb(err);
    return;
  }

  if (reader.numFrames() > 0) {
    var nshape = [reader.numFrames(), reader.height, reader.width, 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3]);
    var result = ndarray(ndata, nshape);

    try {
      for (var i = 0; i < reader.numFrames(); ++i) {
        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(result.index(i, 0, 0, 0), result.index(i + 1, 0, 0, 0)));
      }
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, result.transpose(0, 2, 1));
  } else {
    var nshape = [reader.height, reader.width, 4];
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2]);
    var result = ndarray(ndata, nshape);

    try {
      reader.decodeAndBlitFrameRGBA(0, ndata);
    } catch (err) {
      cb(err);
      return;
    }

    cb(null, result.transpose(1, 0));
  }
}

function httpGif(url, cb) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url, true);
  xhr.responseType = 'arraybuffer';

  if (xhr.overrideMimeType) {
    xhr.overrideMimeType('application/binary');
  }

  xhr.onerror = function (err) {
    cb(err);
  };

  xhr.onload = function () {
    if (xhr.readyState !== 4) {
      return;
    }

    var data = new Uint8Array(xhr.response);
    handleGif(data, cb);
    return;
  };

  xhr.send();
}

function copyBuffer(buffer) {
  if (buffer[0] === undefined) {
    var n = buffer.length;
    var result = new Uint8Array(n);

    for (var i = 0; i < n; ++i) {
      result[i] = buffer.get(i);
    }

    return result;
  } else {
    return new Uint8Array(buffer);
  }
}

function dataGif(url, cb) {
  process.nextTick(function () {
    try {
      var buffer = parseDataURI(url);

      if (buffer) {
        handleGif(copyBuffer(buffer), cb);
      } else {
        cb(new Error('Error parsing data URI'));
      }
    } catch (err) {
      cb(err);
    }
  });
}

module.exports = function getPixels(url, type, cb) {
  if (!cb) {
    cb = type;
    type = '';
  }

  var ext = path.extname(url);

  switch (type || ext.toUpperCase()) {
    case '.GIF':
      httpGif(url, cb);
      break;

    default:
      if (Buffer.isBuffer(url)) {
        url = 'data:' + type + ';base64,' + url.toString('base64');
      }

      if (url.indexOf('data:image/gif;') === 0) {
        dataGif(url, cb);
      } else {
        defaultImage(url, cb);
      }

  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14), __webpack_require__(21).Buffer))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(189);


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/*
 * typedefs.js
 * Normalizes browser-specific prefixes and provide some basic polyfills
 */
if (typeof window !== 'undefined') {
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function () {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (
      /* function FrameRequestCallback */
      callback) {
        window.setTimeout(callback, 1000 / 60);
      };
    }();
  }
}

if (typeof Math.imul !== 'function') {
  /* eslint-disable no-bitwise */
  Math.imul = function (a, b) {
    var ah = a >>> 16 & 0xffff;
    var al = a & 0xffff;
    var bh = b >>> 16 & 0xffff;
    var bl = b & 0xffff; // the shift by 0 fixes the sign on the high part
    // the final |0 converts the unsigned value into a signed value

    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
  };
  /* eslint-enable no-bitwise */

}

if (typeof Object.assign !== 'function') {
  Object.assign = function (target) {
    // .length of function is 2
    'use strict';

    if (target === null) {
      // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      // eslint-disable-next-line prefer-rest-params
      var nextSource = arguments[index];

      if (nextSource !== null) {
        // Skip over if undefined or null
        // eslint-disable-next-line no-restricted-syntax
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }

    return to;
  };
}

/***/ }),
/* 69 */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 71 */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new Float32Array(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 73 */
/***/ (function(module, exports) {

module.exports = fromValues;
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new Float32Array(2);
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 74 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(36);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var b0 = b[0];
  var b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/***/ }),
/* 77 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/***/ }),
/* 78 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(38);

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(39);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(40);

/***/ }),
/* 82 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/***/ }),
/* 85 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a vec2 by an angle
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to rotate
 * @param {Number} angle the angle of rotation (in radians)
 * @returns {vec2} out
 */

function rotate(out, a, angle) {
  var c = Math.cos(angle),
      s = Math.sin(angle);
  var x = a[0],
      y = a[1];
  out[0] = x * c - y * s;
  out[1] = x * s + y * c;
  return out;
}

/***/ }),
/* 86 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/***/ }),
/* 87 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/***/ }),
/* 88 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/***/ }),
/* 90 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(41);

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(42);

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(43);

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(44);

/***/ }),
/* 95 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = normalize;
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }

  return out;
}

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = dot;
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/***/ }),
/* 98 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/***/ }),
/* 99 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = transformMat2;
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = transformMat2d;
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/***/ }),
/* 104 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(37)();
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 2;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
  }

  return a;
}

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = limit;
/**
 * Limit the magnitude of this vector to the value used for the `max`
 * parameter.
 *
 * @param  {vec2} the vector to limit
 * @param  {Number} max the maximum magnitude for the vector
 * @returns {vec2} out
 */

function limit(out, a, max) {
  var mSq = a[0] * a[0] + a[1] * a[1];

  if (mSq > max * max) {
    var n = Math.sqrt(mSq);
    out[0] = a[0] / n * max;
    out[1] = a[1] / n * max;
  } else {
    out[0] = a[0];
    out[1] = a[1];
  }

  return out;
}

/***/ }),
/* 107 */
/***/ (function(module, exports) {

module.exports = clone;
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new Float32Array(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = angle;

var fromValues = __webpack_require__(47);

var normalize = __webpack_require__(48);

var dot = __webpack_require__(49);
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else {
    return Math.acos(cosine);
  }
}

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = set;
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = equals;

var EPSILON = __webpack_require__(45);
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var b0 = b[0];
  var b1 = b[1];
  var b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = exactEquals;
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/***/ }),
/* 113 */
/***/ (function(module, exports) {

module.exports = add;
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(50);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(51);

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(52);

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = min;
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = max;
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = floor;
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = ceil;
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = round;
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = scaleAndAdd;
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(53);

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(54);

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(55);

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(56);

/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = negate;
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = inverse;
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = cross;
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = lerp;
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = random;
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = Math.random() * 2.0 * Math.PI;
  var z = Math.random() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = transformMat4;
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = transformMat3;
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = transformQuat;
/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations
  var x = a[0],
      y = a[1],
      z = a[2],
      qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      // calculate quat * vec
  ix = qw * x + qy * z - qz * y,
      iy = qw * y + qz * x - qx * z,
      iz = qw * z + qx * y - qy * x,
      iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return out;
}

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = rotateX;
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var by = b[1];
  var bz = b[2]; // Translate point to the origin

  var py = a[1] - by;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = a[0];
  out[1] = by + py * cc - pz * sc;
  out[2] = bz + py * sc + pz * cc;
  return out;
}

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = rotateY;
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var bx = b[0];
  var bz = b[2]; // translate point to the origin

  var px = a[0] - bx;
  var pz = a[2] - bz;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + pz * sc + px * cc;
  out[1] = a[1];
  out[2] = bz + pz * cc - px * sc;
  return out;
}

/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = rotateZ;
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var bx = b[0];
  var by = b[1]; //Translate point to the origin

  var px = a[0] - bx;
  var py = a[1] - by;
  var sc = Math.sin(c);
  var cc = Math.cos(c); // perform rotation and translate to correct position

  out[0] = bx + px * cc - py * sc;
  out[1] = by + px * sc + py * cc;
  out[2] = a[2];
  return out;
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = forEach;

var vec = __webpack_require__(46)();
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */


function forEach(a, stride, offset, count, fn, arg) {
  var i, l;

  if (!stride) {
    stride = 3;
  }

  if (!offset) {
    offset = 0;
  }

  if (count) {
    l = Math.min(count * stride + offset, a.length);
  } else {
    l = a.length;
  }

  for (i = offset; i < l; i += stride) {
    vec[0] = a[i];
    vec[1] = a[i + 1];
    vec[2] = a[i + 2];
    fn(vec, vec, arg);
    a[i] = vec[0];
    a[i + 1] = vec[1];
    a[i + 2] = vec[2];
  }

  return a;
}

/***/ }),
/* 140 */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(35);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 143 */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 144 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

var getPrototypeOf = __webpack_require__(2);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function () {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function (record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : undefined);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),
/* 147 */
/***/ (function(module, exports) {

module.exports = determinant;
/**
 * Calculates the determinant of a mat2
 *
 * @alias mat2.determinant
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/***/ }),
/* 148 */
/***/ (function(module, exports) {

module.exports = transpose;
/**
 * Transpose the values of a mat2
 *
 * @alias mat2.transpose
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/***/ }),
/* 149 */
/***/ (function(module, exports) {

module.exports = multiply;
/**
 * Multiplies two mat2's
 *
 * @alias mat2.multiply
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/***/ }),
/* 150 */
/***/ (function(module, exports) {

module.exports = identity;
/**
 * Set a mat2 to the identity matrix
 *
 * @alias mat2.identity
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 151 */
/***/ (function(module, exports) {

module.exports = adjoint;
/**
 * Calculates the adjugate of a mat2
 *
 * @alias mat2.adjoint
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}

/***/ }),
/* 152 */
/***/ (function(module, exports) {

module.exports = rotate;
/**
 * Rotates a mat2 by the given angle
 *
 * @alias mat2.rotate
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/***/ }),
/* 153 */
/***/ (function(module, exports) {

module.exports = invert;
/**
 * Inverts a mat2
 *
 * @alias mat2.invert
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0];
  var a1 = a[1];
  var a2 = a[2];
  var a3 = a[3];
  var det = a0 * a3 - a2 * a1;
  if (!det) return null;
  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}

/***/ }),
/* 154 */
/***/ (function(module, exports) {

module.exports = create;
/**
 * Creates a new identity mat2
 *
 * @alias mat2.create
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new Float32Array(4);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/***/ }),
/* 155 */
/***/ (function(module, exports) {

module.exports = scale;
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @alias mat2.scale
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/***/ }),
/* 156 */
/***/ (function(module, exports) {

module.exports = copy;
/**
 * Copy the values from one mat2 to another
 *
 * @alias mat2.copy
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/***/ }),
/* 157 */
/***/ (function(module, exports) {

module.exports = frob;
/**
 * Returns Frobenius norm of a mat2
 *
 * @alias mat2.frob
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/***/ }),
/* 158 */
/***/ (function(module, exports) {

module.exports = ldu;
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 *
 * @alias mat2.ldu
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function ldu(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),
/* 160 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 161 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47
  /*/*/
  ;
  var end = -1;
  var matchedSlash = true;

  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';

  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }

  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';
  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
} // Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here


exports.basename = function (path, ext) {
  var f = basename(path);

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find

  var preDotState = 0;

  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);

    if (code === 47
    /*/*/
    ) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }

        continue;
      }

    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }

    if (code === 46
    /*.*/
    ) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }

  return path.slice(startDot, end);
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function iota(n) {
  var result = new Array(n);

  for (var i = 0; i < n; ++i) {
    result[i] = i;
  }

  return result;
}

module.exports = iota;

/***/ }),
/* 164 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
} // For Node v0.10 support. Remove this eventually.


function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.


function GifWriter(buf, width, height, gopts) {
  var p = 0;
  var gopts = gopts === undefined ? {} : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;
  if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;

    if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
      throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
    }

    return num_colors;
  } // - Header.


  buf[p++] = 0x47;
  buf[p++] = 0x49;
  buf[p++] = 0x46; // GIF

  buf[p++] = 0x38;
  buf[p++] = 0x39;
  buf[p++] = 0x61; // 89a
  // Handling of Global Color Table (palette) and background index.

  var gp_num_colors_pow2 = 0;
  var background = 0;

  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);

    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;

    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;

    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors) throw new Error("Background index out of range."); // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).

      if (background === 0) throw new Error("Background index explicitly passed as 0.");
    }
  } // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.


  buf[p++] = width & 0xff;
  buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff;
  buf[p++] = height >> 8 & 0xff; // NOTE: Indicates 0-bpp original color resolution (unused?).

  buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.
  gp_num_colors_pow2; // NOTE: No sort flag (unused?).

  buf[p++] = background; // Background Color Index.

  buf[p++] = 0; // Pixel aspect ratio (unused?).
  // - Global Color Table

  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {
    // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid."); // Extension code, label, and length.

    buf[p++] = 0x21;
    buf[p++] = 0xff;
    buf[p++] = 0x0b; // NETSCAPE2.0

    buf[p++] = 0x4e;
    buf[p++] = 0x45;
    buf[p++] = 0x54;
    buf[p++] = 0x53;
    buf[p++] = 0x43;
    buf[p++] = 0x41;
    buf[p++] = 0x50;
    buf[p++] = 0x45;
    buf[p++] = 0x32;
    buf[p++] = 0x2e;
    buf[p++] = 0x30; // Sub-block

    buf[p++] = 0x03;
    buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff;
    buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00; // Terminator.
  }

  var ended = false;

  this.addFrame = function (x, y, w, h, indexed_pixels, opts) {
    if (ended === true) {
      --p;
      ended = false;
    } // Un-end.


    opts = opts === undefined ? {} : opts; // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?

    if (x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
    if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
    if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
    var using_local_palette = true;
    var palette = opts.palette;

    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null) throw new Error("Must supply either a local or global palette.");
    var num_colors = check_palette_and_num_colors(palette); // Compute the min_code_size (power of 2), destroying num_colors.

    var min_code_size = 0;

    while (num_colors >>= 1) ++min_code_size;

    num_colors = 1 << min_code_size; // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay; // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.

    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3) // 4-7 is reserved.
      throw new Error("Disposal out of range.");
    var use_transparency = false;
    var transparent_index = 0;

    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors) throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21;
      buf[p++] = 0xf9; // Extension / Label.

      buf[p++] = 4; // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff;
      buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index; // Transparent color index.

      buf[p++] = 0; // Block Terminator.
    } // - Image Descriptor


    buf[p++] = 0x2c; // Image Seperator.

    buf[p++] = x & 0xff;
    buf[p++] = x >> 8 & 0xff; // Left.

    buf[p++] = y & 0xff;
    buf[p++] = y >> 8 & 0xff; // Top.

    buf[p++] = w & 0xff;
    buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff;
    buf[p++] = h >> 8 & 0xff; // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.

    buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0; // - Local Color Table

    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
    return p;
  };

  this.end = function () {
    if (ended === false) {
      buf[p++] = 0x3b; // Trailer.

      ended = true;
    }

    return p;
  };

  this.getOutputBuffer = function () {
    return buf;
  };

  this.setOutputBuffer = function (v) {
    buf = v;
  };

  this.getOutputBufferPosition = function () {
    return p;
  };

  this.setOutputBufferPosition = function (v) {
    p = v;
  };
} // Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.


function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++; // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1; // Number of bits per code.

  var cur_shift = 0; // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).

  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8;
      cur_shift -= 8;

      if (p === cur_subblock + 256) {
        // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  } // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.
  // Output code for the current contents of the index buffer.


  var ib_code = index_stream[0] & code_mask; // Load first input index.

  var code_table = {}; // Key'd on our 20-bit "tuple".

  emit_code(clear_code); // Spec says first code should be a clear code.
  // First index already loaded, process the rest of the stream.

  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.

    var cur_code = code_table[cur_key]; // buffer + k.
    // Check if we have to create a new code table entry.

    if (cur_code === undefined) {
      // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;

      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8;
        cur_shift -= 8;

        if (p === cur_subblock + 256) {
          // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {
        // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = {};
      } else {
        // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= 1 << cur_code_size) ++cur_code_size;
        code_table[cur_key] = next_code++; // Insert into code table.
      }

      ib_code = k; // Index buffer to single input k.
    } else {
      ib_code = cur_code; // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code); // There will still be something in the index buffer.

  emit_code(eoi_code); // End Of Information.
  // Flush / finalize the sub-blocks stream to the buffer.

  emit_bytes_to_buffer(1); // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.

  if (cur_subblock + 1 === p) {
    // Started but unused.
    buf[cur_subblock] = 0;
  } else {
    // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }

  return p;
}

function GifReader(buf) {
  var p = 0; // - Header (GIF87a or GIF89a).

  if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 || buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  } // - Logical Screen Descriptor.


  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++]; // <Packed Fields>.

  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << num_global_colors_pow2 + 1;
  var background = buf[p++];
  buf[p++]; // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3; // Seek past palette.
  }

  var no_eof = true;
  var frames = [];
  var delay = 0;
  var transparent_index = null;
  var disposal = 0; // 0 - No disposal specified.

  var loop_count = null;
  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:
        // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:
            // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p] !== 0x0b || // 21 FF already read, check block size.
            // NETSCAPE2.0
            buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 && buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 && buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 && buf[p + 10] == 0x2e && buf[p + 11] == 0x30 && // Sub-block
            buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++; // Skip terminator.
            } else {
              // We don't know what it is, just try to get past it.
              p += 12;

              while (true) {
                // Seek through subblocks.
                var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break; // 0 size is terminator

                p += block_size;
              }
            }

            break;

          case 0xf9:
            // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p + 4] !== 0) throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++; // Skip terminator.

            break;

          case 0xfe:
            // Comment Extension.
            while (true) {
              // Seek through subblocks.
              var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break; // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));

              p += block_size;
            }

            break;

          default:
            throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
        }

        break;

      case 0x2c:
        // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << num_local_colors_pow2 + 1;
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;

        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p; // Override with local palette.

          palette_size = num_local_colors;
          p += num_local_colors * 3; // Seek past palette.
        }

        var data_offset = p;
        p++; // codesize

        while (true) {
          var block_size = buf[p++]; // Bad block size (ex: undefined from an out of bounds read).

          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break; // 0 size is terminator

          p += block_size;
        }

        frames.push({
          x: x,
          y: y,
          width: w,
          height: h,
          has_local_palette: has_local_palette,
          palette_offset: palette_offset,
          palette_size: palette_size,
          data_offset: data_offset,
          data_length: p - data_offset,
          transparent_index: transparent_index,
          interlaced: !!interlace_flag,
          delay: delay,
          disposal: disposal
        });
        break;

      case 0x3b:
        // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
        break;
    }
  }

  this.numFrames = function () {
    return frames.length;
  };

  this.loopCount = function () {
    return loop_count;
  };

  this.frameInfo = function (frame_num) {
    if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
    return frames[frame_num];
  };

  this.decodeAndBlitFrameBGRA = function (frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.

    var trans = frame.transparent_index;
    if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.

    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth; // Number of subrect pixels left in scanline.
    // Output indicies of the top left and bottom right corners of the subrect.

    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.

    if (frame.interlaced === true) {
      scanstride += width * 4 * 7; // Pass 1.
    }

    var interlaceskip = 8; // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {
        // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;

        if (op >= opend) {
          // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }

      --xleft;
    }
  }; // I will go to copy and paste hell one day...


  this.decodeAndBlitFrameRGBA = function (frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.

    GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset; // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.

    var trans = frame.transparent_index;
    if (trans === null) trans = 256; // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.

    var framewidth = frame.width;
    var framestride = width - framewidth;
    var xleft = framewidth; // Number of subrect pixels left in scanline.
    // Output indicies of the top left and bottom right corners of the subrect.

    var opbeg = (frame.y * width + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op = opbeg;
    var scanstride = framestride * 4; // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.

    if (frame.interlaced === true) {
      scanstride += width * 4 * 7; // Pass 1.
    }

    var interlaceskip = 8; // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {
        // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;

        if (op >= opend) {
          // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip - 1); // interlaceskip / 2 * 4 is interlaceskip << 1.

          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }

      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];
  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;
  var cur_code_size = min_code_size + 1; // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.

  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;
  var op = 0; // Output pointer.

  var subblock_size = code_stream[p++]; // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);

  var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.

  var prev_code = null; // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break; // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {
        // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++]; // Next subblock.
      } else {
        --subblock_size;
      }
    } // TODO(deanm): We should never really get here, we should have received
    // and EOI.


    if (cur_shift < cur_code_size) break;
    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size; // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.

    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.
      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1; // Don't update prev_code ?

      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    } // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.


    var chase_code = code < next_code ? code : prev_code; // Chase what we will output, either {CODE} or {CODE-1}.

    var chase_length = 0;
    var chase = chase_code;

    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;
    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);

    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    } // Already have the first byte from the chase, might as well write it fast.


    output[op++] = k;
    op += chase_length;
    var b = op; // Track pointer, writing backwards.

    if (chase_code !== code) // The case of emitting {CODE-1} + k.
      output[op++] = k;
    chase = chase_code;

    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff; // Write backwards.

      chase >>= 8; // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k; // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).

      if (next_code >= code_mask + 1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
} // CommonJS.


try {
  exports.GifWriter = GifWriter;
  exports.GifReader = GifReader;
} catch (e) {}

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ndarray = __webpack_require__(29);

var do_convert = __webpack_require__(167);

module.exports = function convert(arr, result) {
  var shape = [],
      c = arr,
      sz = 1;

  while (Array.isArray(c)) {
    shape.push(c.length);
    sz *= c.length;
    c = c[0];
  }

  if (shape.length === 0) {
    return ndarray();
  }

  if (!result) {
    result = ndarray(new Float64Array(sz), shape);
  }

  do_convert(result, arr);
  return result;
};

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(168)({
  "args": ["array", "scalar", "index"],
  "pre": {
    "body": "{}",
    "args": [],
    "thisVars": [],
    "localVars": []
  },
  "body": {
    "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
    "args": [{
      "name": "_inline_1_arg0_",
      "lvalue": true,
      "rvalue": false,
      "count": 1
    }, {
      "name": "_inline_1_arg1_",
      "lvalue": false,
      "rvalue": true,
      "count": 1
    }, {
      "name": "_inline_1_arg2_",
      "lvalue": false,
      "rvalue": true,
      "count": 4
    }],
    "thisVars": [],
    "localVars": ["_inline_1_i", "_inline_1_v"]
  },
  "post": {
    "body": "{}",
    "args": [],
    "thisVars": [],
    "localVars": []
  },
  "funcName": "convert",
  "blockSize": 64
});

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createThunk = __webpack_require__(169);

function Procedure() {
  this.argTypes = [];
  this.shimArgs = [];
  this.arrayArgs = [];
  this.arrayBlockIndices = [];
  this.scalarArgs = [];
  this.offsetArgs = [];
  this.offsetArgIndex = [];
  this.indexArgs = [];
  this.shapeArgs = [];
  this.funcName = "";
  this.pre = null;
  this.body = null;
  this.post = null;
  this.debug = false;
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure(); //Parse blocks

  proc.pre = user_args.pre;
  proc.body = user_args.body;
  proc.post = user_args.post; //Parse arguments

  var proc_args = user_args.args.slice(0);
  proc.argTypes = proc_args;

  for (var i = 0; i < proc_args.length; ++i) {
    var arg_type = proc_args[i];

    if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
      proc.argTypes[i] = "array";
      proc.arrayArgs.push(i);
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
      proc.shimArgs.push("array" + i);

      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array args");
      }

      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array args");
      }
    } else if (arg_type === "scalar") {
      proc.scalarArgs.push(i);
      proc.shimArgs.push("scalar" + i);
    } else if (arg_type === "index") {
      proc.indexArgs.push(i);

      if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index");
      }

      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index");
      }

      if (i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index");
      }
    } else if (arg_type === "shape") {
      proc.shapeArgs.push(i);

      if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape");
      }

      if (i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape");
      }

      if (i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape");
      }
    } else if (typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset";
      proc.offsetArgs.push({
        array: arg_type.array,
        offset: arg_type.offset
      });
      proc.offsetArgIndex.push(i);
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
  } //Make sure at least one array argument was specified


  if (proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified");
  } //Make sure arguments are correct


  if (proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block");
  }

  if (proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block");
  }

  if (proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block");
  } //Check debug flag


  proc.debug = !!user_args.printCode || !!user_args.debug; //Retrieve name

  proc.funcName = user_args.funcName || "cwise"; //Read in block size

  proc.blockSize = user_args.blockSize || 64;
  return createThunk(proc);
}

module.exports = compileCwise;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = __webpack_require__(170);

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"];
  var vars = [];
  var thunkName = proc.funcName + "_cwise_thunk"; //Build thunk

  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""));
  var typesig = [];
  var string_typesig = [];
  var proc_args = [["array", proc.arrayArgs[0], ".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
  Math.max(0, proc.arrayBlockIndices[0]), proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"].join("")];
  var shapeLengthConditions = [],
      shapeConditions = []; // Process array arguments

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i];
    vars.push(["t", j, "=array", j, ".dtype,", "r", j, "=array", j, ".order"].join(""));
    typesig.push("t" + j);
    typesig.push("r" + j);
    string_typesig.push("t" + j);
    string_typesig.push("r" + j + ".join()");
    proc_args.push("array" + j + ".data");
    proc_args.push("array" + j + ".stride");
    proc_args.push("array" + j + ".offset|0");

    if (i > 0) {
      // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
    }
  } // Check for shape equality


  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
    code.push("}");
  } // Process scalar arguments


  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i]);
  } // Check for cached function (and if not present, generate it)


  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""));
  vars.push("proc=CACHED[type]");
  code.push("var " + vars.join(","));
  code.push(["if(!proc){", "CACHED[type]=proc=compile([", typesig.join(","), "])}", "return proc(", proc_args.join(","), ")}"].join(""));

  if (proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
  } //Compile thunk


  var thunk = new Function("compile", code.join("\n"));
  return thunk(compile.bind(undefined, proc));
}

module.exports = createThunk;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uniq = __webpack_require__(171); // This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.


function innerFill(order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      has_index = proc.indexArgs.length > 0,
      code = [],
      vars = [],
      idx = 0,
      pidx = 0,
      i,
      j;

  for (i = 0; i < dimension; ++i) {
    // Iteration variables
    vars.push(["i", i, "=0"].join(""));
  } //Compute scan deltas


  for (j = 0; j < nargs; ++j) {
    for (i = 0; i < dimension; ++i) {
      pidx = idx;
      idx = order[i];

      if (i === 0) {
        // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d", j, "s", i, "=t", j, "p", idx].join(""));
      } else {
        // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d", j, "s", i, "=(t", j, "p", idx, "-s", pidx, "*t", j, "p", pidx, ")"].join(""));
      }
    }
  }

  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  } //Scan loop


  for (i = dimension - 1; i >= 0; --i) {
    // Start at largest stride and work your way inwards
    idx = order[i];
    code.push(["for(i", i, "=0;i", i, "<s", idx, ";++i", i, "){"].join(""));
  } //Push body of inner loop


  code.push(body); //Advance scan pointers

  for (i = 0; i < dimension; ++i) {
    pidx = idx;
    idx = order[i];

    for (j = 0; j < nargs; ++j) {
      code.push(["p", j, "+=d", j, "s", i].join(""));
    }

    if (has_index) {
      if (i > 0) {
        code.push(["index[", pidx, "]-=s", pidx].join(""));
      }

      code.push(["++index[", idx, "]"].join(""));
    }

    code.push("}");
  }

  return code.join("\n");
} // Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.


function outerFill(matched, order, proc, body) {
  var dimension = order.length,
      nargs = proc.arrayArgs.length,
      blockSize = proc.blockSize,
      has_index = proc.indexArgs.length > 0,
      code = [];

  for (var i = 0; i < nargs; ++i) {
    code.push(["var offset", i, "=p", i].join(""));
  } //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).


  for (var i = matched; i < dimension; ++i) {
    code.push(["for(var j" + i + "=SS[", order[i], "]|0;j", i, ">0;){"].join("")); // Iterate back to front

    code.push(["if(j", i, "<", blockSize, "){"].join("")); // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).

    code.push(["s", order[i], "=j", i].join(""));
    code.push(["j", i, "=0"].join(""));
    code.push(["}else{s", order[i], "=", blockSize].join(""));
    code.push(["j", i, "-=", blockSize, "}"].join(""));

    if (has_index) {
      code.push(["index[", order[i], "]=j", i].join(""));
    }
  }

  for (var i = 0; i < nargs; ++i) {
    var indexStr = ["offset" + i];

    for (var j = matched; j < dimension; ++j) {
      indexStr.push(["j", j, "*t", i, "p", order[j]].join(""));
    }

    code.push(["p", i, "=(", indexStr.join("+"), ")"].join(""));
  }

  code.push(innerFill(order, proc, body));

  for (var i = matched; i < dimension; ++i) {
    code.push("}");
  }

  return code.join("\n");
} //Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.


function countMatches(orders) {
  var matched = 0,
      dimension = orders[0].length;

  while (matched < dimension) {
    for (var j = 1; j < orders.length; ++j) {
      if (orders[j][matched] !== orders[0][matched]) {
        return matched;
      }
    }

    ++matched;
  }

  return matched;
} //Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.


function processBlock(block, proc, dtypes) {
  var code = block.body;
  var pre = [];
  var post = [];

  for (var i = 0; i < block.args.length; ++i) {
    var carg = block.args[i];

    if (carg.count <= 0) {
      continue;
    }

    var re = new RegExp(carg.name, "g");
    var ptrStr = "";
    var arrNum = proc.arrayArgs.indexOf(i);

    switch (proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i);
        var offArg = proc.offsetArgs[offArgIndex];
        arrNum = offArg.array;
        ptrStr = "+q" + offArgIndex;
      // Adds offset to the "pointer" in the array

      case "array":
        ptrStr = "p" + arrNum + ptrStr;
        var localStr = "l" + i;
        var arrStr = "a" + arrNum;

        if (proc.arrayBlockIndices[arrNum] === 0) {
          // Argument to body is just a single value from this array
          if (carg.count === 1) {
            // Argument/array used only once(?)
            if (dtypes[arrNum] === "generic") {
              if (carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)

                code = code.replace(re, localStr);
                post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""));
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
            }
          } else if (dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

            code = code.replace(re, localStr);

            if (carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr, ")"].join(""));
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")); // TODO: Could we optimize by checking for carg.rvalue?

            code = code.replace(re, localStr);

            if (carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""));
            }
          }
        } else {
          // Argument to body is a "block"
          var reStrArr = [carg.name],
              ptrStrArr = [ptrStr];

          for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]");
            ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j); // Matched index times stride
          }

          re = new RegExp(reStrArr.join(""), "g");
          ptrStr = ptrStrArr.join("+");

          if (dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!");
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""));
          }
        }

        break;

      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
        break;

      case "index":
        code = code.replace(re, "index");
        break;

      case "shape":
        code = code.replace(re, "shape");
        break;
    }
  }

  return [pre.join("\n"), code, post.join("\n")].join("\n").trim();
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length);
  var allEqual = true;

  for (var i = 0; i < dtypes.length; ++i) {
    var t = dtypes[i];
    var digits = t.match(/\d+/);

    if (!digits) {
      digits = "";
    } else {
      digits = digits[0];
    }

    if (t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits;
    } else {
      summary[i] = t.charAt(0) + digits;
    }

    if (i > 0) {
      allEqual = allEqual && summary[i] === summary[i - 1];
    }
  }

  if (allEqual) {
    return summary[0];
  }

  return summary.join("");
} //Generates a cwise operator


function generateCWiseOp(proc, typesig) {
  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
  var orders = new Array(proc.arrayArgs.length);
  var dtypes = new Array(proc.arrayArgs.length);

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2 * i];
    orders[i] = typesig[2 * i + 1];
  } //Determine where block and loop indices start and end


  var blockBegin = [],
      blockEnd = []; // These indices are exposed as blocks

  var loopBegin = [],
      loopEnd = []; // These indices are iterated over

  var loopOrders = []; // orders restricted to the loop indices

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i] < 0) {
      loopBegin.push(0);
      loopEnd.push(dimension);
      blockBegin.push(dimension);
      blockEnd.push(dimension + proc.arrayBlockIndices[i]);
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]); // Non-negative

      loopEnd.push(proc.arrayBlockIndices[i] + dimension);
      blockBegin.push(0);
      blockEnd.push(proc.arrayBlockIndices[i]);
    }

    var newOrder = [];

    for (var j = 0; j < orders[i].length; j++) {
      if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
        newOrder.push(orders[i][j] - loopBegin[i]); // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }

    loopOrders.push(newOrder);
  } //First create arguments for procedure


  var arglist = ["SS"]; // SS is the overall shape over which we iterate

  var code = ["'use strict'"];
  var vars = [];

  for (var j = 0; j < dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")); // The limits for each dimension.
  }

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    arglist.push("a" + i); // Actual data array

    arglist.push("t" + i); // Strides

    arglist.push("p" + i); // Offset in the array at which the data starts (also used for iterating over the data)

    for (var j = 0; j < dimension; ++j) {
      // Unpack the strides into vars for looping
      vars.push(["t", i, "p", j, "=t", i, "[", loopBegin[i] + j, "]"].join(""));
    }

    for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
      // Unpack the strides into vars for block iteration
      vars.push(["t", i, "b", j, "=t", i, "[", blockBegin[i] + j, "]"].join(""));
    }
  }

  for (var i = 0; i < proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i);
  }

  if (proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)"); // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }

  if (proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension);

    for (var i = 0; i < dimension; ++i) {
      zeros[i] = "0";
    }

    vars.push(["index=[", zeros.join(","), "]"].join(""));
  }

  for (var i = 0; i < proc.offsetArgs.length; ++i) {
    // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i];
    var init_string = [];

    for (var j = 0; j < off_arg.offset.length; ++j) {
      if (off_arg.offset[j] === 0) {
        continue;
      } else if (off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""));
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""));
      }
    }

    if (init_string.length === 0) {
      vars.push("q" + i + "=0");
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""));
    }
  } //Prepare this variables


  var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
  vars = vars.concat(thisVars);

  if (vars.length > 0) {
    code.push("var " + vars.join(","));
  }

  for (var i = 0; i < proc.arrayArgs.length; ++i) {
    code.push("p" + i + "|=0");
  } //Inline prelude


  if (proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes));
  } //Process body


  var body = processBlock(proc.body, proc, dtypes);
  var matched = countMatches(loopOrders);

  if (matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)); // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body));
  } //Inline epilog


  if (proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes));
  }

  if (proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
  }

  var loopName = [proc.funcName || "unnamed", "_cwise_loop_", orders[0].join("s"), "m", matched, typeSummary(dtypes)].join("");
  var f = new Function(["function ", loopName, "(", arglist.join(","), "){", code.join("\n"), "} return ", loopName].join(""));
  return f();
}

module.exports = generateCWiseOp;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function unique_pred(list, compare) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];

  for (var i = 1; i < len; ++i) {
    b = a;
    a = list[i];

    if (compare(a, b)) {
      if (i === ptr) {
        ptr++;
        continue;
      }

      list[ptr++] = a;
    }
  }

  list.length = ptr;
  return list;
}

function unique_eq(list) {
  var ptr = 1,
      len = list.length,
      a = list[0],
      b = list[0];

  for (var i = 1; i < len; ++i, b = a) {
    b = a;
    a = list[i];

    if (a !== b) {
      if (i === ptr) {
        ptr++;
        continue;
      }

      list[ptr++] = a;
    }
  }

  list.length = ptr;
  return list;
}

function unique(list, compare, sorted) {
  if (list.length === 0) {
    return list;
  }

  if (compare) {
    if (!sorted) {
      list.sort(compare);
    }

    return unique_pred(list, compare);
  }

  if (!sorted) {
    list.sort();
  }

  return unique_eq(list);
}

module.exports = unique;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(173); // through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)


exports = module.exports = through;
through.through = through; //create a readable writable stream.

function through(write, end, opts) {
  write = write || function (data) {
    this.queue(data);
  };

  end = end || function () {
    this.queue(null);
  };

  var ended = false,
      destroyed = false,
      buffer = [],
      _ended = false;
  var stream = new Stream();
  stream.readable = stream.writable = true;
  stream.paused = false; //  stream.autoPause   = !(opts && opts.autoPause   === false)

  stream.autoDestroy = !(opts && opts.autoDestroy === false);

  stream.write = function (data) {
    write.call(this, data);
    return !stream.paused;
  };

  function drain() {
    while (buffer.length && !stream.paused) {
      var data = buffer.shift();
      if (null === data) return stream.emit('end');else stream.emit('data', data);
    }
  }

  stream.queue = stream.push = function (data) {
    //    console.error(ended)
    if (_ended) return stream;
    if (data === null) _ended = true;
    buffer.push(data);
    drain();
    return stream;
  }; //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'


  stream.on('end', function () {
    stream.readable = false;
    if (!stream.writable && stream.autoDestroy) process.nextTick(function () {
      stream.destroy();
    });
  });

  function _end() {
    stream.writable = false;
    end.call(stream);
    if (!stream.readable && stream.autoDestroy) stream.destroy();
  }

  stream.end = function (data) {
    if (ended) return;
    ended = true;
    if (arguments.length) stream.write(data);

    _end(); // will emit or queue


    return stream;
  };

  stream.destroy = function () {
    if (destroyed) return;
    destroyed = true;
    ended = true;
    buffer.length = 0;
    stream.writable = stream.readable = false;
    stream.emit('close');
    return stream;
  };

  stream.pause = function () {
    if (stream.paused) return;
    stream.paused = true;
    return stream;
  };

  stream.resume = function () {
    if (stream.paused) {
      stream.paused = false;
      stream.emit('resume');
    }

    drain(); //may have become paused again,
    //as drain emits 'data'.

    if (!stream.paused) stream.emit('drain');
    return stream;
  };

  return stream;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(14)))

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__(30).EventEmitter;

var inherits = __webpack_require__(18);

inherits(Stream, EE);
Stream.Readable = __webpack_require__(31);
Stream.Writable = __webpack_require__(183);
Stream.Duplex = __webpack_require__(184);
Stream.Transform = __webpack_require__(185);
Stream.PassThrough = __webpack_require__(186); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),
/* 174 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 175 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__(32).Buffer;

var util = __webpack_require__(177);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),
/* 177 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(179); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function (handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function (event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function (handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function (handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function (handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function (handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13), __webpack_require__(14)))

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(13)))

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(21);

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(61);
/*<replacement>*/


var util = Object.create(__webpack_require__(22));
util.inherits = __webpack_require__(18);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(33);

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(15);

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31).Transform;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(31).PassThrough;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/**
 * Module exports.
 */
module.exports = dataUriToBuffer;
/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer(uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  } // strip newlines


  uri = uri.replace(/\r?\n/g, ''); // split the URI up into the "metadata" and the "data" portions

  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI'); // remove the "data:" scheme and parse the metadata

  var meta = uri.substring(5, firstComma).split(';');
  var base64 = false;
  var charset = 'US-ASCII';

  for (var i = 0; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else if (0 == meta[i].indexOf('charset=')) {
      charset = meta[i].substring(8);
    }
  } // get the encoded data portion and decode URI-encoded chars


  var data = unescape(uri.substring(firstComma + 1));
  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = new Buffer(data, encoding); // set `.type` property to MIME type

  buffer.type = meta[0] || 'text/plain'; // set the `.charset` property

  buffer.charset = charset;
  return buffer;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(21).Buffer))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function interp1d(arr, x) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      w0 = s0 ? +arr.get(ix) : 0.0,
      w1 = s1 ? +arr.get(ix + 1) : 0.0;
  return (1.0 - fx) * w0 + fx * w1;
}

function interp2d(arr, x, y) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      iy = Math.floor(y),
      fy = y - iy,
      t0 = 0 <= iy && iy < arr.shape[1],
      t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
      w00 = s0 && t0 ? arr.get(ix, iy) : 0.0,
      w01 = s0 && t1 ? arr.get(ix, iy + 1) : 0.0,
      w10 = s1 && t0 ? arr.get(ix + 1, iy) : 0.0,
      w11 = s1 && t1 ? arr.get(ix + 1, iy + 1) : 0.0;
  return (1.0 - fy) * ((1.0 - fx) * w00 + fx * w10) + fy * ((1.0 - fx) * w01 + fx * w11);
}

function interp3d(arr, x, y, z) {
  var ix = Math.floor(x),
      fx = x - ix,
      s0 = 0 <= ix && ix < arr.shape[0],
      s1 = 0 <= ix + 1 && ix + 1 < arr.shape[0],
      iy = Math.floor(y),
      fy = y - iy,
      t0 = 0 <= iy && iy < arr.shape[1],
      t1 = 0 <= iy + 1 && iy + 1 < arr.shape[1],
      iz = Math.floor(z),
      fz = z - iz,
      u0 = 0 <= iz && iz < arr.shape[2],
      u1 = 0 <= iz + 1 && iz + 1 < arr.shape[2],
      w000 = s0 && t0 && u0 ? arr.get(ix, iy, iz) : 0.0,
      w010 = s0 && t1 && u0 ? arr.get(ix, iy + 1, iz) : 0.0,
      w100 = s1 && t0 && u0 ? arr.get(ix + 1, iy, iz) : 0.0,
      w110 = s1 && t1 && u0 ? arr.get(ix + 1, iy + 1, iz) : 0.0,
      w001 = s0 && t0 && u1 ? arr.get(ix, iy, iz + 1) : 0.0,
      w011 = s0 && t1 && u1 ? arr.get(ix, iy + 1, iz + 1) : 0.0,
      w101 = s1 && t0 && u1 ? arr.get(ix + 1, iy, iz + 1) : 0.0,
      w111 = s1 && t1 && u1 ? arr.get(ix + 1, iy + 1, iz + 1) : 0.0;
  return (1.0 - fz) * ((1.0 - fy) * ((1.0 - fx) * w000 + fx * w100) + fy * ((1.0 - fx) * w010 + fx * w110)) + fz * ((1.0 - fy) * ((1.0 - fx) * w001 + fx * w101) + fy * ((1.0 - fx) * w011 + fx * w111));
}

function interpNd(arr) {
  var d = arr.shape.length | 0,
      ix = new Array(d),
      fx = new Array(d),
      s0 = new Array(d),
      s1 = new Array(d),
      i,
      t;

  for (i = 0; i < d; ++i) {
    t = +arguments[i + 1];
    ix[i] = Math.floor(t);
    fx[i] = t - ix[i];
    s0[i] = 0 <= ix[i] && ix[i] < arr.shape[i];
    s1[i] = 0 <= ix[i] + 1 && ix[i] + 1 < arr.shape[i];
  }

  var r = 0.0,
      j,
      w,
      idx;

  i_loop: for (i = 0; i < 1 << d; ++i) {
    w = 1.0;
    idx = arr.offset;

    for (j = 0; j < d; ++j) {
      if (i & 1 << j) {
        if (!s1[j]) {
          continue i_loop;
        }

        w *= fx[j];
        idx += arr.stride[j] * (ix[j] + 1);
      } else {
        if (!s0[j]) {
          continue i_loop;
        }

        w *= 1.0 - fx[j];
        idx += arr.stride[j] * ix[j];
      }
    }

    r += w * arr.data[idx];
  }

  return r;
}

function interpolate(arr, x, y, z) {
  switch (arr.shape.length) {
    case 0:
      return 0.0;

    case 1:
      return interp1d(arr, x);

    case 2:
      return interp2d(arr, x, y);

    case 3:
      return interp3d(arr, x, y, z);

    default:
      return interpNd.apply(undefined, arguments);
  }
}

module.exports = interpolate;
module.exports.d1 = interp1d;
module.exports.d2 = interp2d;
module.exports.d3 = interp3d;

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "BarcodeDecoder", function() { return /* reexport */ barcode_decoder; });
__webpack_require__.d(__webpack_exports__, "BarcodeReader", function() { return /* reexport */ barcode_reader; });
__webpack_require__.d(__webpack_exports__, "CameraAccess", function() { return /* reexport */ camera_access; });
__webpack_require__.d(__webpack_exports__, "ImageDebug", function() { return /* reexport */ image_debug["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ImageWrapper", function() { return /* reexport */ image_wrapper["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "ResultCollector", function() { return /* reexport */ result_collector; });

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js
var helpers_typeof = __webpack_require__(19);
var typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);

// EXTERNAL MODULE: ./src/common/typedefs.js
var typedefs = __webpack_require__(68);

// EXTERNAL MODULE: ./src/common/image_wrapper.ts
var image_wrapper = __webpack_require__(11);

// CONCATENATED MODULE: ./src/decoder/bresenham.js
var Bresenham = {};
var Slope = {
  DIR: {
    UP: 1,
    DOWN: -1
  }
};
/**
 * Scans a line of the given image from point p1 to p2 and returns a result object containing
 * gray-scale values (0-255) of the underlying pixels in addition to the min
 * and max values.
 * @param {Object} imageWrapper
 * @param {Object} p1 The start point {x,y}
 * @param {Object} p2 The end point {x,y}
 * @returns {line, min, max}
 */

Bresenham.getBarcodeLine = function (imageWrapper, p1, p2) {
  /* eslint-disable no-bitwise */
  var x0 = p1.x | 0;
  var y0 = p1.y | 0;
  var x1 = p2.x | 0;
  var y1 = p2.y | 0;
  /* eslint-disable no-bitwise */

  var steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);
  var error;
  var y;
  var tmp;
  var x;
  var line = [];
  var imageData = imageWrapper.data;
  var width = imageWrapper.size.x;
  var val;
  var min = 255;
  var max = 0;

  function read(a, b) {
    val = imageData[b * width + a];
    min = val < min ? val : min;
    max = val > max ? val : max;
    line.push(val);
  }

  if (steep) {
    tmp = x0;
    x0 = y0;
    y0 = tmp;
    tmp = x1;
    x1 = y1;
    y1 = tmp;
  }

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }

  var deltaX = x1 - x0;
  var deltaY = Math.abs(y1 - y0);
  error = deltaX / 2 | 0;
  y = y0;
  var yStep = y0 < y1 ? 1 : -1;

  for (x = x0; x < x1; x++) {
    if (steep) {
      read(y, x);
    } else {
      read(x, y);
    }

    error -= deltaY;

    if (error < 0) {
      y += yStep;
      error += deltaX;
    }
  }

  return {
    line: line,
    min: min,
    max: max
  };
};
/**
 * Converts the result from getBarcodeLine into a binary representation
 * also considering the frequency and slope of the signal for more robust results
 * @param {Object} result {line, min, max}
 */


Bresenham.toBinaryLine = function (result) {
  var min = result.min;
  var max = result.max;
  var line = result.line;
  var slope;
  var slope2;
  var center = min + (max - min) / 2;
  var extrema = [];
  var currentDir;
  var dir;
  var threshold = (max - min) / 12;
  var rThreshold = -threshold;
  var i;
  var j; // 1. find extrema

  currentDir = line[0] > center ? Slope.DIR.UP : Slope.DIR.DOWN;
  extrema.push({
    pos: 0,
    val: line[0]
  });

  for (i = 0; i < line.length - 2; i++) {
    slope = line[i + 1] - line[i];
    slope2 = line[i + 2] - line[i + 1];

    if (slope + slope2 < rThreshold && line[i + 1] < center * 1.5) {
      dir = Slope.DIR.DOWN;
    } else if (slope + slope2 > threshold && line[i + 1] > center * 0.5) {
      dir = Slope.DIR.UP;
    } else {
      dir = currentDir;
    }

    if (currentDir !== dir) {
      extrema.push({
        pos: i,
        val: line[i]
      });
      currentDir = dir;
    }
  }

  extrema.push({
    pos: line.length,
    val: line[line.length - 1]
  });

  for (j = extrema[0].pos; j < extrema[1].pos; j++) {
    line[j] = line[j] > center ? 0 : 1;
  } // iterate over extrema and convert to binary based on avg between minmax


  for (i = 1; i < extrema.length - 1; i++) {
    if (extrema[i + 1].val > extrema[i].val) {
      threshold = extrema[i].val + (extrema[i + 1].val - extrema[i].val) / 3 * 2 | 0;
    } else {
      threshold = extrema[i + 1].val + (extrema[i].val - extrema[i + 1].val) / 3 | 0;
    }

    for (j = extrema[i].pos; j < extrema[i + 1].pos; j++) {
      line[j] = line[j] > threshold ? 0 : 1;
    }
  }

  return {
    line: line,
    threshold: threshold
  };
};
/**
 * Used for development only
 */


Bresenham.debug = {
  printFrequency: function printFrequency(line, canvas) {
    var i;
    var ctx = canvas.getContext('2d'); // eslint-disable-next-line no-param-reassign

    canvas.width = line.length; // eslint-disable-next-line no-param-reassign

    canvas.height = 256;
    ctx.beginPath();
    ctx.strokeStyle = 'blue';

    for (i = 0; i < line.length; i++) {
      ctx.moveTo(i, 255);
      ctx.lineTo(i, 255 - line[i]);
    }

    ctx.stroke();
    ctx.closePath();
  },
  printPattern: function printPattern(line, canvas) {
    var ctx = canvas.getContext('2d');
    var i; // eslint-disable-next-line no-param-reassign

    canvas.width = line.length;
    ctx.fillColor = 'black';

    for (i = 0; i < line.length; i++) {
      if (line[i] === 1) {
        ctx.fillRect(i, 0, 1, 100);
      }
    }
  }
};
/* harmony default export */ var bresenham = (Bresenham);
// EXTERNAL MODULE: ./src/common/image_debug.ts
var image_debug = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(3);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(4);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/assertThisInitialized.js
var assertThisInitialized = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(6);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(5);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(2);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./src/common/array_helper.ts
var array_helper = __webpack_require__(10);

// CONCATENATED MODULE: ./src/reader/barcode_reader.ts




var BarcodeDirection;

(function (BarcodeDirection) {
  BarcodeDirection[BarcodeDirection["Forward"] = 1] = "Forward";
  BarcodeDirection[BarcodeDirection["Reverse"] = -1] = "Reverse";
})(BarcodeDirection || (BarcodeDirection = {}));

;
;
;
;
;
;
var barcode_reader_BarcodeReader = /*#__PURE__*/function () {
  createClass_default()(BarcodeReader, null, [{
    key: "Exception",
    get: function get() {
      return {
        StartNotFoundException: 'Start-Info was not found!',
        CodeNotFoundException: 'Code could not be found!',
        PatternNotFoundException: 'Pattern could not be found!'
      };
    }
  }]);

  function BarcodeReader(config, supplements) {
    classCallCheck_default()(this, BarcodeReader);

    defineProperty_default()(this, "_row", []);

    defineProperty_default()(this, "config", {});

    defineProperty_default()(this, "supplements", []);

    defineProperty_default()(this, "SINGLE_CODE_ERROR", 0);

    defineProperty_default()(this, "FORMAT", 'unknown');

    defineProperty_default()(this, "CONFIG_KEYS", {});

    this._row = [];
    this.config = config || {};

    if (supplements) {
      this.supplements = supplements;
    }

    return this;
  }

  createClass_default()(BarcodeReader, [{
    key: "_nextUnset",
    value: function _nextUnset(line) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = start; i < line.length; i++) {
        if (!line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_matchPattern",
    value: function _matchPattern(counter, code, maxSingleError) {
      var error = 0;
      var singleError = 0;
      var sum = 0;
      var modulo = 0;
      var barWidth = 0;
      var count = 0;
      var scaled = 0;
      maxSingleError = maxSingleError || this.SINGLE_CODE_ERROR || 1;

      for (var i = 0; i < counter.length; i++) {
        sum += counter[i];
        modulo += code[i];
      }

      if (sum < modulo) {
        return Number.MAX_VALUE;
      }

      barWidth = sum / modulo;
      maxSingleError *= barWidth;

      for (var _i = 0; _i < counter.length; _i++) {
        count = counter[_i];
        scaled = code[_i] * barWidth;
        singleError = Math.abs(count - scaled) / scaled;

        if (singleError > maxSingleError) {
          return Number.MAX_VALUE;
        }

        error += singleError;
      }

      return error / modulo;
    }
  }, {
    key: "_nextSet",
    value: function _nextSet(line) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = offset; i < line.length; i++) {
        if (line[i]) return i;
      }

      return line.length;
    }
  }, {
    key: "_correctBars",
    value: function _correctBars(counter, correction, indices) {
      var length = indices.length;
      var tmp = 0;

      while (length--) {
        tmp = counter[indices[length]] * (1 - (1 - correction) / 2);

        if (tmp > 1) {
          counter[indices[length]] = tmp;
        }
      }
    }
  }, {
    key: "decodePattern",
    value: function decodePattern(pattern) {
      // console.warn('* decodePattern', pattern);
      this._row = pattern; // console.warn('* decodePattern calling decode', typeof this, this.constructor, this.FORMAT, JSON.stringify(this));

      var result = this._decode(); // console.warn('* first result=', result);


      if (result === null) {
        this._row.reverse();

        result = this._decode(); // console.warn('* reversed result=', result);

        if (result) {
          result.direction = BarcodeDirection.Reverse;
          result.start = this._row.length - result.start;
          result.end = this._row.length - result.end;
        }
      } else {
        result.direction = BarcodeDirection.Forward;
      }

      if (result) {
        result.format = this.FORMAT;
      } // console.warn('* returning', result);


      return result;
    }
  }, {
    key: "_matchRange",
    value: function _matchRange(start, end, value) {
      var i;
      start = start < 0 ? 0 : start;

      for (i = start; i < end; i++) {
        if (this._row[i] !== value) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_fillCounters",
    value: function _fillCounters() {
      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._nextUnset(this._row);
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row.length;
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var counters = [];
      var counterPos = 0;
      counters[counterPos] = 0;

      for (var i = offset; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;
          counters[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return counters;
    }
  }, {
    key: "_toCounters",
    value: function _toCounters(start, counters) {
      var numCounters = counters.length;
      var end = this._row.length;
      var isWhite = !this._row[start];
      var counterPos = 0;
      array_helper["a" /* default */].init(counters, 0);

      for (var i = start; i < end; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counters[counterPos]++;
        } else {
          counterPos++;

          if (counterPos === numCounters) {
            break;
          } else {
            counters[counterPos] = 1;
            isWhite = !isWhite;
          }
        }
      }

      return counters;
    }
  }]);

  return BarcodeReader;
}();
/* harmony default export */ var barcode_reader = (barcode_reader_BarcodeReader);
// CONCATENATED MODULE: ./src/reader/code_128_reader.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_128_reader_Code128Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code128Reader, _BarcodeReader);

  var _super = _createSuper(Code128Reader);

  function Code128Reader() {
    var _this;

    classCallCheck_default()(this, Code128Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_SHIFT", 98);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_C", 99);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_B", 100);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_A", 101);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_A", 103);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_B", 104);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_CODE_C", 105);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_CODE", 106);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[2, 1, 2, 2, 2, 2], [2, 2, 2, 1, 2, 2], [2, 2, 2, 2, 2, 1], [1, 2, 1, 2, 2, 3], [1, 2, 1, 3, 2, 2], [1, 3, 1, 2, 2, 2], [1, 2, 2, 2, 1, 3], [1, 2, 2, 3, 1, 2], [1, 3, 2, 2, 1, 2], [2, 2, 1, 2, 1, 3], [2, 2, 1, 3, 1, 2], [2, 3, 1, 2, 1, 2], [1, 1, 2, 2, 3, 2], [1, 2, 2, 1, 3, 2], [1, 2, 2, 2, 3, 1], [1, 1, 3, 2, 2, 2], [1, 2, 3, 1, 2, 2], [1, 2, 3, 2, 2, 1], [2, 2, 3, 2, 1, 1], [2, 2, 1, 1, 3, 2], [2, 2, 1, 2, 3, 1], [2, 1, 3, 2, 1, 2], [2, 2, 3, 1, 1, 2], [3, 1, 2, 1, 3, 1], [3, 1, 1, 2, 2, 2], [3, 2, 1, 1, 2, 2], [3, 2, 1, 2, 2, 1], [3, 1, 2, 2, 1, 2], [3, 2, 2, 1, 1, 2], [3, 2, 2, 2, 1, 1], [2, 1, 2, 1, 2, 3], [2, 1, 2, 3, 2, 1], [2, 3, 2, 1, 2, 1], [1, 1, 1, 3, 2, 3], [1, 3, 1, 1, 2, 3], [1, 3, 1, 3, 2, 1], [1, 1, 2, 3, 1, 3], [1, 3, 2, 1, 1, 3], [1, 3, 2, 3, 1, 1], [2, 1, 1, 3, 1, 3], [2, 3, 1, 1, 1, 3], [2, 3, 1, 3, 1, 1], [1, 1, 2, 1, 3, 3], [1, 1, 2, 3, 3, 1], [1, 3, 2, 1, 3, 1], [1, 1, 3, 1, 2, 3], [1, 1, 3, 3, 2, 1], [1, 3, 3, 1, 2, 1], [3, 1, 3, 1, 2, 1], [2, 1, 1, 3, 3, 1], [2, 3, 1, 1, 3, 1], [2, 1, 3, 1, 1, 3], [2, 1, 3, 3, 1, 1], [2, 1, 3, 1, 3, 1], [3, 1, 1, 1, 2, 3], [3, 1, 1, 3, 2, 1], [3, 3, 1, 1, 2, 1], [3, 1, 2, 1, 1, 3], [3, 1, 2, 3, 1, 1], [3, 3, 2, 1, 1, 1], [3, 1, 4, 1, 1, 1], [2, 2, 1, 4, 1, 1], [4, 3, 1, 1, 1, 1], [1, 1, 1, 2, 2, 4], [1, 1, 1, 4, 2, 2], [1, 2, 1, 1, 2, 4], [1, 2, 1, 4, 2, 1], [1, 4, 1, 1, 2, 2], [1, 4, 1, 2, 2, 1], [1, 1, 2, 2, 1, 4], [1, 1, 2, 4, 1, 2], [1, 2, 2, 1, 1, 4], [1, 2, 2, 4, 1, 1], [1, 4, 2, 1, 1, 2], [1, 4, 2, 2, 1, 1], [2, 4, 1, 2, 1, 1], [2, 2, 1, 1, 1, 4], [4, 1, 3, 1, 1, 1], [2, 4, 1, 1, 1, 2], [1, 3, 4, 1, 1, 1], [1, 1, 1, 2, 4, 2], [1, 2, 1, 1, 4, 2], [1, 2, 1, 2, 4, 1], [1, 1, 4, 2, 1, 2], [1, 2, 4, 1, 1, 2], [1, 2, 4, 2, 1, 1], [4, 1, 1, 2, 1, 2], [4, 2, 1, 1, 1, 2], [4, 2, 1, 2, 1, 1], [2, 1, 2, 1, 4, 1], [2, 1, 4, 1, 2, 1], [4, 1, 2, 1, 2, 1], [1, 1, 1, 1, 4, 3], [1, 1, 1, 3, 4, 1], [1, 3, 1, 1, 4, 1], [1, 1, 4, 1, 1, 3], [1, 1, 4, 3, 1, 1], [4, 1, 1, 1, 1, 3], [4, 1, 1, 3, 1, 1], [1, 1, 3, 1, 4, 1], [1, 1, 4, 1, 3, 1], [3, 1, 1, 1, 4, 1], [4, 1, 1, 1, 3, 1], [2, 1, 1, 4, 1, 2], [2, 1, 1, 2, 1, 4], [2, 1, 1, 2, 3, 2], [2, 3, 3, 1, 1, 1, 2]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.64);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_128');

    defineProperty_default()(assertThisInitialized_default()(_this), "MODULE_INDICES", {
      bar: [0, 2, 4],
      space: [1, 3, 5]
    });

    return _this;
  }

  createClass_default()(Code128Reader, [{
    key: "_decodeCode",
    value: function _decodeCode(start, correction) {
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var counter = [0, 0, 0, 0, 0, 0];
      var offset = start;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            if (correction) {
              this._correct(counter, correction);
            }

            for (var code = 0; code < this.CODE_PATTERN.length; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            bestMatch.end = i;

            if (bestMatch.code === -1 || bestMatch.error > this.AVG_CODE_ERROR) {
              return null;
            }

            if (this.CODE_PATTERN[bestMatch.code]) {
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
            }

            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_correct",
    value: function _correct(counter, correction) {
      this._correctBars(counter, correction.bar, this.MODULE_INDICES.bar);

      this._correctBars(counter, correction.space, this.MODULE_INDICES.space);
    }
  }, {
    key: "_findStart",
    // TODO: _findStart and decodeCode share similar code, can we re-use some?
    value: function _findStart() {
      var counter = [0, 0, 0, 0, 0, 0];

      var offset = this._nextSet(this._row);

      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0,
        correction: {
          bar: 1,
          space: 1
        }
      };
      var isWhite = false;
      var counterPos = 0;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            for (var code = this.START_CODE_A; code <= this.START_CODE_C; code++) {
              var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error < this.AVG_CODE_ERROR) {
              bestMatch.start = i - sum;
              bestMatch.end = i;
              bestMatch.correction.bar = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.bar);
              bestMatch.correction.space = this.calculateCorrection(this.CODE_PATTERN[bestMatch.code], counter, this.MODULE_INDICES.space);
              return bestMatch;
            }

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var _this2 = this;

      var startInfo = this._findStart();

      if (startInfo === null) {
        return null;
      } // var self = this,
      //     done = false,
      //     result = [],
      //     multiplier = 0,
      //     checksum = 0,
      //     codeset,
      //     rawResult = [],
      //     decodedCodes = [],
      //     shiftNext = false,
      //     unshift,
      //     removeLastCharacter = true;


      var code = {
        code: startInfo.code,
        start: startInfo.start,
        end: startInfo.end,
        correction: {
          bar: startInfo.correction.bar,
          space: startInfo.correction.space
        }
      };
      var decodedCodes = [];
      decodedCodes.push(code);
      var checksum = code.code;

      var codeset = function (c) {
        switch (c) {
          case _this2.START_CODE_A:
            return _this2.CODE_A;

          case _this2.START_CODE_B:
            return _this2.CODE_B;

          case _this2.START_CODE_C:
            return _this2.CODE_C;

          default:
            return null;
        }
      }(code.code);

      var done = false;
      var shiftNext = false;
      var unshift = shiftNext;
      var removeLastCharacter = true;
      var multiplier = 0;
      var rawResult = [];
      var result = []; // TODO: i think this should be string only, but it creates problems if it is

      while (!done) {
        unshift = shiftNext;
        shiftNext = false;
        code = this._decodeCode(code.end, code.correction);

        if (code !== null) {
          if (code.code !== this.STOP_CODE) {
            removeLastCharacter = true;
          }

          if (code.code !== this.STOP_CODE) {
            rawResult.push(code.code);
            multiplier++;
            checksum += multiplier * code.code;
          }

          decodedCodes.push(code);

          switch (codeset) {
            case this.CODE_A:
              if (code.code < 64) {
                result.push(String.fromCharCode(32 + code.code));
              } else if (code.code < 96) {
                result.push(String.fromCharCode(code.code - 64));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_B:
              if (code.code < 96) {
                result.push(String.fromCharCode(32 + code.code));
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_SHIFT:
                    shiftNext = true;
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_C:
                    codeset = this.CODE_C;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;

            case this.CODE_C:
              if (code.code < 100) {
                result.push(code.code < 10 ? '0' + code.code : code.code);
              } else {
                if (code.code !== this.STOP_CODE) {
                  removeLastCharacter = false;
                }

                switch (code.code) {
                  case this.CODE_A:
                    codeset = this.CODE_A;
                    break;

                  case this.CODE_B:
                    codeset = this.CODE_B;
                    break;

                  case this.STOP_CODE:
                    done = true;
                    break;
                }
              }

              break;
          }
        } else {
          done = true;
        }

        if (unshift) {
          codeset = codeset === this.CODE_A ? this.CODE_B : this.CODE_A;
        }
      }

      if (code === null) {
        return null;
      }

      code.end = this._nextUnset(this._row, code.end);

      if (!this._verifyTrailingWhitespace(code)) {
        return null;
      }

      checksum -= multiplier * rawResult[rawResult.length - 1];

      if (checksum % 103 !== rawResult[rawResult.length - 1]) {
        return null;
      }

      if (!result.length) {
        return null;
      } // remove last code from result (checksum)


      if (removeLastCharacter) {
        result.splice(result.length - 1, 1);
      }

      return {
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        codeset: codeset,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        endInfo: code,
        format: this.FORMAT
      };
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var self = this,
          trailingWhitespaceEnd;
      trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < self._row.length) {
        if (self._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "calculateCorrection",
    value: function calculateCorrection(expected, normalized, indices) {
      var length = indices.length,
          sumNormalized = 0,
          sumExpected = 0;

      while (length--) {
        sumExpected += expected[indices[length]];
        sumNormalized += normalized[indices[length]];
      }

      return sumExpected / sumNormalized;
    }
  }]);

  return Code128Reader;
}(barcode_reader);

/* harmony default export */ var code_128_reader = (code_128_reader_Code128Reader);
// EXTERNAL MODULE: ./node_modules/lodash/lodash.js
var lodash = __webpack_require__(12);

// CONCATENATED MODULE: ./src/reader/ean_reader.ts








function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ean_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


 // const CODE_L_START = 0;

var CODE_G_START = 10;

var START_PATTERN = [1, 1, 1];
var MIDDLE_PATTERN = [1, 1, 1, 1, 1];

var EXTENSION_START_PATTERN = [1, 1, 2];
var CODE_PATTERN = [[3, 2, 1, 1], [2, 2, 2, 1], [2, 1, 2, 2], [1, 4, 1, 1], [1, 1, 3, 2], [1, 2, 3, 1], [1, 1, 1, 4], [1, 3, 1, 2], [1, 2, 1, 3], [3, 1, 1, 2], [1, 1, 2, 3], [1, 2, 2, 2], [2, 2, 1, 2], [1, 1, 4, 1], [2, 3, 1, 1], [1, 3, 2, 1], [4, 1, 1, 1], [2, 1, 3, 1], [3, 1, 2, 1], [2, 1, 1, 3]];
var CODE_FREQUENCY = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26]; // const SINGLE_CODE_ERROR = 0.70;

var AVG_CODE_ERROR = 0.48;

var ean_reader_EANReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(EANReader, _BarcodeReader);

  var _super = ean_reader_createSuper(EANReader);

  // TODO: does this need to be in the class?
  function EANReader(config, supplements) {
    var _this;

    classCallCheck_default()(this, EANReader);

    _this = _super.call(this, Object(lodash["merge"])({
      supplements: []
    }, config), supplements);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_13');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.70);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1, 1, 1]);

    return _this;
  }

  createClass_default()(EANReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset, isWhite, tryHarder) {
      var counter = new Array(pattern.length).fill(0);
      var bestMatch = {
        error: Number.MAX_VALUE,
        start: 0,
        end: 0
      };
      var epsilon = AVG_CODE_ERROR; // console.warn('* findPattern', pattern, offset, isWhite, tryHarder, epsilon);

      var counterPos = 0;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        // console.warn(`* loop i=${offset} len=${this._row.length} isWhite=${isWhite} counterPos=${counterPos}`);
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos] += 1;
        } else {
          if (counterPos === counter.length - 1) {
            var error = this._matchPattern(counter, pattern); // console.warn('* matchPattern', error, counter, pattern);


            if (error < epsilon && bestMatch.error && error < bestMatch.error) {
              found = true;
              bestMatch.error = error;
              bestMatch.start = i - counter.reduce(function (sum, value) {
                return sum + value;
              }, 0);
              bestMatch.end = i; // console.warn('* return bestMatch', JSON.stringify(bestMatch));

              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      if (found) {// console.warn('* return bestMatch', JSON.stringify(bestMatch));
      } else {// console.warn('* return null');
        }

      return found ? bestMatch : null;
    } // TODO: findPattern and decodeCode appear to share quite similar code, can it be reduced?

  }, {
    key: "_decodeCode",
    value: function _decodeCode(start, coderange) {
      // console.warn('* decodeCode', start, coderange);
      var counter = [0, 0, 0, 0];
      var offset = start;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: start,
        end: start
      };
      var epsilon = AVG_CODE_ERROR;
      var isWhite = !this._row[offset];
      var counterPos = 0;

      if (!coderange) {
        // console.warn('* decodeCode before length');
        coderange = CODE_PATTERN.length; // console.warn('* decodeCode after length');
      }

      var found = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            for (var code = 0; code < coderange; code++) {
              var error = this._matchPattern(counter, CODE_PATTERN[code]);

              bestMatch.end = i;

              if (error < bestMatch.error) {
                bestMatch.code = code;
                bestMatch.error = error;
              }
            }

            if (bestMatch.error > epsilon) {
              // console.warn('* return null');
              return null;
            } // console.warn('* return bestMatch', JSON.stringify(bestMatch));


            return bestMatch;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return found ? bestMatch : null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      // console.warn('* findStart');
      var offset = this._nextSet(this._row);

      var startInfo = null;

      while (!startInfo) {
        startInfo = this._findPattern(START_PATTERN, offset, false, true); // console.warn('* startInfo=', JSON.stringify(startInfo));

        if (!startInfo) {
          return null;
        }

        var leadingWhitespaceStart = startInfo.start - (startInfo.end - startInfo.start);

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            // console.warn('* returning startInfo');
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      } // console.warn('* returning null');


      return null;
    }
  }, {
    key: "_calculateFirstDigit",
    value: function _calculateFirstDigit(codeFrequency) {
      // console.warn('* calculateFirstDigit', codeFrequency);
      for (var i = 0; i < CODE_FREQUENCY.length; i++) {
        if (codeFrequency === CODE_FREQUENCY[i]) {
          // console.warn('* returning', i);
          return i;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      // console.warn('* decodePayload', inCode, result, decodedCodes);
      var outCode = _objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end); // console.warn('* decodeCode=', outCode);

        if (!outCode) {
          // console.warn('* return null');
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code -= CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        } else {
          codeFrequency |= 0 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      var firstDigit = this._calculateFirstDigit(codeFrequency); // console.warn('* firstDigit=', firstDigit);


      if (firstDigit === null) {
        // console.warn('* return null');
        return null;
      }

      result.unshift(firstDigit);

      var middlePattern = this._findPattern(MIDDLE_PATTERN, outCode.end, true, false); // console.warn('* findPattern=', JSON.stringify(middlePattern));


      if (middlePattern === null || !middlePattern.end) {
        // console.warn('* return null');
        return null;
      }

      decodedCodes.push(middlePattern);

      for (var _i = 0; _i < 6; _i++) {
        middlePattern = this._decodeCode(middlePattern.end, CODE_G_START); // console.warn('* decodeCode=', JSON.stringify(middlePattern));

        if (!middlePattern) {
          // console.warn('* return null');
          return null;
        }

        decodedCodes.push(middlePattern);
        result.push(middlePattern.code);
      } // console.warn('* end code=', JSON.stringify(middlePattern));
      // console.warn('* end result=', JSON.stringify(result));
      // console.warn('* end decodedCodes=', decodedCodes);


      return middlePattern;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      // console.warn('* verifyTrailingWhitespace', JSON.stringify(endInfo));
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start);

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          // console.warn('* returning', JSON.stringify(endInfo));
          return endInfo;
        }
      } // console.warn('* return null');


      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      // console.warn('* findEnd', offset, isWhite);
      var endInfo = this._findPattern(this.STOP_PATTERN, offset, isWhite, false);

      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      // console.warn('* _checksum', result);
      var sum = 0;

      for (var i = result.length - 2; i >= 0; i -= 2) {
        sum += result[i];
      }

      sum *= 3;

      for (var _i2 = result.length - 1; _i2 >= 0; _i2 -= 2) {
        sum += result[_i2];
      } // console.warn('* end checksum', sum % 10 === 0);


      return sum % 10 === 0;
    }
  }, {
    key: "_decodeExtensions",
    value: function _decodeExtensions(offset) {
      var start = this._nextSet(this._row, offset);

      var startInfo = this._findPattern(EXTENSION_START_PATTERN, start, false, false);

      if (startInfo === null) {
        return null;
      } // console.warn('* decodeExtensions', this.supplements);
      // console.warn('* there are ', this.supplements.length, ' supplements');


      for (var i = 0; i < this.supplements.length; i++) {
        // console.warn('* extensions loop', i, this.supplements[i], this.supplements[i]._decode);
        try {
          var result = this.supplements[i]._decode(this._row, startInfo.end); // console.warn('* decode result=', result);


          if (result !== null) {
            return {
              code: result.code,
              start: start,
              startInfo: startInfo,
              end: result.end,
              decodedCodes: result.decodedCodes,
              format: this.supplements[i].FORMAT
            };
          }
        } catch (err) {
          console.error('* decodeExtensions error in ', this.supplements[i], ': ', err);
        }
      } // console.warn('* end decodeExtensions');


      return null;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      // console.warn('* decode', row);
      // console.warn('* decode', start);
      var result = new Array();
      var decodedCodes = new Array();
      var resultInfo = {};

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var code = {
        start: startInfo.start,
        end: startInfo.end
      };
      decodedCodes.push(code);
      code = this._decodePayload(code, result, decodedCodes);

      if (!code) {
        return null;
      }

      code = this._findEnd(code.end, false);

      if (!code) {
        return null;
      }

      decodedCodes.push(code); // Checksum

      if (!this._checksum(result)) {
        return null;
      } // console.warn('* this.supplements=', this.supplements);


      if (this.supplements.length > 0) {
        var supplement = this._decodeExtensions(code.end); // console.warn('* decodeExtensions returns', supplement);


        if (!supplement) {
          return null;
        }

        if (!supplement.decodedCodes) {
          return null;
        }

        var lastCode = supplement.decodedCodes[supplement.decodedCodes.length - 1];
        var endInfo = {
          start: lastCode.start + ((lastCode.end - lastCode.start) / 2 | 0),
          end: lastCode.end
        };

        if (!this._verifyTrailingWhitespace(endInfo)) {
          return null;
        }

        resultInfo = {
          supplement: supplement,
          code: result.join('') + supplement.code
        };
      }

      return _objectSpread(_objectSpread({
        code: result.join(''),
        start: startInfo.start,
        end: code.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes
      }, resultInfo), {}, {
        format: this.FORMAT
      });
    }
  }]);

  return EANReader;
}(barcode_reader);

/* harmony default export */ var ean_reader = (ean_reader_EANReader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(26);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// CONCATENATED MODULE: ./src/reader/code_39_reader.ts









function code_39_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. *$/+%';
var ALPHABET = new Uint16Array(toConsumableArray_default()(ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var CHARACTER_ENCODINGS = new Uint16Array([0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064, 0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C, 0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016, 0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x094, 0x0A8, 0x0A2, 0x08A, 0x02A]);
var ASTERISK = 0x094;

var code_39_reader_Code39Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code39Reader, _BarcodeReader);

  var _super = code_39_reader_createSuper(Code39Reader);

  function Code39Reader() {
    var _this;

    classCallCheck_default()(this, Code39Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39');

    return _this;
  }

  createClass_default()(Code39Reader, [{
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 7; j++) {
              counter[j] = counter[j + 2];
            }

            counter[7] = 0;
            counter[8] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var maxNarrowWidth = 0;
      var numWideBars = numCounters;
      var wideBarWidth = 0;

      while (numWideBars > 3) {
        maxNarrowWidth = this._findNextWidth(counters, maxNarrowWidth);
        numWideBars = 0;
        var pattern = 0;

        for (var i = 0; i < numCounters; i++) {
          if (counters[i] > maxNarrowWidth) {
            pattern |= 1 << numCounters - 1 - i;
            numWideBars++;
            wideBarWidth += counters[i];
          }
        }

        if (numWideBars === 3) {
          for (var _i = 0; _i < numCounters && numWideBars > 0; _i++) {
            if (counters[_i] > maxNarrowWidth) {
              numWideBars--;

              if (counters[_i] * 2 >= wideBarWidth) {
                return -1;
              }
            }
          }

          return pattern;
        }
      }

      return -1;
    }
  }, {
    key: "_findNextWidth",
    value: function _findNextWidth(counters, current) {
      var minWidth = Number.MAX_VALUE;

      for (var i = 0; i < counters.length; i++) {
        if (counters[i] < minWidth && counters[i] > current) {
          minWidth = counters[i];
        }
      }

      return minWidth;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < CHARACTER_ENCODINGS.length; i++) {
        if (CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(lastStart, nextStart, counters) {
      var patternSize = array_helper["a" /* default */].sum(counters);
      var trailingWhitespaceEnd = nextStart - lastStart - patternSize;

      if (trailingWhitespaceEnd * 3 >= patternSize) {
        return true;
      }

      return false;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var counters = new Uint16Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
      var result = [];
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = this._nextSet(this._row, start.end);

      var decodedChar;
      var lastStart;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyTrailingWhitespace(lastStart, nextStart, counters)) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code39Reader;
}(barcode_reader);

/* harmony default export */ var code_39_reader = (code_39_reader_Code39Reader);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/get.js
var get = __webpack_require__(16);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/reader/code_39_vin_reader.ts









function code_39_vin_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_39_vin_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_39_vin_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var patterns = {
  IOQ: /[IOQ]/g,
  AZ09: /[A-Z0-9]{17}/
};

var code_39_vin_reader_Code39VINReader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code39VINReader, _Code39Reader);

  var _super = code_39_vin_reader_createSuper(Code39VINReader);

  function Code39VINReader() {
    var _this;

    classCallCheck_default()(this, Code39VINReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_39_vin');

    return _this;
  }

  createClass_default()(Code39VINReader, [{
    key: "_checkChecksum",
    // TODO (this was todo in original repo, no text was there. sorry.)
    value: function _checkChecksum(code) {
      return !!code;
    } // Cribbed from:
    // https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/client/result/VINResultParser.java

  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code39VINReader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(patterns.IOQ, '');

      if (!code.match(patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      result.code = code;
      return result;
    }
  }]);

  return Code39VINReader;
}(code_39_reader);

/* harmony default export */ var code_39_vin_reader = (code_39_vin_reader_Code39VINReader);
// CONCATENATED MODULE: ./src/reader/codabar_reader.ts








function codabar_reader_createSuper(Derived) { var hasNativeReflectConstruct = codabar_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function codabar_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // const ALPHABETH_STRING = '0123456789-$:/.+ABCD';

var codabar_reader_ALPHABET = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 36, 58, 47, 46, 43, 65, 66, 67, 68];
var codabar_reader_CHARACTER_ENCODINGS = [0x003, 0x006, 0x009, 0x060, 0x012, 0x042, 0x021, 0x024, 0x030, 0x048, 0x00c, 0x018, 0x045, 0x051, 0x054, 0x015, 0x01A, 0x029, 0x00B, 0x00E];
var START_END = [0x01A, 0x029, 0x00B, 0x00E];
var MIN_ENCODED_CHARS = 4;
var MAX_ACCEPTABLE = 2.0;
var PADDING = 1.5;
;
;

var codabar_reader_NewCodabarReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(NewCodabarReader, _BarcodeReader);

  var _super = codabar_reader_createSuper(NewCodabarReader);

  function NewCodabarReader() {
    var _this;

    classCallCheck_default()(this, NewCodabarReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "_counters", []);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'codabar');

    return _this;
  }

  createClass_default()(NewCodabarReader, [{
    key: "_computeAlternatingThreshold",
    value: function _computeAlternatingThreshold(offset, end) {
      var min = Number.MAX_VALUE;
      var max = 0;
      var counter = 0;

      for (var i = offset; i < end; i += 2) {
        counter = this._counters[i];

        if (counter > max) {
          max = counter;
        }

        if (counter < min) {
          min = counter;
        }
      }

      return (min + max) / 2.0 | 0;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(offset) {
      var numCounters = 7;
      var end = offset + numCounters;

      if (end > this._counters.length) {
        return -1;
      }

      var barThreshold = this._computeAlternatingThreshold(offset, end);

      var spaceThreshold = this._computeAlternatingThreshold(offset + 1, end);

      var bitmask = 1 << numCounters - 1;
      var threshold = 0;
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        threshold = (i & 1) === 0 ? barThreshold : spaceThreshold;

        if (this._counters[offset + i] > threshold) {
          pattern |= bitmask;
        }

        bitmask >>= 1;
      }

      return pattern;
    }
  }, {
    key: "_isStartEnd",
    value: function _isStartEnd(pattern) {
      for (var i = 0; i < START_END.length; i++) {
        if (START_END[i] === pattern) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_sumCounters",
    value: function _sumCounters(start, end) {
      var sum = 0;

      for (var i = start; i < end; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var start = this._nextUnset(this._row);

      var end = start;

      for (var i = 1; i < this._counters.length; i++) {
        var pattern = this._toPattern(i);

        if (pattern !== -1 && this._isStartEnd(pattern)) {
          // TODO: Look for whitespace ahead
          start += this._sumCounters(0, i);
          end = start + this._sumCounters(i, i + 8);
          return {
            start: start,
            end: end,
            startCounter: i,
            endCounter: i + 8
          };
        }
      }

      return null;
    }
  }, {
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < codabar_reader_CHARACTER_ENCODINGS.length; i++) {
        if (codabar_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(codabar_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_calculatePatternLength",
    value: function _calculatePatternLength(offset) {
      var sum = 0;

      for (var i = offset; i < offset + 7; i++) {
        sum += this._counters[i];
      }

      return sum;
    }
  }, {
    key: "_verifyWhitespace",
    value: function _verifyWhitespace(startCounter, endCounter) {
      if (startCounter - 1 <= 0 || this._counters[startCounter - 1] >= this._calculatePatternLength(startCounter) / 2.0) {
        if (endCounter + 8 >= this._counters.length || this._counters[endCounter + 7] >= this._calculatePatternLength(endCounter) / 2.0) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_charToPattern",
    value: function _charToPattern(_char) {
      var charCode = _char.charCodeAt(0);

      for (var i = 0; i < codabar_reader_ALPHABET.length; i++) {
        if (codabar_reader_ALPHABET[i] === charCode) {
          return codabar_reader_CHARACTER_ENCODINGS[i];
        }
      }

      return 0x0;
    }
  }, {
    key: "_thresholdResultPattern",
    value: function _thresholdResultPattern(result, startCounter) {
      var categorization = {
        space: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        },
        bar: {
          narrow: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          },
          wide: {
            size: 0,
            counts: 0,
            min: 0,
            max: Number.MAX_VALUE
          }
        }
      };
      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 2 ? categorization.bar : categorization.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          cat.size += this._counters[pos + j];
          cat.counts++;
          pattern >>= 1;
        }

        pos += 8;
      }

      ['space', 'bar'].forEach(function (key) {
        var newkind = categorization[key];
        newkind.wide.min = Math.floor((newkind.narrow.size / newkind.narrow.counts + newkind.wide.size / newkind.wide.counts) / 2);
        newkind.narrow.max = Math.ceil(newkind.wide.min);
        newkind.wide.max = Math.ceil((newkind.wide.size * MAX_ACCEPTABLE + PADDING) / newkind.wide.counts);
      });
      return categorization;
    }
  }, {
    key: "_validateResult",
    value: function _validateResult(result, startCounter) {
      var thresholds = this._thresholdResultPattern(result, startCounter);

      var pos = startCounter;
      var pattern;

      for (var i = 0; i < result.length; i++) {
        pattern = this._charToPattern(result[i]);

        for (var j = 6; j >= 0; j--) {
          var kind = (j & 1) === 0 ? thresholds.bar : thresholds.space;
          var cat = (pattern & 1) === 1 ? kind.wide : kind.narrow;
          var size = this._counters[pos + j];

          if (size < cat.min || size > cat.max) {
            return false;
          }

          pattern >>= 1;
        }

        pos += 8;
      }

      return true;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      this._counters = this._fillCounters();
      start = this._findStart();

      if (!start) {
        return null;
      }

      var nextStart = start.startCounter;
      var result = [];
      var pattern;

      do {
        pattern = this._toPattern(nextStart);

        if (pattern < 0) {
          return null;
        }

        var decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        nextStart += 8;

        if (result.length > 1 && this._isStartEnd(pattern)) {
          break;
        }
      } while (nextStart < this._counters.length); // verify end


      if (result.length - 2 < MIN_ENCODED_CHARS || !this._isStartEnd(pattern)) {
        return null;
      } // verify end white space


      if (!this._verifyWhitespace(start.startCounter, nextStart - 8)) {
        return null;
      }

      if (!this._validateResult(result, start.startCounter)) {
        return null;
      }

      nextStart = nextStart > this._counters.length ? this._counters.length : nextStart;

      var end = start.start + this._sumCounters(start.startCounter, nextStart - 8);

      return {
        code: result.join(''),
        start: start.start,
        end: end,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT // TODO: i think it should not be required to return format from this, as barcode_reader force sets the format anyway

      };
    }
  }]);

  return NewCodabarReader;
}(barcode_reader);

/* harmony default export */ var codabar_reader = (codabar_reader_NewCodabarReader);
// CONCATENATED MODULE: ./src/reader/upc_reader.ts








function upc_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_reader_UPCReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCReader, _EANReader);

  var _super = upc_reader_createSuper(UPCReader);

  function UPCReader() {
    var _this;

    classCallCheck_default()(this, UPCReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_a');

    return _this;
  }

  createClass_default()(UPCReader, [{
    key: "_decode",
    value: function _decode(row, start) {
      var result = ean_reader.prototype._decode.call(this);

      if (result && result.code && result.code.length === 13 && result.code.charAt(0) === '0') {
        result.code = result.code.substring(1);
        return result;
      }

      return null;
    }
  }]);

  return UPCReader;
}(ean_reader);

/* harmony default export */ var upc_reader = (upc_reader_UPCReader);
// CONCATENATED MODULE: ./src/reader/ean_8_reader.ts








function ean_8_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_8_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_8_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_8_reader_EAN8Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN8Reader, _EANReader);

  var _super = ean_8_reader_createSuper(EAN8Reader);

  function EAN8Reader() {
    var _this;

    classCallCheck_default()(this, EAN8Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_8');

    return _this;
  }

  createClass_default()(EAN8Reader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var code = inCode;

      for (var i = 0; i < 4; i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        result.push(code.code);
        decodedCodes.push(code);
      }

      code = this._findPattern(MIDDLE_PATTERN, code.end, true, false);

      if (code === null) {
        return null;
      }

      decodedCodes.push(code);

      for (var _i = 0; _i < 4; _i++) {
        code = this._decodeCode(code.end, CODE_G_START);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code);
      }

      return code;
    }
  }]);

  return EAN8Reader;
}(ean_reader);

/* harmony default export */ var ean_8_reader = (ean_8_reader_EAN8Reader);
// CONCATENATED MODULE: ./src/reader/ean_2_reader.ts








function ean_2_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_2_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_2_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var ean_2_reader_EAN2Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN2Reader, _EANReader);

  var _super = ean_2_reader_createSuper(EAN2Reader);

  function EAN2Reader() {
    var _this;

    classCallCheck_default()(this, EAN2Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_2');

    return _this;
  }

  createClass_default()(EAN2Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var result = [];
      var decodedCodes = [];
      var code = null;

      if (offset === undefined) {
        return null;
      }

      for (var i = 0; i < 2 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 1 - i;
        }

        if (i !== 1) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 2 || parseInt(result.join('')) % 4 !== codeFrequency) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN2Reader;
}(ean_reader);

;
/* harmony default export */ var ean_2_reader = (ean_2_reader_EAN2Reader);
// CONCATENATED MODULE: ./src/reader/ean_5_reader.ts








function ean_5_reader_createSuper(Derived) { var hasNativeReflectConstruct = ean_5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function ean_5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];

function determineCheckDigit(codeFrequency) {
  for (var i = 0; i < 10; i++) {
    if (codeFrequency === CHECK_DIGIT_ENCODINGS[i]) {
      return i;
    }
  }

  return null;
}

function extensionChecksum(result) {
  var length = result.length;
  var sum = 0;

  for (var i = length - 2; i >= 0; i -= 2) {
    sum += result[i];
  }

  sum *= 3;

  for (var _i = length - 1; _i >= 0; _i -= 2) {
    sum += result[_i];
  }

  sum *= 3;
  return sum % 10;
}

var ean_5_reader_EAN5Reader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(EAN5Reader, _EANReader);

  var _super = ean_5_reader_createSuper(EAN5Reader);

  function EAN5Reader() {
    var _this;

    classCallCheck_default()(this, EAN5Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'ean_5');

    return _this;
  }

  createClass_default()(EAN5Reader, [{
    key: "_decode",
    value: function _decode(row, start) {
      if (start === undefined) {
        return null;
      }

      if (row) {
        this._row = row;
      }

      var codeFrequency = 0;
      var offset = start;
      var end = this._row.length;
      var code = null;
      var result = [];
      var decodedCodes = [];

      for (var i = 0; i < 5 && offset < end; i++) {
        code = this._decodeCode(offset);

        if (!code) {
          return null;
        }

        decodedCodes.push(code);
        result.push(code.code % 10);

        if (code.code >= CODE_G_START) {
          codeFrequency |= 1 << 4 - i;
        }

        if (i !== 4) {
          offset = this._nextSet(this._row, code.end);
          offset = this._nextUnset(this._row, offset);
        }
      }

      if (result.length !== 5) {
        return null;
      }

      if (extensionChecksum(result) !== determineCheckDigit(codeFrequency)) {
        return null;
      }

      var startInfo = this._findStart();

      return {
        code: result.join(''),
        decodedCodes: decodedCodes,
        end: code.end,
        format: this.FORMAT,
        startInfo: startInfo,
        start: startInfo.start
      };
    }
  }]);

  return EAN5Reader;
}(ean_reader);

;
/* harmony default export */ var ean_5_reader = (ean_5_reader_EAN5Reader);
// CONCATENATED MODULE: ./src/reader/upc_e_reader.ts









function upc_e_reader_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function upc_e_reader_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { upc_e_reader_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { upc_e_reader_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function upc_e_reader_createSuper(Derived) { var hasNativeReflectConstruct = upc_e_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function upc_e_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var upc_e_reader_UPCEReader = /*#__PURE__*/function (_EANReader) {
  inherits_default()(UPCEReader, _EANReader);

  var _super = upc_e_reader_createSuper(UPCEReader);

  function UPCEReader() {
    var _this;

    classCallCheck_default()(this, UPCEReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_FREQUENCY", [[56, 52, 50, 49, 44, 38, 35, 42, 41, 37], [7, 11, 13, 14, 19, 25, 28, 21, 22, 26]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7, 1 / 6 * 7]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'upc_e');

    return _this;
  }

  createClass_default()(UPCEReader, [{
    key: "_decodePayload",
    value: function _decodePayload(inCode, result, decodedCodes) {
      var outCode = upc_e_reader_objectSpread({}, inCode);

      var codeFrequency = 0x0;

      for (var i = 0; i < 6; i++) {
        outCode = this._decodeCode(outCode.end);

        if (!outCode) {
          return null;
        }

        if (outCode.code >= CODE_G_START) {
          outCode.code = outCode.code - CODE_G_START;
          codeFrequency |= 1 << 5 - i;
        }

        result.push(outCode.code);
        decodedCodes.push(outCode);
      }

      if (!this._determineParity(codeFrequency, result)) {
        return null;
      }

      return outCode;
    }
  }, {
    key: "_determineParity",
    value: function _determineParity(codeFrequency, result) {
      for (var nrSystem = 0; nrSystem < this.CODE_FREQUENCY.length; nrSystem++) {
        for (var i = 0; i < this.CODE_FREQUENCY[nrSystem].length; i++) {
          if (codeFrequency === this.CODE_FREQUENCY[nrSystem][i]) {
            result.unshift(nrSystem);
            result.push(i);
            return true;
          }
        }
      }

      return false;
    }
  }, {
    key: "_convertToUPCA",
    value: function _convertToUPCA(result) {
      var upca = [result[0]];
      var lastDigit = result[result.length - 2];

      if (lastDigit <= 2) {
        upca = upca.concat(result.slice(1, 3)).concat([lastDigit, 0, 0, 0, 0]).concat(result.slice(3, 6));
      } else if (lastDigit === 3) {
        upca = upca.concat(result.slice(1, 4)).concat([0, 0, 0, 0, 0]).concat(result.slice(4, 6));
      } else if (lastDigit === 4) {
        upca = upca.concat(result.slice(1, 5)).concat([0, 0, 0, 0, 0, result[5]]);
      } else {
        upca = upca.concat(result.slice(1, 6)).concat([0, 0, 0, 0, lastDigit]);
      }

      upca.push(result[result.length - 1]);
      return upca;
    }
  }, {
    key: "_checksum",
    value: function _checksum(result) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_checksum", this).call(this, this._convertToUPCA(result));
    }
  }, {
    key: "_findEnd",
    value: function _findEnd(offset, isWhite) {
      return get_default()(getPrototypeOf_default()(UPCEReader.prototype), "_findEnd", this).call(this, offset, true);
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }]);

  return UPCEReader;
}(ean_reader);

/* harmony default export */ var upc_e_reader = (upc_e_reader_UPCEReader);
// CONCATENATED MODULE: ./src/reader/i2of5_reader.ts








function i2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = i2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function i2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// TODO: i2of5_reader and 2of5_reader share very similar code, make use of that


var N = 1;
var W = 3;

var i2of5_reader_I2of5Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(I2of5Reader, _BarcodeReader);

  var _super = i2of5_reader_createSuper(I2of5Reader);

  function I2of5Reader(opts) {
    var _this;

    classCallCheck_default()(this, I2of5Reader);

    _this = _super.call(this, Object(lodash["merge"])({
      normalizeBarSpaceWidth: false
    }, opts));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.38);

    defineProperty_default()(assertThisInitialized_default()(_this), "START_PATTERN", [N, N, N, N]);

    defineProperty_default()(assertThisInitialized_default()(_this), "STOP_PATTERN", [N, N, W]);

    defineProperty_default()(assertThisInitialized_default()(_this), "CODE_PATTERN", [[N, N, W, W, N], [W, N, N, N, W], [N, W, N, N, W], [W, W, N, N, N], [N, N, W, N, W], [W, N, W, N, N], [N, W, W, N, N], [N, N, N, W, W], [W, N, N, W, N], [N, W, N, W, N]]);

    defineProperty_default()(assertThisInitialized_default()(_this), "MAX_CORRECTION_FACTOR", 5);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'i2of5');

    if (opts.normalizeBarSpaceWidth) {
      _this.SINGLE_CODE_ERROR = 0.38;
      _this.AVG_CODE_ERROR = 0.09;
    }

    _this.config = opts;
    return possibleConstructorReturn_default()(_this, assertThisInitialized_default()(_this));
  }

  createClass_default()(I2of5Reader, [{
    key: "_matchPattern",
    value: function _matchPattern(counter, code) {
      if (this.config.normalizeBarSpaceWidth) {
        var counterSum = [0, 0];
        var codeSum = [0, 0];
        var correction = [0, 0];
        var correctionRatio = this.MAX_CORRECTION_FACTOR;
        var correctionRatioInverse = 1 / correctionRatio;

        for (var i = 0; i < counter.length; i++) {
          counterSum[i % 2] += counter[i];
          codeSum[i % 2] += code[i];
        }

        correction[0] = codeSum[0] / counterSum[0];
        correction[1] = codeSum[1] / counterSum[1];
        correction[0] = Math.max(Math.min(correction[0], correctionRatio), correctionRatioInverse);
        correction[1] = Math.max(Math.min(correction[1], correctionRatio), correctionRatioInverse);
        this.barSpaceRatio = correction;

        for (var _i = 0; _i < counter.length; _i++) {
          counter[_i] *= this.barSpaceRatio[_i % 2];
        }
      }

      return barcode_reader.prototype._matchPattern.call(this, counter, code);
    }
  }, {
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = new Array(pattern.length).fill(0);
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var epsilon = this.AVG_CODE_ERROR;
      isWhite = isWhite || false;
      tryHarder = tryHarder || false;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            var sum = counter.reduce(function (prev, next) {
              return prev + next;
            }, 0);

            var error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = i - sum;
              bestMatch.end = i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var j = 0; j < counter.length - 2; j++) {
                counter[j] = counter[j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var leadingWhitespaceStart = 0;

      var offset = this._nextSet(this._row);

      var startInfo = null;
      var narrowBarWidth = 1;

      while (!startInfo) {
        startInfo = this._findPattern(this.START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / 4);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 10;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return null;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      this._row.reverse();

      var endInfo = this._findPattern(this.STOP_PATTERN);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_decodePair",
    value: function _decodePair(counterPair) {
      var codes = [];

      for (var i = 0; i < counterPair.length; i++) {
        var code = this._decodeCode(counterPair[i]);

        if (!code) {
          return null;
        }

        codes.push(code);
      }

      return codes;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < this.CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, this.CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counterPair = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0]];
      var codes = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counterPair[0][i] = counters[pos] * this.barSpaceRatio[0];
          counterPair[1][i] = counters[pos + 1] * this.barSpaceRatio[1];
          pos += 2;
        }

        codes = this._decodePair(counterPair);

        if (!codes) {
          return null;
        }

        for (var _i2 = 0; _i2 < codes.length; _i2++) {
          result.push(codes[_i2].code + '');
          decodedCodes.push(codes[_i2]);
        }
      }

      return codes;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = new Array();
      var decodedCodes = new Array();

      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      decodedCodes.push(startInfo);

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length % 2 !== 0 || result.length < 6) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return I2of5Reader;
}(barcode_reader);

/* harmony default export */ var i2of5_reader = (i2of5_reader_I2of5Reader);
// CONCATENATED MODULE: ./src/reader/2of5_reader.ts








function _2of5_reader_createSuper(Derived) { var hasNativeReflectConstruct = _2of5_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _2of5_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var _2of5_reader_N = 1;
var _2of5_reader_W = 3;
var _2of5_reader_START_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N];
var STOP_PATTERN = [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W];
var _2of5_reader_CODE_PATTERN = [[_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_W, _2of5_reader_N, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_W], [_2of5_reader_W, _2of5_reader_N, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N], [_2of5_reader_N, _2of5_reader_W, _2of5_reader_N, _2of5_reader_W, _2of5_reader_N]];
var START_PATTERN_LENGTH = _2of5_reader_START_PATTERN.reduce(function (sum, val) {
  return sum + val;
}, 0);

var _2of5_reader_TwoOfFiveReader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(TwoOfFiveReader, _BarcodeReader);

  var _super = _2of5_reader_createSuper(TwoOfFiveReader);

  function TwoOfFiveReader() {
    var _this;

    classCallCheck_default()(this, TwoOfFiveReader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "barSpaceRatio", [1, 1]);

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", '2of5');

    defineProperty_default()(assertThisInitialized_default()(_this), "SINGLE_CODE_ERROR", 0.78);

    defineProperty_default()(assertThisInitialized_default()(_this), "AVG_CODE_ERROR", 0.30);

    return _this;
  }

  createClass_default()(TwoOfFiveReader, [{
    key: "_findPattern",
    value: function _findPattern(pattern, offset) {
      var isWhite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tryHarder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var counter = [];
      var counterPos = 0;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };
      var sum = 0;
      var error = 0;
      var epsilon = this.AVG_CODE_ERROR;

      if (!offset) {
        offset = this._nextSet(this._row);
      }

      for (var i = 0; i < pattern.length; i++) {
        counter[i] = 0;
      }

      for (var _i = offset; _i < this._row.length; _i++) {
        if (this._row[_i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            sum = 0;

            for (var j = 0; j < counter.length; j++) {
              sum += counter[j];
            }

            error = this._matchPattern(counter, pattern);

            if (error < epsilon) {
              bestMatch.error = error;
              bestMatch.start = _i - sum;
              bestMatch.end = _i;
              return bestMatch;
            }

            if (tryHarder) {
              for (var _j = 0; _j < counter.length - 2; _j++) {
                counter[_j] = counter[_j + 2];
              }

              counter[counter.length - 2] = 0;
              counter[counter.length - 1] = 0;
              counterPos--;
            } else {
              return null;
            }
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var startInfo = null;

      var offset = this._nextSet(this._row);

      var narrowBarWidth = 1;
      var leadingWhitespaceStart = 0;

      while (!startInfo) {
        startInfo = this._findPattern(_2of5_reader_START_PATTERN, offset, false, true);

        if (!startInfo) {
          return null;
        }

        narrowBarWidth = Math.floor((startInfo.end - startInfo.start) / START_PATTERN_LENGTH);
        leadingWhitespaceStart = startInfo.start - narrowBarWidth * 5;

        if (leadingWhitespaceStart >= 0) {
          if (this._matchRange(leadingWhitespaceStart, startInfo.start, 0)) {
            return startInfo;
          }
        }

        offset = startInfo.end;
        startInfo = null;
      }

      return startInfo;
    }
  }, {
    key: "_verifyTrailingWhitespace",
    value: function _verifyTrailingWhitespace(endInfo) {
      var trailingWhitespaceEnd = endInfo.end + (endInfo.end - endInfo.start) / 2;

      if (trailingWhitespaceEnd < this._row.length) {
        if (this._matchRange(endInfo.end, trailingWhitespaceEnd, 0)) {
          return endInfo;
        }
      }

      return null;
    }
  }, {
    key: "_findEnd",
    value: function _findEnd() {
      // TODO: reverse, followed by some calcs, followed by another reverse? really?
      this._row.reverse();

      var offset = this._nextSet(this._row);

      var endInfo = this._findPattern(STOP_PATTERN, offset, false, true);

      this._row.reverse();

      if (endInfo === null) {
        return null;
      } // reverse numbers


      var tmp = endInfo.start;
      endInfo.start = this._row.length - endInfo.end;
      endInfo.end = this._row.length - tmp;
      return endInfo !== null ? this._verifyTrailingWhitespace(endInfo) : null;
    }
  }, {
    key: "_verifyCounterLength",
    value: function _verifyCounterLength(counters) {
      return counters.length % 10 === 0;
    }
  }, {
    key: "_decodeCode",
    value: function _decodeCode(counter) {
      var epsilon = this.AVG_CODE_ERROR;
      var bestMatch = {
        error: Number.MAX_VALUE,
        code: -1,
        start: 0,
        end: 0
      };

      for (var code = 0; code < _2of5_reader_CODE_PATTERN.length; code++) {
        var error = this._matchPattern(counter, _2of5_reader_CODE_PATTERN[code]);

        if (error < bestMatch.error) {
          bestMatch.code = code;
          bestMatch.error = error;
        }
      }

      if (bestMatch.error < epsilon) {
        return bestMatch;
      }

      return null;
    }
  }, {
    key: "_decodePayload",
    value: function _decodePayload(counters, result, decodedCodes) {
      var pos = 0;
      var counterLength = counters.length;
      var counter = [0, 0, 0, 0, 0];
      var code = null;

      while (pos < counterLength) {
        for (var i = 0; i < 5; i++) {
          counter[i] = counters[pos] * this.barSpaceRatio[0];
          pos += 2;
        }

        code = this._decodeCode(counter);

        if (!code) {
          return null;
        }

        result.push("".concat(code.code));
        decodedCodes.push(code);
      }

      return code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var startInfo = this._findStart();

      if (!startInfo) {
        return null;
      }

      var endInfo = this._findEnd();

      if (!endInfo) {
        return null;
      }

      var counters = this._fillCounters(startInfo.end, endInfo.start, false);

      if (!this._verifyCounterLength(counters)) {
        return null;
      }

      var decodedCodes = [];
      decodedCodes.push(startInfo);
      var result = [];

      var code = this._decodePayload(counters, result, decodedCodes);

      if (!code) {
        return null;
      }

      if (result.length < 5) {
        return null;
      }

      decodedCodes.push(endInfo);
      return {
        code: result.join(''),
        start: startInfo.start,
        end: endInfo.end,
        startInfo: startInfo,
        decodedCodes: decodedCodes,
        format: this.FORMAT
      };
    }
  }]);

  return TwoOfFiveReader;
}(barcode_reader);

/* harmony default export */ var _2of5_reader = (_2of5_reader_TwoOfFiveReader);
// CONCATENATED MODULE: ./src/reader/code_93_reader.ts









function code_93_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_93_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_93_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var code_93_reader_ALPHABETH_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%abcd*';
var code_93_reader_ALPHABET = new Uint16Array(toConsumableArray_default()(code_93_reader_ALPHABETH_STRING).map(function (_char) {
  return _char.charCodeAt(0);
}));
var code_93_reader_CHARACTER_ENCODINGS = new Uint16Array([0x114, 0x148, 0x144, 0x142, 0x128, 0x124, 0x122, 0x150, 0x112, 0x10A, 0x1A8, 0x1A4, 0x1A2, 0x194, 0x192, 0x18A, 0x168, 0x164, 0x162, 0x134, 0x11A, 0x158, 0x14C, 0x146, 0x12C, 0x116, 0x1B4, 0x1B2, 0x1AC, 0x1A6, 0x196, 0x19A, 0x16C, 0x166, 0x136, 0x13A, 0x12E, 0x1D4, 0x1D2, 0x1CA, 0x16E, 0x176, 0x1AE, 0x126, 0x1DA, 0x1D6, 0x132, 0x15E]);
var code_93_reader_ASTERISK = 0x15E;

var code_93_reader_Code93Reader = /*#__PURE__*/function (_BarcodeReader) {
  inherits_default()(Code93Reader, _BarcodeReader);

  var _super = code_93_reader_createSuper(Code93Reader);

  function Code93Reader() {
    var _this;

    classCallCheck_default()(this, Code93Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_93');

    return _this;
  }

  createClass_default()(Code93Reader, [{
    key: "_patternToChar",
    value: function _patternToChar(pattern) {
      for (var i = 0; i < code_93_reader_CHARACTER_ENCODINGS.length; i++) {
        if (code_93_reader_CHARACTER_ENCODINGS[i] === pattern) {
          return String.fromCharCode(code_93_reader_ALPHABET[i]);
        }
      }

      return null;
    }
  }, {
    key: "_toPattern",
    value: function _toPattern(counters) {
      var numCounters = counters.length;
      var sum = counters.reduce(function (prev, next) {
        return prev + next;
      }, 0);
      var pattern = 0;

      for (var i = 0; i < numCounters; i++) {
        var normalized = Math.round(counters[i] * 9 / sum);

        if (normalized < 1 || normalized > 4) {
          return -1;
        }

        if ((i & 1) === 0) {
          for (var j = 0; j < normalized; j++) {
            pattern = pattern << 1 | 1;
          }
        } else {
          pattern <<= normalized;
        }
      }

      return pattern;
    }
  }, {
    key: "_findStart",
    value: function _findStart() {
      var offset = this._nextSet(this._row);

      var patternStart = offset;
      var counter = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var counterPos = 0;
      var isWhite = false;

      for (var i = offset; i < this._row.length; i++) {
        if (this._row[i] ^ (isWhite ? 1 : 0)) {
          counter[counterPos]++;
        } else {
          if (counterPos === counter.length - 1) {
            // find start pattern
            if (this._toPattern(counter) === code_93_reader_ASTERISK) {
              var whiteSpaceMustStart = Math.floor(Math.max(0, patternStart - (i - patternStart) / 4));

              if (this._matchRange(whiteSpaceMustStart, patternStart, 0)) {
                return {
                  start: patternStart,
                  end: i
                };
              }
            }

            patternStart += counter[0] + counter[1];

            for (var j = 0; j < 4; j++) {
              counter[j] = counter[j + 2];
            }

            counter[4] = 0;
            counter[5] = 0;
            counterPos--;
          } else {
            counterPos++;
          }

          counter[counterPos] = 1;
          isWhite = !isWhite;
        }
      }

      return null;
    }
  }, {
    key: "_verifyEnd",
    value: function _verifyEnd(lastStart, nextStart) {
      if (lastStart === nextStart || !this._row[nextStart]) {
        return false;
      }

      return true;
    }
  }, {
    key: "_decodeExtended",
    value: function _decodeExtended(charArray) {
      var length = charArray.length;
      var result = [];

      for (var i = 0; i < length; i++) {
        var _char2 = charArray[i];

        if (_char2 >= 'a' && _char2 <= 'd') {
          if (i > length - 2) {
            return null;
          }

          var nextChar = charArray[++i];
          var nextCharCode = nextChar.charCodeAt(0);
          var decodedChar = void 0;

          switch (_char2) {
            case 'a':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode - 64);
              } else {
                return null;
              }

              break;

            case 'b':
              if (nextChar >= 'A' && nextChar <= 'E') {
                decodedChar = String.fromCharCode(nextCharCode - 38);
              } else if (nextChar >= 'F' && nextChar <= 'J') {
                decodedChar = String.fromCharCode(nextCharCode - 11);
              } else if (nextChar >= 'K' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode + 16);
              } else if (nextChar >= 'P' && nextChar <= 'S') {
                decodedChar = String.fromCharCode(nextCharCode + 43);
              } else if (nextChar >= 'T' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(127);
              } else {
                return null;
              }

              break;

            case 'c':
              if (nextChar >= 'A' && nextChar <= 'O') {
                decodedChar = String.fromCharCode(nextCharCode - 32);
              } else if (nextChar === 'Z') {
                decodedChar = ':';
              } else {
                return null;
              }

              break;

            case 'd':
              if (nextChar >= 'A' && nextChar <= 'Z') {
                decodedChar = String.fromCharCode(nextCharCode + 32);
              } else {
                return null;
              }

              break;

            default:
              console.warn('* code_93_reader _decodeExtended hit default case, this may be an error', decodedChar);
              return null;
          }

          result.push(decodedChar);
        } else {
          result.push(_char2);
        }
      }

      return result;
    }
  }, {
    key: "_matchCheckChar",
    value: function _matchCheckChar(charArray, index, maxWeight) {
      var arrayToCheck = charArray.slice(0, index);
      var length = arrayToCheck.length;
      var weightedSums = arrayToCheck.reduce(function (sum, _char3, i) {
        var weight = (i * -1 + (length - 1)) % maxWeight + 1;
        var value = code_93_reader_ALPHABET.indexOf(_char3.charCodeAt(0));
        return sum + weight * value;
      }, 0);
      var checkChar = code_93_reader_ALPHABET[weightedSums % 47];
      return checkChar === charArray[index].charCodeAt(0);
    }
  }, {
    key: "_verifyChecksums",
    value: function _verifyChecksums(charArray) {
      return this._matchCheckChar(charArray, charArray.length - 2, 20) && this._matchCheckChar(charArray, charArray.length - 1, 15);
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      start = this._findStart();

      if (!start) {
        return null;
      }

      var counters = new Uint16Array([0, 0, 0, 0, 0, 0]);
      var result = [];

      var nextStart = this._nextSet(this._row, start.end);

      var lastStart;
      var decodedChar;

      do {
        counters = this._toCounters(nextStart, counters);

        var pattern = this._toPattern(counters);

        if (pattern < 0) {
          return null;
        }

        decodedChar = this._patternToChar(pattern);

        if (decodedChar === null) {
          return null;
        }

        result.push(decodedChar);
        lastStart = nextStart;
        nextStart += array_helper["a" /* default */].sum(counters);
        nextStart = this._nextSet(this._row, nextStart);
      } while (decodedChar !== '*');

      result.pop();

      if (!result.length) {
        return null;
      }

      if (!this._verifyEnd(lastStart, nextStart)) {
        return null;
      }

      if (!this._verifyChecksums(result)) {
        return null;
      }

      result = result.slice(0, result.length - 2); // yes, this is an assign inside an if.

      if ((result = this._decodeExtended(result)) === null) {
        return null;
      }

      return {
        code: result.join(''),
        start: start.start,
        end: nextStart,
        startInfo: start,
        decodedCodes: result,
        format: this.FORMAT
      };
    }
  }]);

  return Code93Reader;
}(barcode_reader);

/* harmony default export */ var code_93_reader = (code_93_reader_Code93Reader);
// CONCATENATED MODULE: ./src/reader/code_32_reader.ts









function code_32_reader_createSuper(Derived) { var hasNativeReflectConstruct = code_32_reader_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function code_32_reader_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }


var code_32_reader_patterns = {
  AEIO: /[AEIO]/g,
  AZ09: /[A-Z0-9]/
};
var plaintextcode = [{
  "digit_code": 0,
  "character_code": "0"
}, {
  "digit_code": 1,
  "character_code": "1"
}, {
  "digit_code": 2,
  "character_code": "2"
}, {
  "digit_code": 3,
  "character_code": "3"
}, {
  "digit_code": 4,
  "character_code": "4"
}, {
  "digit_code": 5,
  "character_code": "5"
}, {
  "digit_code": 6,
  "character_code": "6"
}, {
  "digit_code": 7,
  "character_code": "7"
}, {
  "digit_code": 8,
  "character_code": "8"
}, {
  "digit_code": 9,
  "character_code": "9"
}, {
  "digit_code": 10,
  "character_code": "B"
}, {
  "digit_code": 11,
  "character_code": "C"
}, {
  "digit_code": 12,
  "character_code": "D"
}, {
  "digit_code": 13,
  "character_code": "F"
}, {
  "digit_code": 14,
  "character_code": "G"
}, {
  "digit_code": 15,
  "character_code": "H"
}, {
  "digit_code": 16,
  "character_code": "J"
}, {
  "digit_code": 17,
  "character_code": "K"
}, {
  "digit_code": 18,
  "character_code": "L"
}, {
  "digit_code": 19,
  "character_code": "M"
}, {
  "digit_code": 20,
  "character_code": "N"
}, {
  "digit_code": 21,
  "character_code": "P"
}, {
  "digit_code": 22,
  "character_code": "Q"
}, {
  "digit_code": 23,
  "character_code": "R"
}, {
  "digit_code": 24,
  "character_code": "S"
}, {
  "digit_code": 25,
  "character_code": "T"
}, {
  "digit_code": 26,
  "character_code": "U"
}, {
  "digit_code": 27,
  "character_code": "V"
}, {
  "digit_code": 28,
  "character_code": "W"
}, {
  "digit_code": 29,
  "character_code": "X"
}, {
  "digit_code": 30,
  "character_code": "Y"
}, {
  "digit_code": 31,
  "character_code": "Z"
}];

var code_32_reader_Code32Reader = /*#__PURE__*/function (_Code39Reader) {
  inherits_default()(Code32Reader, _Code39Reader);

  var _super = code_32_reader_createSuper(Code32Reader);

  function Code32Reader() {
    var _this;

    classCallCheck_default()(this, Code32Reader);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    defineProperty_default()(assertThisInitialized_default()(_this), "FORMAT", 'code_32_reader');

    return _this;
  }

  createClass_default()(Code32Reader, [{
    key: "_checkChecksum",
    // TODO (this was todo in original repo, no text was there. sorry.)
    value: function _checkChecksum(code) {
      return !!code;
    }
  }, {
    key: "_decode",
    value: function _decode(row, start) {
      var result = get_default()(getPrototypeOf_default()(Code32Reader.prototype), "_decode", this).call(this, row, start);

      if (!result) {
        return null;
      }

      var code = result.code;

      if (!code) {
        return null;
      }

      code = code.replace(code_32_reader_patterns.AEIO, '');

      if (!code.match(code_32_reader_patterns.AZ09)) {
        if (true) {
          console.log('Failed AZ09 pattern code:', code);
        }

        return null;
      }

      if (!this._checkChecksum(code)) {
        return null;
      }

      var new_code = 0;
      var code_final;

      var _loop = function _loop(i) {
        var char_code = code.charAt(i);
        var search_digit_code = plaintextcode.find(function (e) {
          return e.character_code === char_code;
        });

        if (typeof search_digit_code !== 'undefined') {
          var digit_code = search_digit_code.digit_code;
          var exponent_number = code.length - i - 1;
          digit_code = digit_code * Math.pow(32, exponent_number);
          new_code += digit_code;
        }
      };

      for (var i = 0; i <= code.length; i++) {
        _loop(i);
      }

      if (new_code.toString().length < 9) {
        var code_diff_length = 9 - new_code.toString().length;

        for (var n = 0; n < code_diff_length; n++) {
          code_final = "0" + new_code;
        }
      }

      code_final = "A" + new_code;
      result.code = code_final;
      return result;
    }
  }]);

  return Code32Reader;
}(code_39_reader);

/* harmony default export */ var code_32_reader = (code_32_reader_Code32Reader);
// CONCATENATED MODULE: ./src/decoder/barcode_decoder.js

















var READERS = {
  code_128_reader: code_128_reader,
  ean_reader: ean_reader,
  ean_5_reader: ean_5_reader,
  ean_2_reader: ean_2_reader,
  ean_8_reader: ean_8_reader,
  code_39_reader: code_39_reader,
  code_39_vin_reader: code_39_vin_reader,
  codabar_reader: codabar_reader,
  upc_reader: upc_reader,
  upc_e_reader: upc_e_reader,
  i2of5_reader: i2of5_reader,
  '2of5_reader': _2of5_reader,
  code_93_reader: code_93_reader,
  code_32_reader: code_32_reader
};
/* harmony default export */ var barcode_decoder = ({
  registerReader: function registerReader(name, reader) {
    READERS[name] = reader;
  },
  create: function create(config, inputImageWrapper) {
    var _canvas = {
      ctx: {
        frequency: null,
        pattern: null,
        overlay: null
      },
      dom: {
        frequency: null,
        pattern: null,
        overlay: null
      }
    };
    var _barcodeReaders = [];
    initCanvas();
    initReaders();
    initConfig();

    function initCanvas() {
      if ( true && typeof document !== 'undefined') {
        var $debug = document.querySelector('#debug.detection');
        _canvas.dom.frequency = document.querySelector('canvas.frequency');

        if (!_canvas.dom.frequency) {
          _canvas.dom.frequency = document.createElement('canvas');
          _canvas.dom.frequency.className = 'frequency';

          if ($debug) {
            $debug.appendChild(_canvas.dom.frequency);
          }
        }

        _canvas.ctx.frequency = _canvas.dom.frequency.getContext('2d');
        _canvas.dom.pattern = document.querySelector('canvas.patternBuffer');

        if (!_canvas.dom.pattern) {
          _canvas.dom.pattern = document.createElement('canvas');
          _canvas.dom.pattern.className = 'patternBuffer';

          if ($debug) {
            $debug.appendChild(_canvas.dom.pattern);
          }
        }

        _canvas.ctx.pattern = _canvas.dom.pattern.getContext('2d');
        _canvas.dom.overlay = document.querySelector('canvas.drawingBuffer');

        if (_canvas.dom.overlay) {
          _canvas.ctx.overlay = _canvas.dom.overlay.getContext('2d');
        }
      }
    }

    function initReaders() {
      config.readers.forEach(function (readerConfig) {
        var reader;
        var configuration = {};
        var supplements = [];

        if (typeof_default()(readerConfig) === 'object') {
          reader = readerConfig.format;
          configuration = readerConfig.config;
        } else if (typeof readerConfig === 'string') {
          reader = readerConfig;
        }

        if (true) {
          console.log('Before registering reader: ', reader);
        }

        if (configuration.supplements) {
          supplements = configuration.supplements.map(function (supplement) {
            return new READERS[supplement]();
          });
        }

        try {
          var readerObj = new READERS[reader](configuration, supplements);

          _barcodeReaders.push(readerObj);
        } catch (err) {
          console.error('* Error constructing reader ', reader, err);
          throw err;
        }
      });

      if (true) {
        console.log("Registered Readers: ".concat(_barcodeReaders.map(function (reader) {
          return JSON.stringify({
            format: reader.FORMAT,
            config: reader.config
          });
        }).join(', ')));
      }
    }

    function initConfig() {
      if ( true && typeof document !== 'undefined') {
        var i;
        var vis = [{
          node: _canvas.dom.frequency,
          prop: config.debug.showFrequency
        }, {
          node: _canvas.dom.pattern,
          prop: config.debug.showPattern
        }];

        for (i = 0; i < vis.length; i++) {
          if (vis[i].prop === true) {
            vis[i].node.style.display = 'block';
          } else {
            vis[i].node.style.display = 'none';
          }
        }
      }
    }
    /**
     * extend the line on both ends
     * @param {Array} line
     * @param {Number} angle
     */


    function getExtendedLine(line, angle, ext) {
      function extendLine(amount) {
        var extension = {
          y: amount * Math.sin(angle),
          x: amount * Math.cos(angle)
        };
        /* eslint-disable no-param-reassign */

        line[0].y -= extension.y;
        line[0].x -= extension.x;
        line[1].y += extension.y;
        line[1].x += extension.x;
        /* eslint-enable no-param-reassign */
      } // check if inside image


      extendLine(ext);

      while (ext > 1 && (!inputImageWrapper.inImageWithBorder(line[0]) || !inputImageWrapper.inImageWithBorder(line[1]))) {
        // eslint-disable-next-line no-param-reassign
        ext -= Math.ceil(ext / 2);
        extendLine(-ext);
      }

      return line;
    }

    function getLine(box) {
      return [{
        x: (box[1][0] - box[0][0]) / 2 + box[0][0],
        y: (box[1][1] - box[0][1]) / 2 + box[0][1]
      }, {
        x: (box[3][0] - box[2][0]) / 2 + box[2][0],
        y: (box[3][1] - box[2][1]) / 2 + box[2][1]
      }];
    }

    function tryDecode(line) {
      var result = null;
      var i;
      var barcodeLine = bresenham.getBarcodeLine(inputImageWrapper, line[0], line[1]);

      if ( true && config.debug.showFrequency) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, _canvas.ctx.overlay, {
          color: 'red',
          lineWidth: 3
        });
        bresenham.debug.printFrequency(barcodeLine.line, _canvas.dom.frequency);
      }

      bresenham.toBinaryLine(barcodeLine);

      if ( true && config.debug.showPattern) {
        bresenham.debug.printPattern(barcodeLine.line, _canvas.dom.pattern);
      }

      for (i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodePattern(barcodeLine.line);
      }

      if (result === null) {
        return null;
      }

      return {
        codeResult: result,
        barcodeLine: barcodeLine
      };
    }
    /**
     * This method slices the given area apart and tries to detect a barcode-pattern
     * for each slice. It returns the decoded barcode, or null if nothing was found
     * @param {Array} box
     * @param {Array} line
     * @param {Number} lineAngle
     */


    function tryDecodeBruteForce(box, line, lineAngle) {
      var sideLength = Math.sqrt(Math.pow(box[1][0] - box[0][0], 2) + Math.pow(box[1][1] - box[0][1], 2));
      var i;
      var slices = 16;
      var result = null;
      var dir;
      var extension;
      var xdir = Math.sin(lineAngle);
      var ydir = Math.cos(lineAngle);

      for (i = 1; i < slices && result === null; i++) {
        // move line perpendicular to angle
        // eslint-disable-next-line no-mixed-operators
        dir = sideLength / slices * i * (i % 2 === 0 ? -1 : 1);
        extension = {
          y: dir * xdir,
          x: dir * ydir
        };
        /* eslint-disable no-param-reassign */

        line[0].y += extension.x;
        line[0].x -= extension.y;
        line[1].y += extension.x;
        line[1].x -= extension.y;
        /* eslint-enable no-param-reassign */

        result = tryDecode(line);
      }

      return result;
    }

    function getLineLength(line) {
      return Math.sqrt(Math.pow(Math.abs(line[1].y - line[0].y), 2) + Math.pow(Math.abs(line[1].x - line[0].x), 2));
    }

    function _decodeFromImage(imageWrapper) {
      var result = null;

      for (var i = 0; i < _barcodeReaders.length && result === null; i++) {
        result = _barcodeReaders[i].decodeImage ? _barcodeReaders[i].decodeImage(imageWrapper) : null;
      }

      return result;
    }
    /**
     * With the help of the configured readers (Code128 or EAN) this function tries to detect a
     * valid barcode pattern within the given area.
     * @param {Object} box The area to search in
     * @returns {Object} the result {codeResult, line, angle, pattern, threshold}
     */


    function _decodeFromBoundingBox(box) {
      var line;
      var ctx = _canvas.ctx.overlay;
      var result;

      if (true) {
        if (config.debug.drawBoundingBox && ctx) {
          image_debug["a" /* default */].drawPath(box, {
            x: 0,
            y: 1
          }, ctx, {
            color: 'blue',
            lineWidth: 2
          });
        }
      }

      line = getLine(box);
      var lineLength = getLineLength(line);
      var lineAngle = Math.atan2(line[1].y - line[0].y, line[1].x - line[0].x);
      line = getExtendedLine(line, lineAngle, Math.floor(lineLength * 0.1));

      if (line === null) {
        return null;
      }

      result = tryDecode(line);

      if (result === null) {
        result = tryDecodeBruteForce(box, line, lineAngle);
      }

      if (result === null) {
        return null;
      }

      if ( true && result && config.debug.drawScanline && ctx) {
        image_debug["a" /* default */].drawPath(line, {
          x: 'x',
          y: 'y'
        }, ctx, {
          color: 'red',
          lineWidth: 3
        });
      }

      return {
        codeResult: result.codeResult,
        line: line,
        angle: lineAngle,
        pattern: result.barcodeLine.line,
        threshold: result.barcodeLine.threshold
      };
    }

    return {
      decodeFromBoundingBox: function decodeFromBoundingBox(box) {
        return _decodeFromBoundingBox(box);
      },
      decodeFromBoundingBoxes: function decodeFromBoundingBoxes(boxes) {
        var i;
        var result;
        var barcodes = [];
        var multiple = config.multiple;

        for (i = 0; i < boxes.length; i++) {
          var box = boxes[i];
          result = _decodeFromBoundingBox(box) || {};
          result.box = box;

          if (multiple) {
            barcodes.push(result);
          } else if (result.codeResult) {
            return result;
          }
        }

        if (multiple) {
          return {
            barcodes: barcodes
          };
        }
      },
      decodeFromImage: function decodeFromImage(inputImageWrapper) {
        var result = _decodeFromImage(inputImageWrapper);

        return result;
      },
      registerReader: function registerReader(name, reader) {
        if (READERS[name]) {
          throw new Error('cannot register existing reader', name);
        }

        READERS[name] = reader;
      },
      setReaders: function setReaders(readers) {
        // eslint-disable-next-line no-param-reassign
        config.readers = readers;
        _barcodeReaders.length = 0;
        initReaders();
      }
    };
  }
});
// CONCATENATED MODULE: ./src/common/events.ts
/* harmony default export */ var events = ((function EventInterface() {
  var events = {};

  function getEvent(eventName) {
    if (!events[eventName]) {
      events[eventName] = {
        subscribers: []
      };
    }

    return events[eventName];
  }

  function clearEvents() {
    events = {};
  }

  function publishSubscription(subscription, data) {
    if (subscription.async) {
      setTimeout(function () {
        subscription.callback(data);
      }, 4);
    } else {
      subscription.callback(data);
    }
  }

  function _subscribe(event, callback, async) {
    var subscription;

    if (typeof callback === 'function') {
      subscription = {
        callback: callback,
        async: async
      };
    } else {
      subscription = callback;

      if (!subscription.callback) {
        throw new Error('Callback was not specified on options');
      }
    }

    getEvent(event).subscribers.push(subscription);
  }

  return {
    subscribe: function subscribe(event, callback, async) {
      return _subscribe(event, callback, async);
    },
    publish: function publish(eventName, data) {
      var event = getEvent(eventName);
      var subscribers = event.subscribers; // Publish one-time subscriptions

      subscribers.filter(function (subscriber) {
        return !!subscriber.once;
      }).forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      }); // remove them from the subscriber

      event.subscribers = subscribers.filter(function (subscriber) {
        return !subscriber.once;
      }); // publish the rest

      event.subscribers.forEach(function (subscriber) {
        publishSubscription(subscriber, data);
      });
    },
    once: function once(event, callback) {
      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      _subscribe(event, {
        callback: callback,
        async: async,
        once: true
      });
    },
    unsubscribe: function unsubscribe(eventName, callback) {
      if (eventName) {
        var _event = getEvent(eventName);

        if (_event && callback) {
          _event.subscribers = _event.subscribers.filter(function (subscriber) {
            return subscriber.callback !== callback;
          });
        } else {
          _event.subscribers = [];
        }
      } else {
        clearEvents();
      }
    }
  };
})());
// EXTERNAL MODULE: ./node_modules/@babel/runtime/regenerator/index.js
var regenerator = __webpack_require__(17);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator);

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js
var asyncToGenerator = __webpack_require__(27);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);

// CONCATENATED MODULE: ./src/common/mediaDevices.ts
function enumerateDevices() {
  try {
    return navigator.mediaDevices.enumerateDevices();
  } catch (err) {
    return Promise.reject(new Error('enumerateDevices is not defined'));
  }
}
function getUserMedia(constraints) {
  try {
    return navigator.mediaDevices.getUserMedia(constraints);
  } catch (err) {
    return Promise.reject(new Error('getUserMedia is not defined'));
  }
}
// CONCATENATED MODULE: ./src/input/camera_access.ts




var streamRef;

function waitForVideo(video) {
  return new Promise(function (resolve, reject) {
    var attempts = 10;

    function checkVideo() {
      if (attempts > 0) {
        if (video.videoWidth > 10 && video.videoHeight > 10) {
          if (true) {
            console.log("* dev: checkVideo found ".concat(video.videoWidth, "px x ").concat(video.videoHeight, "px"));
          }

          resolve();
        } else {
          window.setTimeout(checkVideo, 500);
        }
      } else {
        reject(new Error('Unable to play video stream. Is webcam working?'));
      }

      attempts--;
    }

    checkVideo();
  });
}
/**
 * Tries to attach the camera-stream to a given video-element
 * and calls the callback function when the content is ready
 * @param {Object} constraints
 * @param {Object} video
 */


function initCamera(_x, _x2) {
  return _initCamera.apply(this, arguments);
}

function _initCamera() {
  _initCamera = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(video, constraints) {
    var stream;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return getUserMedia(constraints);

          case 2:
            stream = _context2.sent;
            streamRef = stream;
            video.setAttribute('autoplay', 'true');
            video.setAttribute('muted', 'true');
            video.setAttribute('playsinline', 'true'); // not listed on MDN...
            // eslint-disable-next-line no-param-reassign

            video.srcObject = stream;
            video.addEventListener('loadedmetadata', function () {
              video.play();
            });
            return _context2.abrupt("return", waitForVideo(video));

          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _initCamera.apply(this, arguments);
}

function deprecatedConstraints(videoConstraints) {
  var normalized = Object(lodash["pick"])(videoConstraints, ['width', 'height', 'facingMode', 'aspectRatio', 'deviceId']);

  if (typeof videoConstraints.minAspectRatio !== 'undefined' && videoConstraints.minAspectRatio > 0) {
    normalized.aspectRatio = videoConstraints.minAspectRatio;
    console.log('WARNING: Constraint \'minAspectRatio\' is deprecated; Use \'aspectRatio\' instead');
  }

  if (typeof videoConstraints.facing !== 'undefined') {
    normalized.facingMode = videoConstraints.facing;
    console.log('WARNING: Constraint \'facing\' is deprecated. Use \'facingMode\' instead\'');
  }

  return normalized;
} // TODO: #192 I don't think there's any good reason pickConstraints should return a Promise,
// I think it was just that way so it could be chained to other functions that did return a Promise.
// That's not necessary with async functions being a thing, so that should be fixed.


function pickConstraints() {
  var videoConstraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var video = deprecatedConstraints(videoConstraints);

  if (video && video.deviceId && video.facingMode) {
    delete video.facingMode;
  }

  return Promise.resolve({
    audio: false,
    video: video
  });
}

function enumerateVideoDevices() {
  return _enumerateVideoDevices.apply(this, arguments);
}

function _enumerateVideoDevices() {
  _enumerateVideoDevices = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
    var devices;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return enumerateDevices();

          case 2:
            devices = _context3.sent;
            return _context3.abrupt("return", devices.filter(function (device) {
              return device.kind === 'videoinput';
            }));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _enumerateVideoDevices.apply(this, arguments);
}

function getActiveTrack() {
  if (!streamRef) {
    return null;
  }

  var tracks = streamRef.getVideoTracks();
  return tracks && (tracks === null || tracks === void 0 ? void 0 : tracks.length) ? tracks[0] : null;
}
/**
 * Used for accessing information about the active stream track and available video devices.
 */


var QuaggaJSCameraAccess = {
  request: function request(video, videoConstraints) {
    return asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
      var newConstraints;
      return regenerator_default.a.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return pickConstraints(videoConstraints);

            case 2:
              newConstraints = _context.sent;
              return _context.abrupt("return", initCamera(video, newConstraints));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  release: function release() {
    // TODO: i wonder if telling the Video element to pause() before calling MediaStreamTrack.stop() would alleviate some of the issues with the camera appearing to stay open on Android even after stopping.
    var tracks = streamRef && streamRef.getVideoTracks();

    if (tracks && tracks.length) {
      tracks[0].stop();
    }

    streamRef = null;
  },
  enumerateVideoDevices: enumerateVideoDevices,
  getActiveStreamLabel: function getActiveStreamLabel() {
    var track = getActiveTrack();
    return track ? track.label : '';
  },
  getActiveTrack: getActiveTrack
};
/* harmony default export */ var camera_access = (QuaggaJSCameraAccess);
// CONCATENATED MODULE: ./src/analytics/result_collector.ts


function contains(codeResult, list) {
  return list && list.some(function (item) {
    var keys = Object.keys(item);
    return keys.every(function (key) {
      return item[key] === codeResult[key];
    });
  });
}

function passesFilter(codeResult, filter) {
  return typeof filter === 'function' ? filter(codeResult) : true;
}

/* harmony default export */ var result_collector = ({
  create: function create(config) {
    var _config$capacity;

    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var results = [];
    var capacity = (_config$capacity = config.capacity) !== null && _config$capacity !== void 0 ? _config$capacity : 20;
    var capture = config.capture === true;

    function matchesConstraints(codeResult) {
      return !!capacity && codeResult && !contains(codeResult, config.blacklist) && passesFilter(codeResult, config.filter);
    }

    return {
      addResult: function addResult(data, imageSize, codeResult) {
        var result = {}; // this is 'any' to avoid having to construct a whole QuaggaJSCodeResult :|

        if (matchesConstraints(codeResult)) {
          capacity--;
          result.codeResult = codeResult;

          if (capture) {
            canvas.width = imageSize.x;
            canvas.height = imageSize.y;
            image_debug["a" /* default */].drawImage(data, imageSize, ctx);
            result.frame = canvas.toDataURL();
          }

          results.push(result);
        }
      },
      getResults: function getResults() {
        return results;
      }
    };
  }
});
// CONCATENATED MODULE: ./src/config/config.dev.ts
var DevConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader'],
    debug: {
      drawBoundingBox: false,
      showFrequency: false,
      drawScanline: false,
      showPattern: false
    }
  },
  locator: {
    halfSample: true,
    patchSize: 'medium',
    // x-small, small, medium, large, x-large
    debug: {
      showCanvas: false,
      showPatches: false,
      showFoundPatches: false,
      showSkeleton: false,
      showLabels: false,
      showPatchLabels: false,
      showRemainingPatchLabels: false,
      boxFromPatches: {
        showTransformed: false,
        showTransformedBox: false,
        showBB: false
      }
    }
  }
};
/* harmony default export */ var config_dev = (DevConfig);
// CONCATENATED MODULE: ./src/config/config.node.ts
var NodeConfig = {
  inputStream: {
    type: 'ImageStream',
    sequence: false,
    size: 800,
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 0,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_node = (NodeConfig);
// CONCATENATED MODULE: ./src/config/config.prod.ts
var ProdConfig = {
  inputStream: {
    name: 'Live',
    type: 'LiveStream',
    constraints: {
      width: 640,
      height: 480,
      // aspectRatio: 640/480, // optional
      facingMode: 'environment' // or user
      // deviceId: "38745983457387598375983759834"

    },
    area: {
      top: '0%',
      right: '0%',
      left: '0%',
      bottom: '0%'
    },
    singleChannel: false // true: only the red color-channel is read

  },
  locate: true,
  numOfWorkers: 4,
  decoder: {
    readers: ['code_128_reader']
  },
  locator: {
    halfSample: true,
    patchSize: 'medium' // x-small, small, medium, large, x-large

  }
};
/* harmony default export */ var config_prod = (ProdConfig);
// CONCATENATED MODULE: ./src/config/config.ts


 // @ts-ignore // TODO: this produces a bizarre typescript error
// eslint-disable-next-line no-nested-ternary

var QuaggaConfig =  true ? config_dev : undefined;
/* harmony default export */ var config_config = (QuaggaConfig);
// EXTERNAL MODULE: ./node_modules/gl-vec2/index.js
var gl_vec2 = __webpack_require__(7);

// CONCATENATED MODULE: ./src/QuaggaContext.ts


var QuaggaContext_QuaggaContext = function QuaggaContext() {
  classCallCheck_default()(this, QuaggaContext);

  defineProperty_default()(this, "config", void 0);

  defineProperty_default()(this, "inputStream", void 0);

  defineProperty_default()(this, "framegrabber", void 0);

  defineProperty_default()(this, "inputImageWrapper", void 0);

  defineProperty_default()(this, "stopped", false);

  defineProperty_default()(this, "boxSize", void 0);

  defineProperty_default()(this, "resultCollector", void 0);

  defineProperty_default()(this, "decoder", void 0);

  defineProperty_default()(this, "workerPool", []);

  defineProperty_default()(this, "onUIThread", true);

  defineProperty_default()(this, "canvasContainer", new QuaggaContext_CanvasContainer());
};
var QuaggaContext_CanvasInfo = function CanvasInfo() {
  classCallCheck_default()(this, CanvasInfo);

  defineProperty_default()(this, "image", void 0);

  defineProperty_default()(this, "overlay", void 0);
};
var QuaggaContext_CanvasContainer = function CanvasContainer() {
  classCallCheck_default()(this, CanvasContainer);

  defineProperty_default()(this, "ctx", void 0);

  defineProperty_default()(this, "dom", void 0);

  this.ctx = new QuaggaContext_CanvasInfo();
  this.dom = new QuaggaContext_CanvasInfo();
};
// EXTERNAL MODULE: ./src/locator/barcode_locator.js
var barcode_locator = __webpack_require__(23);

// CONCATENATED MODULE: ./src/quagga/initBuffers.ts



// TODO: need typescript def for BarcodeLocator
function initBuffers_initBuffers(inputStream, imageWrapper, locator) {
  var inputImageWrapper = imageWrapper || new image_wrapper["a" /* default */]({
    x: inputStream.getWidth(),
    y: inputStream.getHeight(),
    type: 'XYSize'
  });

  if (true) {
    console.log("image wrapper size ".concat(inputImageWrapper.size));
  }

  var boxSize = [Object(gl_vec2["clone"])([0, 0]), Object(gl_vec2["clone"])([0, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, inputImageWrapper.size.y]), Object(gl_vec2["clone"])([inputImageWrapper.size.x, 0])];
  barcode_locator["a" /* default */].init(inputImageWrapper, locator);
  return {
    inputImageWrapper: inputImageWrapper,
    boxSize: boxSize
  };
}
// CONCATENATED MODULE: ./src/quagga/getViewPort.ts
function getViewPort_getViewPort(target) {
  if (typeof document === 'undefined') {
    return null;
  } // Check if target is already a DOM element


  if (target instanceof HTMLElement && target.nodeName && target.nodeType === 1) {
    return target;
  } // Use '#interactive.viewport' as a fallback selector (backwards compatibility)


  var selector = typeof target === 'string' ? target : '#interactive.viewport';
  return document.querySelector(selector);
}
// CONCATENATED MODULE: ./src/quagga/initCanvas.ts


function findOrCreateCanvas(selector, className) {
  var canvas = document.querySelector(selector);

  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.className = className;
  }

  return canvas;
}

function getCanvasAndContext(selector, className) {
  var canvas = findOrCreateCanvas(selector, className);
  var context = canvas.getContext('2d');
  return {
    canvas: canvas,
    context: context
  };
}

function initCanvases(canvasSize) {
  if (typeof document !== 'undefined') {
    var image = getCanvasAndContext('canvas.imgBuffer', 'imgBuffer');
    var overlay = getCanvasAndContext('canvas.drawingBuffer', 'drawingBuffer');
    image.canvas.width = overlay.canvas.width = canvasSize.x;
    image.canvas.height = overlay.canvas.height = canvasSize.y;
    return {
      dom: {
        image: image.canvas,
        overlay: overlay.canvas
      },
      ctx: {
        image: image.context,
        overlay: overlay.context
      }
    };
  }

  return null;
}

function initCanvas_initCanvas(context) {
  var _context$config, _context$config$input, _context$config2, _context$config2$inpu;

  var viewport = getViewPort_getViewPort(context === null || context === void 0 ? void 0 : (_context$config = context.config) === null || _context$config === void 0 ? void 0 : (_context$config$input = _context$config.inputStream) === null || _context$config$input === void 0 ? void 0 : _context$config$input.target);
  var type = context === null || context === void 0 ? void 0 : (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : (_context$config2$inpu = _context$config2.inputStream) === null || _context$config2$inpu === void 0 ? void 0 : _context$config2$inpu.type;
  if (!type) return null;
  var container = initCanvases(context.inputStream.getCanvasSize());
  if (!container) return {
    dom: {
      image: null,
      overlay: null
    },
    ctx: {
      image: null,
      overlay: null
    }
  };
  var dom = container.dom;

  if (typeof document !== 'undefined') {
    if (viewport) {
      if (type === 'ImageStream' && !viewport.contains(dom.image)) {
        viewport.appendChild(dom.image);
      }

      if (!viewport.contains(dom.overlay)) {
        viewport.appendChild(dom.overlay);
      }
    }
  }

  return container;
}
// CONCATENATED MODULE: ./src/input/exif_helper.js
// NOTE: (SOME OF) THIS IS BROWSER ONLY CODE.  Node does not have 'atob' built in, nor XMLHttpRequest.
// How exactly is this set of functions used in Quagga? Do we need the browser specific code? Do we
// need to port any part of this that doesn't work in Node to node?
// Tags scraped from https://github.com/exif-js/exif-js
var ExifTags = {
  0x0112: 'orientation'
};
var AvailableTags = Object.keys(ExifTags).map(function (key) {
  return ExifTags[key];
});
function findTagsInObjectURL(src) {
  var tags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;

  if (/^blob:/i.test(src)) {
    return objectURLToBlob(src).then(readToBuffer).then(function (buffer) {
      return findTagsInBuffer(buffer, tags);
    });
  }

  return Promise.resolve(null);
}
function base64ToArrayBuffer(dataUrl) {
  var base64 = dataUrl.replace(/^data:([^;]+);base64,/gmi, '');
  var binary = atob(base64);
  var len = binary.length;
  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);

  for (var i = 0; i < len; i++) {
    view[i] = binary.charCodeAt(i);
  }

  return buffer;
}

function readToBuffer(blob) {
  return new Promise(function (resolve) {
    var fileReader = new FileReader();

    fileReader.onload = function (e) {
      return resolve(e.target.result);
    };

    fileReader.readAsArrayBuffer(blob);
  });
}

function objectURLToBlob(url) {
  return new Promise(function (resolve, reject) {
    var http = new XMLHttpRequest();
    http.open('GET', url, true);
    http.responseType = 'blob';

    http.onreadystatechange = function () {
      if (http.readyState === XMLHttpRequest.DONE && (http.status === 200 || http.status === 0)) {
        resolve(this.response);
      }
    };

    http.onerror = reject;
    http.send();
  });
}

function findTagsInBuffer(file) {
  var selectedTags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AvailableTags;
  var dataView = new DataView(file);
  var length = file.byteLength;
  var exifTags = selectedTags.reduce(function (result, selectedTag) {
    var exifTag = Object.keys(ExifTags).filter(function (tag) {
      return ExifTags[tag] === selectedTag;
    })[0];

    if (exifTag) {
      result[exifTag] = selectedTag;
    }

    return result;
  }, {});
  var offset = 2;
  var marker;

  if (dataView.getUint8(0) !== 0xFF || dataView.getUint8(1) !== 0xD8) {
    return false;
  }

  while (offset < length) {
    if (dataView.getUint8(offset) !== 0xFF) {
      return false;
    }

    marker = dataView.getUint8(offset + 1);

    if (marker === 0xE1) {
      return readEXIFData(dataView, offset + 4, exifTags);
    }

    offset += 2 + dataView.getUint16(offset + 2);
  }

  return false;
}

function readEXIFData(file, start, exifTags) {
  if (getStringFromBuffer(file, start, 4) !== 'Exif') {
    return false;
  }

  var tiffOffset = start + 6;
  var bigEnd;

  if (file.getUint16(tiffOffset) === 0x4949) {
    bigEnd = false;
  } else if (file.getUint16(tiffOffset) === 0x4D4D) {
    bigEnd = true;
  } else {
    return false;
  }

  if (file.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
    return false;
  }

  var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);

  if (firstIFDOffset < 0x00000008) {
    return false;
  }

  var tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, exifTags, bigEnd);
  return tags;
}

function readTags(file, tiffStart, dirStart, strings, bigEnd) {
  var entries = file.getUint16(dirStart, !bigEnd);
  var tags = {};

  for (var i = 0; i < entries; i++) {
    var entryOffset = dirStart + i * 12 + 2;
    var tag = strings[file.getUint16(entryOffset, !bigEnd)];

    if (tag) {
      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);
    }
  }

  return tags;
}

function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {
  var type = file.getUint16(entryOffset + 2, !bigEnd);
  var numValues = file.getUint32(entryOffset + 4, !bigEnd);

  switch (type) {
    case 3:
      if (numValues === 1) {
        return file.getUint16(entryOffset + 8, !bigEnd);
      }

  }

  return null;
}

function getStringFromBuffer(buffer, start, length) {
  var outstr = '';

  for (var n = start; n < start + length; n++) {
    outstr += String.fromCharCode(buffer.getUint8(n));
  }

  return outstr;
}
// CONCATENATED MODULE: ./src/input/image_loader.js

var ImageLoader = {};

ImageLoader.load = function (directory, callback, offset, size, sequence) {
  var htmlImagesSrcArray = new Array(size);
  var htmlImagesArray = new Array(htmlImagesSrcArray.length);
  var i;
  var img;
  var num;

  if (sequence === false) {
    htmlImagesSrcArray[0] = directory;
  } else {
    for (i = 0; i < htmlImagesSrcArray.length; i++) {
      num = offset + i;
      htmlImagesSrcArray[i] = "".concat(directory, "image-").concat("00".concat(num).slice(-3), ".jpg");
    }
  }

  htmlImagesArray.notLoaded = [];

  htmlImagesArray.addImage = function (image) {
    htmlImagesArray.notLoaded.push(image);
  };

  htmlImagesArray.loaded = function (loadedImg) {
    var notloadedImgs = htmlImagesArray.notLoaded;

    for (var x = 0; x < notloadedImgs.length; x++) {
      if (notloadedImgs[x] === loadedImg) {
        notloadedImgs.splice(x, 1);

        for (var y = 0; y < htmlImagesSrcArray.length; y++) {
          var imgName = htmlImagesSrcArray[y].substr(htmlImagesSrcArray[y].lastIndexOf('/'));

          if (loadedImg.src.lastIndexOf(imgName) !== -1) {
            htmlImagesArray[y] = {
              img: loadedImg
            };
            break;
          }
        }

        break;
      }
    }

    if (notloadedImgs.length === 0) {
      if (true) {
        console.log('Images loaded');
      }

      if (sequence === false) {
        findTagsInObjectURL(directory, ['orientation']).then(function (tags) {
          htmlImagesArray[0].tags = tags;
          callback(htmlImagesArray);
        })["catch"](function (e) {
          console.log(e);
          callback(htmlImagesArray);
        });
      } else {
        callback(htmlImagesArray);
      }
    }
  };

  for (i = 0; i < htmlImagesSrcArray.length; i++) {
    img = new Image();
    htmlImagesArray.addImage(img);
    addOnloadHandler(img, htmlImagesArray);
    img.src = htmlImagesSrcArray[i];
  }
};

function addOnloadHandler(img, htmlImagesArray) {
  img.onload = function () {
    htmlImagesArray.loaded(this);
  };
}

/* harmony default export */ var image_loader = (ImageLoader);
// CONCATENATED MODULE: ./src/input/input_stream/input_stream_browser.ts
/* eslint-disable @typescript-eslint/no-explicit-any */

var inputStreamFactory = {
  createVideoStream: function createVideoStream(video) {
    var _config = null;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};

    var _calculatedWidth;

    var _calculatedHeight;

    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function initSize() {
      var _config2, _config3;

      var width = video.videoWidth;
      var height = video.videoHeight; // eslint-disable-next-line no-nested-ternary

      _calculatedWidth = ((_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

      _calculatedHeight = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
      _canvasSize.x = _calculatedWidth;
      _canvasSize.y = _calculatedHeight;
    }

    var inputStream = {
      getRealWidth: function getRealWidth() {
        return video.videoWidth;
      },
      getRealHeight: function getRealHeight() {
        return video.videoHeight;
      },
      getWidth: function getWidth() {
        return _calculatedWidth;
      },
      getHeight: function getHeight() {
        return _calculatedHeight;
      },
      setWidth: function setWidth(width) {
        _calculatedWidth = width;
      },
      setHeight: function setHeight(height) {
        _calculatedHeight = height;
      },
      setInputStream: function setInputStream(config) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = config; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        this.setAttribute('src', typeof config.src !== 'undefined' ? config.src : '');
      },
      ended: function ended() {
        return video.ended;
      },
      getConfig: function getConfig() {
        return _config;
      },
      setAttribute: function setAttribute(name, value) {
        if (video) {
          video.setAttribute(name, value);
        }
      },
      pause: function pause() {
        video.pause();
      },
      play: function play() {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        video.play();
      },
      setCurrentTime: function setCurrentTime(time) {
        var _config4;

        if (((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.type) !== 'LiveStream') {
          this.setAttribute('currentTime', time.toString());
        }
      },
      addEventListener: function addEventListener(event, f, bool) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        } else {
          video.addEventListener(event, f, bool);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        _eventNames.forEach(function (eventName) {
          var handlers = _eventHandlers[eventName];

          if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
              video.removeEventListener(eventName, handler);
            });
          }
        });
      },
      trigger: function trigger(eventName, args) {
        var j; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        var handlers = _eventHandlers[eventName];

        if (eventName === 'canrecord') {
          initSize();
        }

        if (handlers && handlers.length > 0) {
          for (j = 0; j < handlers.length; j++) {
            handlers[j].apply(inputStream, args);
          }
        }
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(size) {
        _canvasSize.x = size.x;
        _canvasSize.y = size.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        return video;
      }
    };
    return inputStream;
  },
  createLiveStream: function createLiveStream(video) {
    if (video) {
      video.setAttribute('autoplay', 'true');
    }

    var that = inputStreamFactory.createVideoStream(video);

    that.ended = function ended() {
      return false;
    };

    return that;
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var frameIdx = 0;
    var paused = true;
    var loaded = false;
    var imgArray = null;
    var size = 0;
    var offset = 1;
    var baseUrl = null;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };

    function loadImages() {
      var _config7;

      loaded = false;
      image_loader.load(baseUrl, function (imgs) {
        var _config5, _config6;

        imgArray = imgs; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (imgs[0].tags && imgs[0].tags.orientation) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
          switch (imgs[0].tags.orientation) {
            case 6:
            case 8:
              width = imgs[0].img.height;
              height = imgs[0].img.width;
              break;

            default:
              width = imgs[0].img.width;
              height = imgs[0].img.height;
          }
        } else {
          width = imgs[0].img.width;
          height = imgs[0].img.height;
        } // eslint-disable-next-line no-nested-ternary


        calculatedWidth = ((_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config6 = _config) === null || _config6 === void 0 ? void 0 : _config6.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        loaded = true;
        frameIdx = 0;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      }, offset, size, (_config7 = _config) === null || _config7 === void 0 ? void 0 : _config7.sequence);
    }

    function publishEvent(eventName, args) {
      var j;
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args); // TODO: typescript complains that any[] is not valid for a second arg for apply?!
        }
      }
    } // TODO: any code shared with the first InputStream above should be shared not copied
    // TODO: publishEvent needs access to inputStream, but inputStream needs access to publishEvent
    // TODO: This is why it's a 'var', so it hoists back.  This is ugly, and should be changed.
    // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(newWidth) {
        calculatedWidth = newWidth;
      },
      setHeight: function setHeight(newHeight) {
        calculatedHeight = newHeight;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

        if (stream.sequence === false) {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src;
          size = 1;
        } else {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access
          baseUrl = stream.src; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

          size = stream.length;
        }

        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(canvasSize) {
        _canvasSize.x = canvasSize.x;
        _canvasSize.y = canvasSize.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        var frame;

        if (!loaded) {
          return null;
        }

        if (!paused) {
          var _imgArray;

          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          frame = (_imgArray = imgArray) === null || _imgArray === void 0 ? void 0 : _imgArray[frameIdx];

          if (frameIdx < size - 1) {
            frameIdx++;
          } else {
            setTimeout(function () {
              _ended = true;
              publishEvent('ended', []);
            }, 0);
          }
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_browser = (inputStreamFactory);
// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(25);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/get-pixels/dom-pixels.js
var dom_pixels = __webpack_require__(66);
var dom_pixels_default = /*#__PURE__*/__webpack_require__.n(dom_pixels);

// CONCATENATED MODULE: ./src/input/input_stream/input_stream_node.ts

// TODO: It's pretty likely that this shares code with the browser version, investigate that

var input_stream_node_inputStreamFactory = {
  createVideoStream: function createVideoStream() {
    throw new Error('createVideoStream not available');
  },
  createLiveStream: function createLiveStream() {
    throw new Error('createLiveStream not available');
  },
  createImageStream: function createImageStream() {
    var _config = null;
    var width = 0;
    var height = 0;
    var loaded = false; // TODO: frame should be a type NdArray, but NdArray doesn't have ts definitions
    // TODO: there is a ts-ndarray that might work, though

    var frame = null;
    var baseUrl;
    var _ended = false;
    var calculatedWidth;
    var calculatedHeight;
    var _eventNames = ['canrecord', 'ended'];
    var _eventHandlers = {};
    var _topRight = {
      x: 0,
      y: 0,
      type: 'Point'
    };
    var _canvasSize = {
      x: 0,
      y: 0,
      type: 'XYSize'
    };
    /* eslint-disable no-unused-vars */
    // false eslint errors? weird.
    // @ts-ignore

    var size = 0; // @ts-ignore

    var frameIdx = 0; // @ts-ignore

    var paused = false;
    /* eslint-enable no-unused-vars */

    function loadImages() {
      var _config2;

      loaded = false;
      /* eslint-disable new-cap */

      dom_pixels_default()(baseUrl, (_config2 = _config) === null || _config2 === void 0 ? void 0 : _config2.mime, function (err, pixels) {
        var _config3, _config4;

        if (err) {
          console.error('**** quagga loadImages error:', err);
          throw new Error('error decoding pixels in loadImages');
        }

        loaded = true;

        if (true) {
          console.log('* InputStreamNode pixels.shape', pixels.shape);
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment


        frame = pixels; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        var _pixels$shape = slicedToArray_default()(pixels.shape, 2);

        width = _pixels$shape[0];
        height = _pixels$shape[1];
        // eslint-disable-next-line no-nested-ternary
        calculatedWidth = ((_config3 = _config) === null || _config3 === void 0 ? void 0 : _config3.size) ? width / height > 1 ? _config.size : Math.floor(width / height * _config.size) : width; // eslint-disable-next-line no-nested-ternary

        calculatedHeight = ((_config4 = _config) === null || _config4 === void 0 ? void 0 : _config4.size) ? width / height > 1 ? Math.floor(height / width * _config.size) : _config.size : height;
        _canvasSize.x = calculatedWidth;
        _canvasSize.y = calculatedHeight;
        setTimeout(function () {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          publishEvent('canrecord', []);
        }, 0);
      });
    }

    function publishEvent(eventName, args) {
      var handlers = _eventHandlers[eventName];

      if (handlers && handlers.length > 0) {
        for (var j = 0; j < handlers.length; j++) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          handlers[j].apply(inputStream, args);
        }
      }
    } // eslint-disable-next-line no-var,vars-on-top


    var inputStream = {
      trigger: publishEvent,
      getWidth: function getWidth() {
        return calculatedWidth;
      },
      getHeight: function getHeight() {
        return calculatedHeight;
      },
      setWidth: function setWidth(w) {
        calculatedWidth = w;
      },
      setHeight: function setHeight(h) {
        calculatedHeight = h;
      },
      getRealWidth: function getRealWidth() {
        return width;
      },
      getRealHeight: function getRealHeight() {
        return height;
      },
      setInputStream: function setInputStream(stream) {
        var _config5;

        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        _config = stream; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access

        baseUrl = (_config5 = _config) === null || _config5 === void 0 ? void 0 : _config5.src;
        size = 1;
        loadImages();
      },
      ended: function ended() {
        return _ended;
      },
      setAttribute: function setAttribute() {},
      getConfig: function getConfig() {
        return _config;
      },
      pause: function pause() {
        paused = true;
      },
      play: function play() {
        paused = false;
      },
      setCurrentTime: function setCurrentTime(time) {
        frameIdx = time;
      },
      addEventListener: function addEventListener(event, f) {
        if (_eventNames.indexOf(event) !== -1) {
          if (!_eventHandlers[event]) {
            _eventHandlers[event] = [];
          }

          _eventHandlers[event].push(f);
        }
      },
      clearEventHandlers: function clearEventHandlers() {
        Object.keys(_eventHandlers).forEach(function (ind) {
          return delete _eventHandlers[ind];
        });
      },
      setTopRight: function setTopRight(topRight) {
        _topRight.x = topRight.x;
        _topRight.y = topRight.y;
      },
      getTopRight: function getTopRight() {
        return _topRight;
      },
      setCanvasSize: function setCanvasSize(sz) {
        _canvasSize.x = sz.x;
        _canvasSize.y = sz.y;
      },
      getCanvasSize: function getCanvasSize() {
        return _canvasSize;
      },
      getFrame: function getFrame() {
        if (!loaded) {
          return null;
        } // eslint-disable-next-line @typescript-eslint/no-unsafe-return


        return frame;
      }
    };
    return inputStream;
  }
};
/* harmony default export */ var input_stream_node = (input_stream_node_inputStreamFactory);
// CONCATENATED MODULE: ./src/input/input_stream_factory.ts


/* harmony default export */ var input_stream_factory = (input_stream_browser);

// EXTERNAL MODULE: ./src/input/frame_grabber_node.js
var frame_grabber_node = __webpack_require__(62);
var frame_grabber_node_default = /*#__PURE__*/__webpack_require__.n(frame_grabber_node);

// EXTERNAL MODULE: ./src/common/cv_utils.js + 1 modules
var cv_utils = __webpack_require__(8);

// CONCATENATED MODULE: ./src/input/frame_grabber.js


var TO_RADIANS = Math.PI / 180;

function adjustCanvasSize(canvas, targetSize) {
  if (canvas.width !== targetSize.x) {
    if (true) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.width = targetSize.x;
  }

  if (canvas.height !== targetSize.y) {
    if (true) {
      console.log('WARNING: canvas-size needs to be adjusted');
    }

    canvas.height = targetSize.y;
  }
}

var FrameGrabber = {};

FrameGrabber.create = function (inputStream, canvas) {
  var _that = {};

  var _streamConfig = inputStream.getConfig();

  var _videoSize = Object(cv_utils["imageRef"])(inputStream.getRealWidth(), inputStream.getRealHeight());

  var _canvasSize = inputStream.getCanvasSize();

  var _size = Object(cv_utils["imageRef"])(inputStream.getWidth(), inputStream.getHeight());

  var topRight = inputStream.getTopRight();
  var _sx = topRight.x;
  var _sy = topRight.y;

  var _canvas;

  var _ctx = null;
  var _data = null;
  _canvas = canvas || document.createElement('canvas');
  _canvas.width = _canvasSize.x;
  _canvas.height = _canvasSize.y;
  _ctx = _canvas.getContext('2d');
  _data = new Uint8Array(_size.x * _size.y);

  if (true) {
    console.log('FrameGrabber', JSON.stringify({
      size: _size,
      topRight: topRight,
      videoSize: _videoSize,
      canvasSize: _canvasSize
    }));
  }
  /**
   * Uses the given array as frame-buffer
   */


  _that.attachData = function (data) {
    _data = data;
  };
  /**
   * Returns the used frame-buffer
   */


  _that.getData = function () {
    return _data;
  };
  /**
   * Fetches a frame from the input-stream and puts into the frame-buffer.
   * The image-data is converted to gray-scale and then half-sampled if configured.
   */


  _that.grab = function () {
    var doHalfSample = _streamConfig.halfSample;
    var frame = inputStream.getFrame();
    var drawable = frame;
    var drawAngle = 0;
    var ctxData;

    if (drawable) {
      adjustCanvasSize(_canvas, _canvasSize);

      if (_streamConfig.type === 'ImageStream') {
        drawable = frame.img;

        if (frame.tags && frame.tags.orientation) {
          switch (frame.tags.orientation) {
            case 6:
              drawAngle = 90 * TO_RADIANS;
              break;

            case 8:
              drawAngle = -90 * TO_RADIANS;
              break;
          }
        }
      }

      if (drawAngle !== 0) {
        _ctx.translate(_canvasSize.x / 2, _canvasSize.y / 2);

        _ctx.rotate(drawAngle);

        _ctx.drawImage(drawable, -_canvasSize.y / 2, -_canvasSize.x / 2, _canvasSize.y, _canvasSize.x);

        _ctx.rotate(-drawAngle);

        _ctx.translate(-_canvasSize.x / 2, -_canvasSize.y / 2);
      } else {
        _ctx.drawImage(drawable, 0, 0, _canvasSize.x, _canvasSize.y);
      }

      ctxData = _ctx.getImageData(_sx, _sy, _size.x, _size.y).data;

      if (doHalfSample) {
        Object(cv_utils["grayAndHalfSampleFromCanvasData"])(ctxData, _size, _data);
      } else {
        Object(cv_utils["computeGray"])(ctxData, _data, _streamConfig);
      }

      return true;
    }

    return false;
  };

  _that.getSize = function () {
    return _size;
  };

  return _that;
};

/* harmony default export */ var frame_grabber = (FrameGrabber);

// CONCATENATED MODULE: ./src/quagga/qworker.ts


function qworker_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function qworker_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { qworker_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { qworker_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/* Worker functions. These are straight from the original quagga.js file.
 * Not presently used, as worker support is non-functional.  Keeping them around temporarily
 * to refer to until it is re-implemented. We may be able to fix/use some of this.
 */
// TODO: need a typescript interface for FrameGrabber
var workerPool = [];
function updateWorkers(frameGrabber) {
  var availableWorker;

  if (workerPool.length) {
    availableWorker = workerPool.filter(function (workerThread) {
      return !workerThread.busy;
    })[0];

    if (availableWorker) {
      frameGrabber.attachData(availableWorker.imageData);

      if (frameGrabber.grab()) {
        availableWorker.busy = true;
        availableWorker.worker.postMessage({
          cmd: 'process',
          imageData: availableWorker.imageData
        }, [availableWorker.imageData.buffer]);
      }

      return true;
    } else {
      return false;
    }
  }

  return null;
}

function configForWorker(config) {
  return qworker_objectSpread(qworker_objectSpread({}, config), {}, {
    inputStream: qworker_objectSpread(qworker_objectSpread({}, config.inputStream), {}, {
      target: null
    })
  });
} // @ts-ignore


function workerInterface(factory) {
  if (factory) {
    var Quagga = factory()["default"];

    if (!Quagga) {
      // @ts-ignore
      self.postMessage({
        'event': 'error',
        message: 'Quagga could not be created'
      });
      return;
    }
  } // @ts-ignore


  var imageWrapper; // @ts-ignore

  function onProcessed(result) {
    self.postMessage({
      'event': 'processed',
      // @ts-ignore
      imageData: imageWrapper.data,
      result: result // @ts-ignore

    }, [imageWrapper.data.buffer]);
  }

  function workerInterfaceReady() {
    self.postMessage({
      'event': 'initialized',
      // @ts-ignore
      imageData: imageWrapper.data // @ts-ignore

    }, [imageWrapper.data.buffer]);
  } // @ts-ignore


  self.onmessage = function (e) {
    if (e.data.cmd === 'init') {
      var config = e.data.config;
      config.numOfWorkers = 0;
      imageWrapper = new Quagga.ImageWrapper({
        x: e.data.size.x,
        y: e.data.size.y
      }, new Uint8Array(e.data.imageData));
      Quagga.init(config, workerInterfaceReady, imageWrapper);
      Quagga.onProcessed(onProcessed);
    } else if (e.data.cmd === 'process') {
      // @ts-ignore
      imageWrapper.data = new Uint8Array(e.data.imageData);
      Quagga.start();
    } else if (e.data.cmd === 'setReaders') {
      Quagga.setReaders(e.data.readers);
    } else if (e.data.cmd === 'registerReader') {
      Quagga.registerReader(e.data.name, e.data.reader);
    }
  };
}

function generateWorkerBlob() {
  var blob, factorySource;
  /* jshint ignore:start */
  // @ts-ignore

  if (typeof __factorySource__ !== 'undefined') {
    // @ts-ignore
    factorySource = __factorySource__; // eslint-disable-line no-undef
  }
  /* jshint ignore:end */


  blob = new Blob(['(' + workerInterface.toString() + ')(' + factorySource + ');'], {
    type: 'text/javascript'
  });
  return window.URL.createObjectURL(blob);
}

function initWorker(config, inputStream, cb) {
  var blobURL = generateWorkerBlob();
  var worker = new Worker(blobURL);
  var workerThread = {
    worker: worker,
    imageData: new Uint8Array(inputStream.getWidth() * inputStream.getHeight()),
    busy: true
  };

  workerThread.worker.onmessage = function (e) {
    if (e.data.event === 'initialized') {
      URL.revokeObjectURL(blobURL);
      workerThread.busy = false;
      workerThread.imageData = new Uint8Array(e.data.imageData);

      if (true) {
        console.log('Worker initialized');
      }

      cb(workerThread);
    } else if (e.data.event === 'processed') {
      workerThread.imageData = new Uint8Array(e.data.imageData);
      workerThread.busy = false; // TODO: how to thread publishResult into here?
      // publishResult(e.data.result, workerThread.imageData);
    } else if (e.data.event === 'error') {
      if (true) {
        console.log('Worker error: ' + e.data.message);
      }
    }
  };

  workerThread.worker.postMessage({
    cmd: 'init',
    size: {
      x: inputStream.getWidth(),
      y: inputStream.getHeight()
    },
    imageData: workerThread.imageData,
    config: configForWorker(config)
  }, [workerThread.imageData.buffer]);
}
function adjustWorkerPool(capacity, config, inputStream, cb) {
  var increaseBy = capacity - workerPool.length;

  if (increaseBy === 0 && cb) {
    cb();
  } else if (increaseBy < 0) {
    var workersToTerminate = workerPool.slice(increaseBy);
    workersToTerminate.forEach(function (workerThread) {
      workerThread.worker.terminate();

      if (true) {
        console.log('Worker terminated!');
      }
    });
    workerPool = workerPool.slice(0, increaseBy);

    if (cb) {
      cb();
    }
  } else {
    var workerInitialized = function workerInitialized(workerThread) {
      workerPool.push(workerThread);

      if (workerPool.length >= capacity && cb) {
        cb();
      }
    };

    if (config) {
      for (var i = 0; i < increaseBy; i++) {
        initWorker(config, inputStream, workerInitialized);
      }
    }
  }
}
function qworker_setReaders(readers) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'setReaders',
      readers: readers
    });
  });
}
function qworker_registerReader(name, reader) {
  workerPool.forEach(function (workerThread) {
    return workerThread.worker.postMessage({
      cmd: 'registerReader',
      name: name,
      reader: reader
    });
  });
}
// CONCATENATED MODULE: ./src/quagga/setupInputStream.ts
// TODO: need to create an InputStream typescript interface, so we don't have an "any" in the next line
function setupInputStream() {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'LiveStream';
  var viewport = arguments.length > 1 ? arguments[1] : undefined;
  var InputStream = arguments.length > 2 ? arguments[2] : undefined;

  switch (type) {
    case 'VideoStream':
      {
        var video = document.createElement('video');
        return {
          video: video,
          inputStream: InputStream.createVideoStream(video)
        };
      }

    case 'ImageStream':
      return {
        inputStream: InputStream.createImageStream()
      };

    case 'LiveStream':
      {
        var _video = null;

        if (viewport) {
          _video = viewport.querySelector('video');

          if (!_video) {
            _video = document.createElement('video');
            viewport.appendChild(_video);
          }
        }

        return {
          video: _video,
          inputStream: InputStream.createLiveStream(_video)
        };
      }

    default:
      console.error("* setupInputStream invalid type ".concat(type));
      return {
        video: null,
        inputStream: null
      };
  }
}
// CONCATENATED MODULE: ./src/quagga/transform.ts
/* eslint-disable no-param-reassign */
function moveBox(box, xOffset, yOffset) {
  var corner = box.length;

  while (corner--) {
    box[corner][0] += xOffset;
    box[corner][1] += yOffset;
  }
}
function moveLine(line, xOffset, yOffset) {
  line[0].x += xOffset;
  line[0].y += yOffset;
  line[1].x += xOffset;
  line[1].y += yOffset;
}
// CONCATENATED MODULE: ./src/quagga/quagga.ts

















var InputStream = typeof window === 'undefined' ? input_stream_node : input_stream_factory;
var quagga_FrameGrabber = typeof window === 'undefined' ? frame_grabber_node_default.a : frame_grabber;

var quagga_Quagga = /*#__PURE__*/function () {
  function Quagga() {
    var _this = this;

    classCallCheck_default()(this, Quagga);

    defineProperty_default()(this, "context", new QuaggaContext_QuaggaContext());

    defineProperty_default()(this, "canRecord", function (callback) {
      var _this$context$config;

      if (!_this.context.config) {
        return;
      }

      barcode_locator["a" /* default */].checkImageConstraints(_this.context.inputStream, (_this$context$config = _this.context.config) === null || _this$context$config === void 0 ? void 0 : _this$context$config.locator);

      _this.initCanvas();

      _this.context.framegrabber = quagga_FrameGrabber.create(_this.context.inputStream, _this.context.canvasContainer.dom.image);

      if (_this.context.config.numOfWorkers === undefined) {
        _this.context.config.numOfWorkers = 0;
      }

      adjustWorkerPool(_this.context.config.numOfWorkers, _this.context.config, _this.context.inputStream, function () {
        var _this$context$config2;

        if (((_this$context$config2 = _this.context.config) === null || _this$context$config2 === void 0 ? void 0 : _this$context$config2.numOfWorkers) === 0) {
          _this.initializeData();
        }

        _this.ready(callback);
      });
    });

    defineProperty_default()(this, "update", function () {
      if (_this.context.onUIThread) {
        var workersUpdated = updateWorkers(_this.context.framegrabber);

        if (!workersUpdated) {
          var _this$context$inputIm;

          _this.context.framegrabber.attachData((_this$context$inputIm = _this.context.inputImageWrapper) === null || _this$context$inputIm === void 0 ? void 0 : _this$context$inputIm.data);

          if (_this.context.framegrabber.grab()) {
            if (!workersUpdated) {
              _this.locateAndDecode();
            }
          }
        }
      } else {
        var _this$context$inputIm2;

        _this.context.framegrabber.attachData((_this$context$inputIm2 = _this.context.inputImageWrapper) === null || _this$context$inputIm2 === void 0 ? void 0 : _this$context$inputIm2.data);

        _this.context.framegrabber.grab();

        _this.locateAndDecode();
      }
    });
  }

  createClass_default()(Quagga, [{
    key: "initBuffers",
    value: function initBuffers(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      var _initBuffers2 = initBuffers_initBuffers(this.context.inputStream, imageWrapper, this.context.config.locator),
          inputImageWrapper = _initBuffers2.inputImageWrapper,
          boxSize = _initBuffers2.boxSize;

      this.context.inputImageWrapper = inputImageWrapper;
      this.context.boxSize = boxSize;
    }
  }, {
    key: "initializeData",
    value: function initializeData(imageWrapper) {
      if (!this.context.config) {
        return;
      }

      this.initBuffers(imageWrapper);
      this.context.decoder = barcode_decoder.create(this.context.config.decoder, this.context.inputImageWrapper);
    }
  }, {
    key: "getViewPort",
    value: function getViewPort() {
      if (!this.context.config || !this.context.config.inputStream) {
        return null;
      }

      var target = this.context.config.inputStream.target;
      return getViewPort_getViewPort(target);
    }
  }, {
    key: "ready",
    value: function ready(callback) {
      this.context.inputStream.play();
      callback();
    }
  }, {
    key: "initCanvas",
    value: function initCanvas() {
      var container = initCanvas_initCanvas(this.context);

      if (!container) {
        return;
      }

      var ctx = container.ctx,
          dom = container.dom;
      this.context.canvasContainer.dom.image = dom.image;
      this.context.canvasContainer.dom.overlay = dom.overlay;
      this.context.canvasContainer.ctx.image = ctx.image;
      this.context.canvasContainer.ctx.overlay = ctx.overlay;
    }
  }, {
    key: "initInputStream",
    value: function initInputStream(callback) {
      if (!this.context.config || !this.context.config.inputStream) {
        return;
      }

      var _this$context$config$ = this.context.config.inputStream,
          inputType = _this$context$config$.type,
          constraints = _this$context$config$.constraints;

      var _setupInputStream = setupInputStream(inputType, this.getViewPort(), InputStream),
          video = _setupInputStream.video,
          inputStream = _setupInputStream.inputStream;

      if (inputType === 'LiveStream' && video) {
        camera_access.request(video, constraints).then(function () {
          return inputStream.trigger('canrecord');
        })["catch"](function (err) {
          return callback(err);
        });
      }

      inputStream.setAttribute('preload', 'auto');
      inputStream.setInputStream(this.context.config.inputStream);
      inputStream.addEventListener('canrecord', this.canRecord.bind(undefined, callback));
      this.context.inputStream = inputStream;
    }
  }, {
    key: "getBoundingBoxes",
    value: function getBoundingBoxes() {
      var _this$context$config3;

      return ((_this$context$config3 = this.context.config) === null || _this$context$config3 === void 0 ? void 0 : _this$context$config3.locate) ? barcode_locator["a" /* default */].locate() : [[Object(gl_vec2["clone"])(this.context.boxSize[0]), Object(gl_vec2["clone"])(this.context.boxSize[1]), Object(gl_vec2["clone"])(this.context.boxSize[2]), Object(gl_vec2["clone"])(this.context.boxSize[3])]];
    } // TODO: need a typescript type for result here.
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "transformResult",
    value: function transformResult(result) {
      var _this2 = this;

      var topRight = this.context.inputStream.getTopRight();
      var xOffset = topRight.x;
      var yOffset = topRight.y;

      if (xOffset === 0 && yOffset === 0) {
        return;
      }

      if (result.barcodes) {
        // TODO: BarcodeInfo may not be the right type here.
        result.barcodes.forEach(function (barcode) {
          return _this2.transformResult(barcode);
        });
      }

      if (result.line && result.line.length === 2) {
        moveLine(result.line, xOffset, yOffset);
      }

      if (result.box) {
        moveBox(result.box, xOffset, yOffset);
      }

      if (result.boxes && result.boxes.length > 0) {
        for (var i = 0; i < result.boxes.length; i++) {
          moveBox(result.boxes[i], xOffset, yOffset);
        }
      }
    }
  }, {
    key: "addResult",
    value: function addResult(result, imageData) {
      var _this3 = this;

      if (!imageData || !this.context.resultCollector) {
        return;
      } // TODO: Figure out what data structure holds a "barcodes" result, if any...


      if (result.barcodes) {
        result.barcodes.filter(function (barcode) {
          return barcode.codeResult;
        }).forEach(function (barcode) {
          return _this3.addResult(barcode, imageData);
        });
      } else if (result.codeResult) {
        this.context.resultCollector.addResult(imageData, this.context.inputStream.getCanvasSize(), result.codeResult);
      }
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "hasCodeResult",
    value: function hasCodeResult(result) {
      return !!(result && (result.barcodes ? result.barcodes.some(function (barcode) {
        return barcode.codeResult;
      }) : result.codeResult));
    } // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  }, {
    key: "publishResult",
    value: function publishResult() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var imageData = arguments.length > 1 ? arguments[1] : undefined;
      var resultToPublish = result;

      if (result && this.context.onUIThread) {
        this.transformResult(result);
        this.addResult(result, imageData);
        resultToPublish = result.barcodes || result;
      }

      events.publish('processed', resultToPublish);

      if (this.hasCodeResult(result)) {
        events.publish('detected', resultToPublish);
      }
    }
  }, {
    key: "locateAndDecode",
    value: function locateAndDecode() {
      var boxes = this.getBoundingBoxes();

      if (boxes) {
        var _this$context$inputIm3;

        var decodeResult = this.context.decoder.decodeFromBoundingBoxes(boxes) || {};
        decodeResult.boxes = boxes;
        this.publishResult(decodeResult, (_this$context$inputIm3 = this.context.inputImageWrapper) === null || _this$context$inputIm3 === void 0 ? void 0 : _this$context$inputIm3.data);
      } else {
        var imageResult = this.context.decoder.decodeFromImage(this.context.inputImageWrapper);

        if (imageResult) {
          var _this$context$inputIm4;

          this.publishResult(imageResult, (_this$context$inputIm4 = this.context.inputImageWrapper) === null || _this$context$inputIm4 === void 0 ? void 0 : _this$context$inputIm4.data);
        } else {
          this.publishResult();
        }
      }
    }
  }, {
    key: "startContinuousUpdate",
    value: function startContinuousUpdate() {
      var _this$context$config4,
          _this4 = this;

      var next = null;
      var delay = 1000 / (((_this$context$config4 = this.context.config) === null || _this$context$config4 === void 0 ? void 0 : _this$context$config4.frequency) || 60);
      this.context.stopped = false;
      var context = this.context;

      var newFrame = function newFrame(timestamp) {
        next = next || timestamp;

        if (!context.stopped) {
          next += delay;

          _this4.update();
        }

        window.requestAnimationFrame(newFrame);
      };

      newFrame(performance.now());
    }
  }, {
    key: "start",
    value: function start() {
      var _this$context$config5, _this$context$config6;

      if (this.context.onUIThread && ((_this$context$config5 = this.context.config) === null || _this$context$config5 === void 0 ? void 0 : (_this$context$config6 = _this$context$config5.inputStream) === null || _this$context$config6 === void 0 ? void 0 : _this$context$config6.type) === 'LiveStream') {
        this.startContinuousUpdate();
      } else {
        this.update();
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this$context$config7;

      this.context.stopped = true;
      adjustWorkerPool(0);

      if (((_this$context$config7 = this.context.config) === null || _this$context$config7 === void 0 ? void 0 : _this$context$config7.inputStream) && this.context.config.inputStream.type === 'LiveStream') {
        camera_access.release();
        this.context.inputStream.clearEventHandlers();
      }
    }
  }, {
    key: "setReaders",
    value: function setReaders(readers) {
      if (this.context.decoder) {
        this.context.decoder.setReaders(readers);
      }

      qworker_setReaders(readers);
    }
  }, {
    key: "registerReader",
    value: function registerReader(name, reader) {
      barcode_decoder.registerReader(name, reader);

      if (this.context.decoder) {
        this.context.decoder.registerReader(name, reader);
      }

      qworker_registerReader(name, reader);
    }
  }]);

  return Quagga;
}();


// CONCATENATED MODULE: ./src/quagga.js

 // eslint-disable-line no-unused-vars











var instance = new quagga_Quagga();
var _context = instance.context;
var QuaggaJSStaticInterface = {
  init: function init(config, cb, imageWrapper) {
    var quaggaInstance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : instance;
    var promise;

    if (!cb) {
      promise = new Promise(function (resolve, reject) {
        cb = function cb(err) {
          err ? reject(err) : resolve();
        };
      });
    }

    quaggaInstance.context.config = Object(lodash["merge"])({}, config_config, config); // TODO #179: pending restructure in Issue #179, we are temp disabling workers

    if (quaggaInstance.context.config.numOfWorkers > 0) {
      quaggaInstance.context.config.numOfWorkers = 0;
    }

    if (imageWrapper) {
      quaggaInstance.context.onUIThread = false;
      quaggaInstance.initializeData(imageWrapper);

      if (cb) {
        cb();
      }
    } else {
      quaggaInstance.initInputStream(cb);
    }

    return promise;
  },
  start: function start() {
    instance.start();
  },
  stop: function stop() {
    instance.stop();
  },
  pause: function pause() {
    _context.stopped = true;
  },
  onDetected: function onDetected(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onDetected called with invalid callback, ignoring');
      return;
    }

    events.subscribe('detected', callback);
  },
  offDetected: function offDetected(callback) {
    events.unsubscribe('detected', callback);
  },
  onProcessed: function onProcessed(callback) {
    if (!callback || typeof callback !== 'function' && (typeof_default()(callback) !== 'object' || !callback.callback)) {
      console.trace('* warning: Quagga.onProcessed called with invalid callback, ignoring');
      return;
    }

    events.subscribe('processed', callback);
  },
  offProcessed: function offProcessed(callback) {
    events.unsubscribe('processed', callback);
  },
  setReaders: function setReaders(readers) {
    if (!readers) {
      console.trace('* warning: Quagga.setReaders called with no readers, ignoring');
      return;
    }

    instance.setReaders(readers);
  },
  registerReader: function registerReader(name, reader) {
    if (!name) {
      console.trace('* warning: Quagga.registerReader called with no name, ignoring');
      return;
    }

    if (!reader) {
      console.trace('* warning: Quagga.registerReader called with no reader, ignoring');
      return;
    }

    instance.registerReader(name, reader);
  },
  registerResultCollector: function registerResultCollector(resultCollector) {
    if (resultCollector && typeof resultCollector.addResult === 'function') {
      _context.resultCollector = resultCollector;
    }
  },

  get canvas() {
    return _context.canvasContainer;
  },

  decodeSingle: function decodeSingle(config, resultCallback) {
    var _this = this;

    var quaggaInstance = new quagga_Quagga();
    config = Object(lodash["merge"])({
      inputStream: {
        type: 'ImageStream',
        sequence: false,
        size: 800,
        src: config.src
      },
      numOfWorkers:  true && config.debug ? 0 : 1,
      locator: {
        halfSample: false
      }
    }, config); // TODO #175: restructure worker support so that it will work with typescript using worker-loader
    // https://webpack.js.org/loaders/worker-loader/

    if (config.numOfWorkers > 0) {
      config.numOfWorkers = 0;
    } // workers require Worker and Blob support presently, so if no Blob or Worker then set
    // workers to 0.


    if (config.numOfWorkers > 0 && (typeof Blob === 'undefined' || typeof Worker === 'undefined')) {
      console.warn('* no Worker and/or Blob support - forcing numOfWorkers to 0');
      config.numOfWorkers = 0;
    }

    return new Promise(function (resolve, reject) {
      try {
        _this.init(config, function () {
          events.once('processed', function (result) {
            quaggaInstance.stop();

            if (resultCallback) {
              resultCallback.call(null, result);
            }

            resolve(result);
          }, true);
          quaggaInstance.start();
        }, null, quaggaInstance);
      } catch (err) {
        reject(err);
      }
    });
  },

  // add the usually expected "default" for use with require, build step won't allow us to
  // write to module.exports so do it here.
  get default() {
    return QuaggaJSStaticInterface;
  },

  BarcodeReader: barcode_reader,
  CameraAccess: camera_access,
  ImageDebug: image_debug["a" /* default */],
  ImageWrapper: image_wrapper["a" /* default */],
  ResultCollector: result_collector
};
/* harmony default export */ var quagga = __webpack_exports__["default"] = (QuaggaJSStaticInterface); // export BarcodeReader and other utilities for external plugins



/***/ })
/******/ ])["default"];
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9RdWFnZ2Evd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1F1YWdnYS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2suanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2NsdXN0ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi9jdl91dGlscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29tbW9uL2ltYWdlX2RlYnVnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vYXJyYXlfaGVscGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vaW1hZ2Vfd3JhcHBlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvdHJhY2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9ub2RlLWxpYnMtYnJvd3Nlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2Vwc2lsb24uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1YnRyYWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZXBzaWxvbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jcmVhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9ub3JtYWxpemUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvZG90LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3N1YnRyYWN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2RpdmlkZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0YW5jZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9zcXVhcmVkRGlzdGFuY2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlcl9ub2RlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9sb2NhdG9yL3Jhc3Rlcml6ZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2xvY2F0b3Ivc2tlbGV0b25pemVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nZXQtcGl4ZWxzL2RvbS1waXhlbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbW1vbi90eXBlZGVmcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZnJvbVZhbHVlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jb3B5LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NldC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9lcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZXhhY3RFcXVhbHMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvYWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3N1Yi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9tdWwuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZGl2LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2ludmVyc2UuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3RhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvZmxvb3IuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvY2VpbC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9yb3VuZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9zY2FsZUFuZEFkZC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9kaXN0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3NxckRpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3Nxckxlbi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9uZWdhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvbm9ybWFsaXplLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2RvdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9jcm9zcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9sZXJwLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3JhbmRvbS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi90cmFuc2Zvcm1NYXQyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDJkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL3RyYW5zZm9ybU1hdDMuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzIvdHJhbnNmb3JtTWF0NC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMi9mb3JFYWNoLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMyL2xpbWl0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nsb25lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2FuZ2xlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2VxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9leGFjdEVxdWFscy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9hZGQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3ViLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvbWluLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdW5kLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Rpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9sZW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyTGVuLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2Nyb3NzLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2xlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0My5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1RdWF0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc3VwZXJQcm9wQmFzZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2RldGVybWluYW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3RyYW5zcG9zZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9tdWx0aXBseS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9hZGpvaW50LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3JvdGF0ZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9pbnZlcnQuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvY3JlYXRlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL3NjYWxlLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9nbC1tYXQyL2NvcHkuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2dsLW1hdDIvZnJvYi5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZ2wtbWF0Mi9sZHUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvaW90YS1hcnJheS9pb3RhLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL29tZ2dpZi9vbWdnaWYuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL25kYXJyYXktcGFjay9jb252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9jb21waWxlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9jd2lzZS1jb21waWxlci9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvdW5pcS91bmlxLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy90aHJvdWdoL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS91dGlsIChpZ25vcmVkKSIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhL3V0aWwgKGlnbm9yZWQpP2Y1MjkiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9ub2RlX21vZHVsZXMvZGF0YS11cmktdG8tYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL1F1YWdnYS8uL25vZGVfbW9kdWxlcy9uZGFycmF5LWxpbmVhci1pbnRlcnBvbGF0ZS9pbnRlcnAuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYnJlc2VuaGFtLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvYmFyY29kZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzEyOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zOV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9jb2RhYmFyX3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL3VwY19yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fOF9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9lYW5fNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci91cGNfZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci9pMm9mNV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3JlYWRlci8yb2Y1X3JlYWRlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcmVhZGVyL2NvZGVfOTNfcmVhZGVyLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9yZWFkZXIvY29kZV8zMl9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2RlY29kZXIvYmFyY29kZV9kZWNvZGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vZXZlbnRzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb21tb24vbWVkaWFEZXZpY2VzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9jYW1lcmFfYWNjZXNzLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9hbmFseXRpY3MvcmVzdWx0X2NvbGxlY3Rvci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5kZXYudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2NvbmZpZy9jb25maWcubm9kZS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvY29uZmlnL2NvbmZpZy5wcm9kLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9jb25maWcvY29uZmlnLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9RdWFnZ2FDb250ZXh0LnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvaW5pdEJ1ZmZlcnMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9nZXRWaWV3UG9ydC50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL2luaXRDYW52YXMudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2V4aWZfaGVscGVyLmpzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbWFnZV9sb2FkZXIuanMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL2lucHV0L2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvaW5wdXRfc3RyZWFtL2lucHV0X3N0cmVhbV9ub2RlLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeS50cyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvaW5wdXQvZnJhbWVfZ3JhYmJlci5qcyIsIndlYnBhY2s6Ly9RdWFnZ2EvLi9zcmMvcXVhZ2dhL3F3b3JrZXIudHMiLCJ3ZWJwYWNrOi8vUXVhZ2dhLy4vc3JjL3F1YWdnYS9zZXR1cElucHV0U3RyZWFtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvdHJhbnNmb3JtLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EvcXVhZ2dhLnRzIiwid2VicGFjazovL1F1YWdnYS8uL3NyYy9xdWFnZ2EuanMiXSwibmFtZXMiOlsiX2RlZmluZVByb3BlcnR5Iiwib2JqIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiX2dldFByb3RvdHlwZU9mIiwibyIsInNldFByb3RvdHlwZU9mIiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiX3R5cGVvZiIsInJlcXVpcmUiLCJhc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsImNhbGwiLCJfaW5oZXJpdHMiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIkVQU0lMT04iLCJjbG9uZSIsImZyb21WYWx1ZXMiLCJjb3B5Iiwic2V0IiwiZXF1YWxzIiwiZXhhY3RFcXVhbHMiLCJhZGQiLCJzdWJ0cmFjdCIsInN1YiIsIm11bHRpcGx5IiwibXVsIiwiZGl2aWRlIiwiZGl2IiwiaW52ZXJzZSIsIm1pbiIsIm1heCIsInJvdGF0ZSIsImZsb29yIiwiY2VpbCIsInJvdW5kIiwic2NhbGUiLCJzY2FsZUFuZEFkZCIsImRpc3RhbmNlIiwiZGlzdCIsInNxdWFyZWREaXN0YW5jZSIsInNxckRpc3QiLCJsZW4iLCJzcXVhcmVkTGVuZ3RoIiwic3FyTGVuIiwibmVnYXRlIiwibm9ybWFsaXplIiwiZG90IiwiY3Jvc3MiLCJsZXJwIiwicmFuZG9tIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwidHJhbnNmb3JtTWF0MyIsInRyYW5zZm9ybU1hdDQiLCJmb3JFYWNoIiwibGltaXQiLCJ2ZWMyIiwicG9pbnQiLCJ0aHJlc2hvbGQiLCJwb2ludHMiLCJjZW50ZXIiLCJyYWQiLCJ2ZWMiLCJwb2ludE1hcCIsInBvaW50VG9BZGQiLCJpZCIsInB1c2giLCJ1cGRhdGVDZW50ZXIiLCJzdW0iLCJNYXRoIiwiY29zIiwic2luIiwiaW5pdCIsImZpdHMiLCJvdGhlclBvaW50Iiwic2ltaWxhcml0eSIsImFicyIsImdldFBvaW50cyIsImdldENlbnRlciIsImNyZWF0ZVBvaW50IiwibmV3UG9pbnQiLCJwcm9wZXJ0eSIsInYyY2xvbmUiLCJ2ZWMzIiwidjNjbG9uZSIsImltYWdlUmVmIiwieCIsInkiLCJ0aGF0IiwidG9WZWMyIiwidG9WZWMzIiwiY29tcHV0ZUludGVncmFsSW1hZ2UyIiwiaW1hZ2VXcmFwcGVyIiwiaW50ZWdyYWxXcmFwcGVyIiwiaW1hZ2VEYXRhIiwiZGF0YSIsIndpZHRoIiwic2l6ZSIsImhlaWdodCIsImludGVncmFsSW1hZ2VEYXRhIiwicG9zQSIsInBvc0IiLCJwb3NDIiwicG9zRCIsImNvbXB1dGVJbnRlZ3JhbEltYWdlIiwidiIsInUiLCJ0aHJlc2hvbGRJbWFnZSIsInRhcmdldFdyYXBwZXIiLCJ0YXJnZXREYXRhIiwiY29tcHV0ZUhpc3RvZ3JhbSIsImJpdHNQZXJQaXhlbCIsImJpdFNoaWZ0IiwiYnVja2V0Q250IiwiaGlzdCIsIkludDMyQXJyYXkiLCJzaGFycGVuTGluZSIsImxpbmUiLCJsZWZ0IiwicmlnaHQiLCJkZXRlcm1pbmVPdHN1VGhyZXNob2xkIiwicHgiLCJlbmQiLCJteCIsImRldGVybWluZVRocmVzaG9sZCIsInZldCIsInAxIiwicDIiLCJwMTIiLCJtMSIsIm0yIiwibTEyIiwiayIsIkFycmF5SGVscGVyIiwibWF4SW5kZXgiLCJvdHN1VGhyZXNob2xkIiwiY29tcHV0ZUJpbmFyeUltYWdlIiwia2VybmVsIiwiQSIsIkIiLCJDIiwiRCIsImF2ZyIsImNsdXN0ZXIiLCJ0aGlzQ2x1c3RlciIsImNsdXN0ZXJzIiwiYWRkVG9DbHVzdGVyIiwiZm91bmQiLCJDbHVzdGVyMiIsIlRyYWNlciIsInRyYWNlIiwiaXRlcmF0aW9uIiwibWF4SXRlcmF0aW9ucyIsInRvcCIsInJlc3VsdCIsImNlbnRlclBvcyIsImN1cnJlbnRQb3MiLCJpZHgiLCJmb3J3YXJkIiwidG8iLCJ0b0lkeCIsInByZWRpY3RlZFBvcyIsInRocmVzaG9sZFgiLCJ0aHJlc2hvbGRZIiwibWF0Y2giLCJwb3MiLCJwcmVkaWN0ZWQiLCJmcm9tIiwiRElMQVRFIiwiRVJPREUiLCJkaWxhdGUiLCJpbkltYWdlV3JhcHBlciIsIm91dEltYWdlV3JhcHBlciIsImluSW1hZ2VEYXRhIiwib3V0SW1hZ2VEYXRhIiwieVN0YXJ0MSIsInlTdGFydDIiLCJ4U3RhcnQxIiwieFN0YXJ0MiIsImVyb2RlIiwiYUltYWdlV3JhcHBlciIsImJJbWFnZVdyYXBwZXIiLCJyZXN1bHRJbWFnZVdyYXBwZXIiLCJhSW1hZ2VEYXRhIiwiYkltYWdlRGF0YSIsImNJbWFnZURhdGEiLCJiaXR3aXNlT3IiLCJjb3VudE5vblplcm8iLCJ0b3BHZW5lcmljIiwibGlzdCIsInNjb3JlRnVuYyIsIm1pbklkeCIsInF1ZXVlIiwic2NvcmUiLCJoaXQiLCJpdGVtIiwiYXBwbHkiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJncmF5QXJyYXlGcm9tSW1hZ2UiLCJodG1sSW1hZ2UiLCJvZmZzZXRYIiwiY3R4IiwiYXJyYXkiLCJkcmF3SW1hZ2UiLCJjdHhEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwiY29tcHV0ZUdyYXkiLCJncmF5QXJyYXlGcm9tQ29udGV4dCIsIm9mZnNldCIsImdyYXlBbmRIYWxmU2FtcGxlRnJvbUNhbnZhc0RhdGEiLCJjYW52YXNEYXRhIiwib3V0QXJyYXkiLCJ0b3BSb3dJZHgiLCJib3R0b21Sb3dJZHgiLCJlbmRJZHgiLCJvdXRXaWR0aCIsIm91dEltZ0lkeCIsImluV2lkdGgiLCJjb25maWciLCJsIiwic2luZ2xlQ2hhbm5lbCIsImxvYWRJbWFnZUFycmF5Iiwic3JjIiwiY2FsbGJhY2siLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImdldENvbnRleHQiLCJVaW50OEFycmF5IiwiaGFsZlNhbXBsZSIsImluSW1nV3JhcHBlciIsIm91dEltZ1dyYXBwZXIiLCJpbkltZyIsIm91dEltZyIsImhzdjJyZ2IiLCJoc3YiLCJyZ2IiLCJoIiwicyIsImMiLCJtIiwiciIsImciLCJiIiwiX2NvbXB1dGVEaXZpc29ycyIsIm4iLCJsYXJnZURpdmlzb3JzIiwiZGl2aXNvcnMiLCJzcXJ0IiwidW5zaGlmdCIsImNvbmNhdCIsIl9jb21wdXRlSW50ZXJzZWN0aW9uIiwiYXJyMSIsImFycjIiLCJqIiwiY2FsY3VsYXRlUGF0Y2hTaXplIiwicGF0Y2hTaXplIiwiaW1nU2l6ZSIsImRpdmlzb3JzWCIsImRpdmlzb3JzWSIsIndpZGVTaWRlIiwiY29tbW9uIiwibnJPZlBhdGNoZXNMaXN0IiwibnJPZlBhdGNoZXNNYXAiLCJzbWFsbCIsIm1lZGl1bSIsImxhcmdlIiwibnJPZlBhdGNoZXNJZHgiLCJuck9mUGF0Y2hlcyIsImRlc2lyZWRQYXRjaFNpemUiLCJvcHRpbWFsUGF0Y2hTaXplIiwiZmluZFBhdGNoU2l6ZUZvckRpdmlzb3JzIiwiX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzIiwiZGltZW5zaW9uIiwicGFyc2VGbG9hdCIsInVuaXQiLCJpbmRleE9mIiwiX2RpbWVuc2lvbnNDb252ZXJ0ZXJzIiwiY29udGV4dCIsImJvdHRvbSIsImNvbXB1dGVJbWFnZUFyZWEiLCJpbnB1dFdpZHRoIiwiaW5wdXRIZWlnaHQiLCJhcmVhIiwicGFyc2VkQXJlYSIsImtleXMiLCJyZWR1Y2UiLCJwYXJzZWQiLCJjYWxjdWxhdGVkIiwic3giLCJzeSIsInN3Iiwic2giLCJkcmF3UmVjdCIsInN0eWxlIiwic3Ryb2tlU3R5bGUiLCJjb2xvciIsImZpbGxTdHlsZSIsImxpbmVXaWR0aCIsImJlZ2luUGF0aCIsInN0cm9rZVJlY3QiLCJkcmF3UGF0aCIsInBhdGgiLCJkZWYiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJzdHJva2UiLCJjYW52YXNEYXRhUG9zIiwiaW1hZ2VEYXRhUG9zIiwicHV0SW1hZ2VEYXRhIiwiYXJyIiwidmFsIiwic2h1ZmZsZSIsInRvUG9pbnRMaXN0Iiwicm93cyIsInAiLCJyb3ciLCJqb2luIiwicHJldiIsIm5leHQiLCJhc3NlcnROdW1iZXJQb3NpdGl2ZSIsIkVycm9yIiwiSW1hZ2VXcmFwcGVyIiwiQXJyYXlUeXBlIiwiaW5pdGlhbGl6ZSIsImltZ1JlZiIsImJvcmRlciIsInNpemVYIiwic2l6ZVkiLCJpbmRleE1hcHBpbmciLCJsYWJlbENvdW50IiwieXNxIiwibGFiZWxTdW0iLCJsYWJlbCIsIm11MTEiLCJtdTAyIiwibXUyMCIsInhfIiwieV8iLCJ0bXAiLCJQSSIsIlBJXzQiLCJtMDAiLCJtMDEiLCJtMTAiLCJtMTEiLCJtMDIiLCJtMjAiLCJ0aGV0YSIsImlzTmFOIiwiYXRhbiIsInJldCIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwicGl4ZWwiLCJjdXJyZW50IiwiZ2V0IiwiZnJhbWUiLCJnZXRBc1JHQkEiLCJuZXdGcmFtZSIsIkltYWdlRGF0YSIsImluU2NhbGUiLCJhZGp1c3RlZFNjYWxlIiwid2hpdGVSZ2IiLCJibGFja1JnYiIsInVuZGVmaW5lZCIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSEFTSF9VTkRFRklORUQiLCJNQVhfTUVNT0laRV9TSVpFIiwiUExBQ0VIT0xERVIiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJXUkFQX0JJTkRfRkxBRyIsIldSQVBfQklORF9LRVlfRkxBRyIsIldSQVBfQ1VSUllfQk9VTkRfRkxBRyIsIldSQVBfQ1VSUllfRkxBRyIsIldSQVBfQ1VSUllfUklHSFRfRkxBRyIsIldSQVBfUEFSVElBTF9GTEFHIiwiV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9SRUFSR19GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJERUZBVUxUX1RSVU5DX0xFTkdUSCIsIkRFRkFVTFRfVFJVTkNfT01JU1NJT04iLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIkxBWllfRklMVEVSX0ZMQUciLCJMQVpZX01BUF9GTEFHIiwiTEFaWV9XSElMRV9GTEFHIiwiSU5GSU5JVFkiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYXN5bmNUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImRvbUV4Y1RhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm51bGxUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicHJveHlUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJ1bmRlZmluZWRUYWciLCJ3ZWFrTWFwVGFnIiwid2Vha1NldFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzY2FwZWRIdG1sIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNFc2NhcGVkSHRtbCIsIlJlZ0V4cCIsInNvdXJjZSIsInJlSGFzVW5lc2NhcGVkSHRtbCIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlSW50ZXJwb2xhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwicmVQcm9wTmFtZSIsInJlUmVnRXhwQ2hhciIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbSIsInJlVHJpbVN0YXJ0IiwicmVUcmltRW5kIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxIiwicnNFbW9qaSIsInJzU3ltYm9sIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGUiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsInR5cGVkQXJyYXlUYWdzIiwiY2xvbmVhYmxlVGFncyIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsImZyZWVQYXJzZUludCIsInBhcnNlSW50IiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsImJpbmRpbmciLCJlIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJub2RlSXNTZXQiLCJpc1NldCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJmdW5jIiwidGhpc0FyZyIsImFyZ3MiLCJhcnJheUFnZ3JlZ2F0b3IiLCJzZXR0ZXIiLCJpdGVyYXRlZSIsImFjY3VtdWxhdG9yIiwiaW5kZXgiLCJhcnJheUVhY2giLCJhcnJheUVhY2hSaWdodCIsImFycmF5RXZlcnkiLCJwcmVkaWNhdGUiLCJhcnJheUZpbHRlciIsInJlc0luZGV4IiwiYXJyYXlJbmNsdWRlcyIsImJhc2VJbmRleE9mIiwiYXJyYXlJbmNsdWRlc1dpdGgiLCJjb21wYXJhdG9yIiwiYXJyYXlNYXAiLCJBcnJheSIsImFycmF5UHVzaCIsInZhbHVlcyIsImFycmF5UmVkdWNlIiwiaW5pdEFjY3VtIiwiYXJyYXlSZWR1Y2VSaWdodCIsImFycmF5U29tZSIsImFzY2lpU2l6ZSIsImJhc2VQcm9wZXJ0eSIsImFzY2lpVG9BcnJheSIsInN0cmluZyIsInNwbGl0IiwiYXNjaWlXb3JkcyIsImJhc2VGaW5kS2V5IiwiY29sbGVjdGlvbiIsImVhY2hGdW5jIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsInN0cmljdEluZGV4T2YiLCJiYXNlSXNOYU4iLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJvYmplY3QiLCJiYXNlUHJvcGVydHlPZiIsImJhc2VSZWR1Y2UiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiYmFzZVRpbWVzIiwiYmFzZVRvUGFpcnMiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjYWNoZSIsImhhcyIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwidGVzdCIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJkb25lIiwibWFwVG9BcnJheSIsIm1hcCIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJhcmciLCJyZXBsYWNlSG9sZGVycyIsInNldFRvQXJyYXkiLCJzZXRUb1BhaXJzIiwic3RyaWN0TGFzdEluZGV4T2YiLCJzdHJpbmdTaXplIiwidW5pY29kZVNpemUiLCJzdHJpbmdUb0FycmF5IiwidW5pY29kZVRvQXJyYXkiLCJ1bmVzY2FwZUh0bWxDaGFyIiwibGFzdEluZGV4IiwidW5pY29kZVdvcmRzIiwicnVuSW5Db250ZXh0IiwiXyIsImRlZmF1bHRzIiwicGljayIsIkRhdGUiLCJTdHJpbmciLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwidG9TdHJpbmciLCJoYXNPd25Qcm9wZXJ0eSIsImlkQ291bnRlciIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJleGVjIiwiSUVfUFJPVE8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsIm9iamVjdEN0b3JTdHJpbmciLCJvbGREYXNoIiwicmVJc05hdGl2ZSIsInJlcGxhY2UiLCJCdWZmZXIiLCJTeW1ib2wiLCJhbGxvY1Vuc2FmZSIsImdldFByb3RvdHlwZSIsIm9iamVjdENyZWF0ZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic3BsaWNlIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInN5bUl0ZXJhdG9yIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldE5hdGl2ZSIsImN0eENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImN0eE5vdyIsIm5vdyIsImN0eFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsIm5hdGl2ZUZsb29yIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZUtleXMiLCJuYXRpdmVNYXgiLCJuYXRpdmVNaW4iLCJuYXRpdmVOb3ciLCJuYXRpdmVQYXJzZUludCIsIm5hdGl2ZVJhbmRvbSIsIm5hdGl2ZVJldmVyc2UiLCJyZXZlcnNlIiwiRGF0YVZpZXciLCJNYXAiLCJQcm9taXNlIiwiU2V0IiwiV2Vha01hcCIsIm5hdGl2ZUNyZWF0ZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJkYXRhVmlld0N0b3JTdHJpbmciLCJ0b1NvdXJjZSIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJzeW1ib2xUb1N0cmluZyIsImxvZGFzaCIsImlzT2JqZWN0TGlrZSIsImlzQXJyYXkiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlQ3JlYXRlIiwicHJvdG8iLCJpc09iamVjdCIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsIl9fZGlyX18iLCJfX2ZpbHRlcmVkX18iLCJfX2l0ZXJhdGVlc19fIiwiX190YWtlQ291bnRfXyIsIl9fdmlld3NfXyIsImxhenlDbG9uZSIsImNvcHlBcnJheSIsImxhenlSZXZlcnNlIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNBcnIiLCJpc1JpZ2h0IiwiYXJyTGVuZ3RoIiwidmlldyIsImdldFZpZXciLCJzdGFydCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJ0eXBlIiwiY29tcHV0ZWQiLCJIYXNoIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIlNldENhY2hlIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc0FyZ3VtZW50cyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiaXNJbmRleCIsImFycmF5U2FtcGxlIiwiYmFzZVJhbmRvbSIsImFycmF5U2FtcGxlU2l6ZSIsInNodWZmbGVTZWxmIiwiYmFzZUNsYW1wIiwiYXJyYXlTaHVmZmxlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsIm51bWJlciIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJ0YWciLCJnZXRUYWciLCJpc0Z1bmMiLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJnZXRBbGxLZXlzSW4iLCJnZXRBbGxLZXlzIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJpbmNsdWRlcyIsImlzQ29tbW9uIiwidmFsdWVzTGVuZ3RoIiwidmFsdWVzSW5kZXgiLCJjcmVhdGVCYXNlRWFjaCIsImJhc2VGb3JPd24iLCJiYXNlRWFjaFJpZ2h0IiwiYmFzZUZvck93blJpZ2h0IiwiYmFzZUV2ZXJ5IiwiYmFzZUV4dHJlbXVtIiwiaXNTeW1ib2wiLCJiYXNlRmlsbCIsInRvSW50ZWdlciIsInRvTGVuZ3RoIiwiYmFzZUZpbHRlciIsImJhc2VGbGF0dGVuIiwiZGVwdGgiLCJpc1N0cmljdCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRm9yIiwiY3JlYXRlQmFzZUZvciIsImJhc2VGb3JSaWdodCIsImJhc2VGdW5jdGlvbnMiLCJpc0Z1bmN0aW9uIiwiYmFzZUdldCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJJbmZpbml0eSIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJiYXNlSW52b2tlIiwicGFyZW50IiwibGFzdCIsImJhc2VJc0FyZ3VtZW50cyIsImJhc2VJc0FycmF5QnVmZmVyIiwiYmFzZUlzRGF0ZSIsImJhc2VJc0VxdWFsIiwiYmFzZUlzRXF1YWxEZWVwIiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNNYXAiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiaXNNYXNrZWQiLCJwYXR0ZXJuIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUlzU2V0IiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUl0ZXJhdGVlIiwiaWRlbnRpdHkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTHQiLCJiYXNlTWFwIiwiaXNBcnJheUxpa2UiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImlzS2V5IiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJuZXdWYWx1ZSIsInNhZmVHZXQiLCJtZXJnZUZ1bmMiLCJpc1R5cGVkIiwiaXNBcnJheUxpa2VPYmplY3QiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImJhc2VOdGgiLCJiYXNlT3JkZXJCeSIsIm9yZGVycyIsImdldEl0ZXJhdGVlIiwiY3JpdGVyaWEiLCJjb21wYXJlTXVsdGlwbGUiLCJiYXNlUGljayIsImJhc2VQaWNrQnkiLCJiYXNlU2V0IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsInN0ZXAiLCJiYXNlUmVwZWF0IiwiYmFzZVJlc3QiLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2V0VG9TdHJpbmciLCJjb25zdGFudCIsImJhc2VTaHVmZmxlIiwiYmFzZVNsaWNlIiwiYmFzZVNvbWUiLCJiYXNlU29ydGVkSW5kZXgiLCJyZXRIaWdoZXN0IiwibG93IiwiaGlnaCIsIm1pZCIsImJhc2VTb3J0ZWRJbmRleEJ5IiwidmFsSXNOYU4iLCJ2YWxJc051bGwiLCJ2YWxJc1N5bWJvbCIsInZhbElzVW5kZWZpbmVkIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsInNldExvdyIsImJhc2VTb3J0ZWRVbmlxIiwiYmFzZVRvTnVtYmVyIiwiYmFzZVRvU3RyaW5nIiwiYmFzZVVuaXEiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJhY3Rpb24iLCJiYXNlWG9yIiwiYmFzZVppcE9iamVjdCIsImFzc2lnbkZ1bmMiLCJ2YWxzTGVuZ3RoIiwiY2FzdEFycmF5TGlrZU9iamVjdCIsImNhc3RGdW5jdGlvbiIsInN0cmluZ1RvUGF0aCIsImNhc3RSZXN0IiwiY2FzdFNsaWNlIiwiYnVmZmVyIiwic2xpY2UiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVEYXRhVmlldyIsImRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImNsb25lUmVnRXhwIiwicmVnZXhwIiwiY2xvbmVTeW1ib2wiLCJzeW1ib2wiLCJ0eXBlZEFycmF5IiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzUmVmbGV4aXZlIiwib2JqQ3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiY29tcG9zZUFyZ3MiLCJwYXJ0aWFscyIsImhvbGRlcnMiLCJpc0N1cnJpZWQiLCJhcmdzSW5kZXgiLCJhcmdzTGVuZ3RoIiwiaG9sZGVyc0xlbmd0aCIsImxlZnRJbmRleCIsImxlZnRMZW5ndGgiLCJyYW5nZUxlbmd0aCIsImlzVW5jdXJyaWVkIiwiY29tcG9zZUFyZ3NSaWdodCIsImhvbGRlcnNJbmRleCIsInJpZ2h0SW5kZXgiLCJyaWdodExlbmd0aCIsImlzTmV3IiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImNyZWF0ZUFnZ3JlZ2F0b3IiLCJpbml0aWFsaXplciIsImNyZWF0ZUFzc2lnbmVyIiwiYXNzaWduZXIiLCJzb3VyY2VzIiwiZ3VhcmQiLCJpc0l0ZXJhdGVlQ2FsbCIsIml0ZXJhYmxlIiwiY3JlYXRlQmluZCIsImlzQmluZCIsIkN0b3IiLCJjcmVhdGVDdG9yIiwid3JhcHBlciIsImZuIiwiYXJndW1lbnRzIiwiY3JlYXRlQ2FzZUZpcnN0IiwibWV0aG9kTmFtZSIsImNoYXJBdCIsInRyYWlsaW5nIiwiY3JlYXRlQ29tcG91bmRlciIsIndvcmRzIiwiZGVidXJyIiwidGhpc0JpbmRpbmciLCJjcmVhdGVDdXJyeSIsImFyaXR5IiwiZ2V0SG9sZGVyIiwiY3JlYXRlUmVjdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZUZpbmQiLCJmaW5kSW5kZXhGdW5jIiwiY3JlYXRlRmxvdyIsImZsYXRSZXN0IiwiZnVuY3MiLCJwcmVyZXEiLCJ0aHJ1IiwiZ2V0RnVuY05hbWUiLCJmdW5jTmFtZSIsImdldERhdGEiLCJpc0xhemlhYmxlIiwicGxhbnQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiYXJnUG9zIiwiYXJ5IiwiaXNBcnkiLCJpc0JpbmRLZXkiLCJpc0ZsaXAiLCJob2xkZXJzQ291bnQiLCJuZXdIb2xkZXJzIiwicmVvcmRlciIsImNyZWF0ZUludmVydGVyIiwidG9JdGVyYXRlZSIsImNyZWF0ZU1hdGhPcGVyYXRpb24iLCJvcGVyYXRvciIsImRlZmF1bHRWYWx1ZSIsImNyZWF0ZU92ZXIiLCJhcnJheUZ1bmMiLCJjcmVhdGVQYWRkaW5nIiwiY2hhcnMiLCJjaGFyc0xlbmd0aCIsImNyZWF0ZVBhcnRpYWwiLCJjcmVhdGVSYW5nZSIsInRvRmluaXRlIiwiY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsInRvTnVtYmVyIiwid3JhcEZ1bmMiLCJpc0N1cnJ5IiwibmV3SG9sZGVyc1JpZ2h0IiwibmV3UGFydGlhbHMiLCJuZXdQYXJ0aWFsc1JpZ2h0IiwibmV3RGF0YSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJjcmVhdGVSb3VuZCIsInByZWNpc2lvbiIsInBhaXIiLCJub29wIiwiY3JlYXRlVG9QYWlycyIsImNyZWF0ZVdyYXAiLCJtZXJnZURhdGEiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwiY3VzdG9tRGVmYXVsdHNNZXJnZSIsImN1c3RvbU9taXRDbG9uZSIsImlzUGFydGlhbCIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm5hbWUiLCJtZXNzYWdlIiwiY29udmVydCIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZmxhdHRlbiIsIm90aGVyRnVuYyIsImlzS2V5YWJsZSIsImlzT3duIiwidW5tYXNrZWQiLCJzdHViQXJyYXkiLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwidHJhbnNmb3JtcyIsImdldFdyYXBEZXRhaWxzIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJpbnB1dCIsImluc2VydFdyYXBEZXRhaWxzIiwiZGV0YWlscyIsImlzTWFza2FibGUiLCJzdHViRmFsc2UiLCJtZW1vaXplQ2FwcGVkIiwibWVtb2l6ZSIsInNyY0JpdG1hc2siLCJuZXdCaXRtYXNrIiwiaXNDb21ibyIsIm90aGVyQXJncyIsIm9sZEFycmF5Iiwic2hvcnRPdXQiLCJyZWZlcmVuY2UiLCJ1cGRhdGVXcmFwRGV0YWlscyIsImNvdW50IiwibGFzdENhbGxlZCIsInN0YW1wIiwicmVtYWluaW5nIiwicmFuZCIsImNoYXJDb2RlQXQiLCJxdW90ZSIsInN1YlN0cmluZyIsImNodW5rIiwiY29tcGFjdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlQnkiLCJkaWZmZXJlbmNlV2l0aCIsImRyb3AiLCJkcm9wUmlnaHQiLCJkcm9wUmlnaHRXaGlsZSIsImRyb3BXaGlsZSIsImZpbGwiLCJmaW5kSW5kZXgiLCJmaW5kTGFzdEluZGV4IiwiZmxhdHRlbkRlZXAiLCJmbGF0dGVuRGVwdGgiLCJmcm9tUGFpcnMiLCJoZWFkIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsImxhc3RJbmRleE9mIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInJlbW92ZSIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwiY2hhaW4iLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsIndyYXBwZXJSZXZlcnNlIiwid3JhcHBlZCIsIndyYXBwZXJWYWx1ZSIsImNvdW50QnkiLCJldmVyeSIsImZpbHRlciIsImZpbmQiLCJmaW5kTGFzdCIsImZsYXRNYXAiLCJmbGF0TWFwRGVlcCIsImZsYXRNYXBEZXB0aCIsImZvckVhY2hSaWdodCIsImdyb3VwQnkiLCJpc1N0cmluZyIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZVJpZ2h0IiwicmVqZWN0Iiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNvbWUiLCJzb3J0QnkiLCJhZnRlciIsImJlZm9yZSIsImJpbmQiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJvcHRpb25zIiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwiaW52b2tlRnVuYyIsInRpbWUiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImRlZmVyIiwiZGVsYXkiLCJmbGlwIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwib25jZSIsIm92ZXJBcmdzIiwiZnVuY3NMZW5ndGgiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicmVhcmciLCJyZXN0Iiwic3ByZWFkIiwidGhyb3R0bGUiLCJ1bmFyeSIsIndyYXAiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNCb29sZWFuIiwiaXNFbGVtZW50IiwiaXNFbXB0eSIsImlzRXF1YWwiLCJpc0VxdWFsV2l0aCIsImlzRXJyb3IiLCJpc0ludGVnZXIiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc051bWJlciIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNVbmRlZmluZWQiLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXQiLCJsdCIsImx0ZSIsInNpZ24iLCJyZW1haW5kZXIiLCJpc0JpbmFyeSIsInRvU2FmZUludGVnZXIiLCJhc3NpZ24iLCJhc3NpZ25JbiIsImFzc2lnbkluV2l0aCIsImFzc2lnbldpdGgiLCJhdCIsInByb3BlcnRpZXMiLCJwcm9wc0luZGV4IiwicHJvcHNMZW5ndGgiLCJkZWZhdWx0c0RlZXAiLCJtZXJnZVdpdGgiLCJmaW5kS2V5IiwiZmluZExhc3RLZXkiLCJmb3JJbiIsImZvckluUmlnaHQiLCJmb3JPd24iLCJmb3JPd25SaWdodCIsImZ1bmN0aW9ucyIsImZ1bmN0aW9uc0luIiwiaW52ZXJ0IiwiaW52ZXJ0QnkiLCJpbnZva2UiLCJtYXBLZXlzIiwibWFwVmFsdWVzIiwibWVyZ2UiLCJvbWl0Iiwib21pdEJ5IiwicGlja0J5IiwicHJvcCIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGUiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJjbGFtcCIsImluUmFuZ2UiLCJmbG9hdGluZyIsInRlbXAiLCJjYW1lbENhc2UiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVuZHNXaXRoIiwicG9zaXRpb24iLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInJlcGVhdCIsInNuYWtlQ2FzZSIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidG9VcHBlckNhc2UiLCJ0cmltIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzZWFyY2giLCJzdWJzdHJpbmciLCJuZXdFbmQiLCJ1bmVzY2FwZSIsInVwcGVyQ2FzZSIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNvbmQiLCJjb25mb3JtcyIsImRlZmF1bHRUbyIsImZsb3ciLCJmbG93UmlnaHQiLCJtYXRjaGVzIiwibWF0Y2hlc1Byb3BlcnR5IiwibWV0aG9kIiwibWV0aG9kT2YiLCJtaXhpbiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2UiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRpbWVzIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJtaW51ZW5kIiwic3VidHJhaGVuZCIsInN1bUJ5IiwiZW50cmllc0luIiwiZXh0ZW5kIiwiZXh0ZW5kV2l0aCIsImVhY2giLCJlYWNoUmlnaHQiLCJmaXJzdCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJ0b0pTT04iLCJkZWZpbmUiLCJ3aW5kb3ciLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsInRpbWVvdXQiLCJydW4iLCJuZXh0VGljayIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwib24iLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsInByZXBlbmRMaXN0ZW5lciIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJjd2QiLCJjaGRpciIsInVtYXNrIiwicG5hIiwib2JqZWN0S2V5cyIsIkR1cGxleCIsInV0aWwiLCJpbmhlcml0cyIsIlJlYWRhYmxlIiwiV3JpdGFibGUiLCJyZWFkYWJsZSIsImFsbG93SGFsZk9wZW4iLCJvbmVuZCIsIl93cml0YWJsZVN0YXRlIiwiaGlnaFdhdGVyTWFyayIsImVuZGVkIiwib25FbmROVCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3kiLCJlcnIiLCJjYiIsInN1cGVyUHJvcEJhc2UiLCJfZ2V0IiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiYmFzZSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJjdG9yIiwic3VwZXJDdG9yIiwic3VwZXJfIiwiVGVtcEN0b3IiLCJzZWFyY2hEaXJlY3Rpb25zIiwibGFiZWxXcmFwcGVyIiwibGFiZWxEYXRhIiwiZWRnZWxhYmVsIiwiY3kiLCJjeCIsInZlcnRleDJEIiwiY29udG91clRyYWNpbmciLCJGdiIsIkN2IiwiUCIsImxkaXIiLCJiYXNlNjQiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0Iiwia01heExlbmd0aCIsImZvbyIsInN1YmFycmF5IiwiY3JlYXRlQnVmZmVyIiwiUmFuZ2VFcnJvciIsImVuY29kaW5nT3JPZmZzZXQiLCJwb29sU2l6ZSIsIl9hdWdtZW50IiwiZnJvbUFycmF5QnVmZmVyIiwiZnJvbVN0cmluZyIsImZyb21PYmplY3QiLCJzcGVjaWVzIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZW5jb2RpbmciLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93IiwiaXNFbmNvZGluZyIsImFjdHVhbCIsIndyaXRlIiwiZnJvbUFycmF5TGlrZSIsImlzbmFuIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsImEiLCJidWYiLCJpc1ZpZXciLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiaW5zcGVjdCIsInN0ciIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsInZhbExlbmd0aCIsInJlYWQiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiaGV4V3JpdGUiLCJzdHJMZW4iLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsIl9hcnIiLCJmcm9tQnl0ZUFycmF5IiwicmVzIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4Iiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJjb2RlIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ1bml0cyIsImxlYWRTdXJyb2dhdGUiLCJieXRlQXJyYXkiLCJoaSIsImxvIiwidG9CeXRlQXJyYXkiLCJkc3QiLCJpc051bGxPclVuZGVmaW5lZCIsInJlIiwiZCIsImlzUHJpbWl0aXZlIiwiX2NvbmZpZyIsIl9jdXJyZW50SW1hZ2VXcmFwcGVyIiwiX3NrZWxJbWFnZVdyYXBwZXIiLCJfc3ViSW1hZ2VXcmFwcGVyIiwiX2xhYmVsSW1hZ2VXcmFwcGVyIiwiX3BhdGNoR3JpZCIsIl9wYXRjaExhYmVsR3JpZCIsIl9pbWFnZVRvUGF0Y2hHcmlkIiwiX2JpbmFyeUltYWdlV3JhcHBlciIsIl9wYXRjaFNpemUiLCJfY2FudmFzQ29udGFpbmVyIiwiYmluYXJ5IiwiZG9tIiwiX251bVBhdGNoZXMiLCJfaW5wdXRJbWFnZVdyYXBwZXIiLCJfc2tlbGV0b25pemVyIiwiaW5pdEJ1ZmZlcnMiLCJza2VsZXRvbkltYWdlRGF0YSIsInNrZWxldG9uaXplciIsImluaXRDYW52YXMiLCJ1c2VXb3JrZXIiLCJjbGFzc05hbWUiLCJFTlYiLCJkZWJ1ZyIsInNob3dDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwiYXBwZW5kQ2hpbGQiLCJib3hGcm9tUGF0Y2hlcyIsInBhdGNoZXMiLCJvdmVyQXZnIiwicGF0Y2giLCJ0cmFuc01hdCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJib3giLCJzaG93UGF0Y2hlcyIsIkltYWdlRGVidWciLCJtYXQyIiwic2hvd1RyYW5zZm9ybWVkIiwic2hvd1RyYW5zZm9ybWVkQm94Iiwic2hvd0JCIiwiYmluYXJpemVJbWFnZSIsInplcm9Cb3JkZXIiLCJzaG93IiwiZmluZFBhdGNoZXMiLCJtb21lbnRzIiwicGF0Y2hlc0ZvdW5kIiwicmFzdGVyaXplciIsInJhc3RlclJlc3VsdCIsInNrZWxldG9uaXplIiwiUmFzdGVyaXplciIsInJhc3Rlcml6ZSIsInNob3dMYWJlbHMiLCJvdmVybGF5IiwiZGVzY3JpYmVQYXRjaCIsInNob3dGb3VuZFBhdGNoZXMiLCJmaW5kQmlnZ2VzdENvbm5lY3RlZEFyZWFzIiwibWF4TGFiZWwiLCJsYWJlbEhpc3QiLCJ0b3BMYWJlbHMiLCJlbCIsImZpbmRCb3hlcyIsImJveGVzIiwic2hvd1JlbWFpbmluZ1BhdGNoTGFiZWxzIiwic2ltaWxhck1vbWVudHMiLCJ0b3BDbHVzdGVyIiwic3ViSW1hZ2VBc0NvcHkiLCJzaG93U2tlbGV0b24iLCJwYXRjaFBvcyIsImVsaWdpYmxlTW9tZW50cyIsIm1hdGNoaW5nTW9tZW50cyIsIm1pbkNvbXBvbmVudFdlaWdodCIsInJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5IiwiY3VycklkeCIsIm5vdFlldFByb2Nlc3NlZCIsImN1cnJlbnRJZHgiLCJjdXJyZW50UGF0Y2giLCJzaG93UGF0Y2hMYWJlbHMiLCJpbnB1dEltYWdlV3JhcHBlciIsImxvY2F0ZSIsImNoZWNrSW1hZ2VDb25zdHJhaW50cyIsImlucHV0U3RyZWFtIiwiZ2V0V2lkdGgiLCJnZXRIZWlnaHQiLCJ0aGlzSGFsZlNhbXBsZSIsImdldENvbmZpZyIsInNldFRvcFJpZ2h0Iiwic2V0Q2FudmFzU2l6ZSIsImNvbnNvbGUiLCJsb2ciLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0V2lkdGgiLCJzZXRIZWlnaHQiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhZnRlclRpY2tPbmUiLCJhZnRlclRpY2tUd28iLCJhZnRlclRpY2tUaHJlZSIsImFmdGVyVGljayIsImFycmF5V2l0aEhvbGVzIiwiaXRlcmFibGVUb0FycmF5TGltaXQiLCJ1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm5vbkl0ZXJhYmxlUmVzdCIsIl9zbGljZWRUb0FycmF5IiwiYXJyYXlXaXRob3V0SG9sZXMiLCJpdGVyYWJsZVRvQXJyYXkiLCJub25JdGVyYWJsZVNwcmVhZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFzeW5jR2VuZXJhdG9yU3RlcCIsImdlbiIsIl9uZXh0IiwiX3Rocm93IiwiaW5mbyIsImVycm9yIiwidGhlbiIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZGV0ZXJtaW5hbnQiLCJ0cmFuc3Bvc2UiLCJhZGpvaW50IiwiZnJvYiIsImxkdSIsImlvdGEiLCJoYXNUeXBlZEFycmF5cyIsIkZsb2F0NjRBcnJheSIsImNvbXBhcmUxc3QiLCJzdHJpZGUiLCJ0ZXJtcyIsImNvbXBpbGVDb25zdHJ1Y3RvciIsImR0eXBlIiwidXNlR2V0dGVycyIsInByb2NlZHVyZSIsIkNBQ0hFRF9DT05TVFJVQ1RPUlMiLCJpbmRpY2VzIiwiaW5kZXhfc3RyIiwic2hhcGVBcmciLCJzdHJpZGVBcmciLCJhX3ZhcnMiLCJjX3ZhcnMiLCJ0U2hhcGUiLCJ0U3RyaWRlIiwiYXJyYXlEVHlwZSIsIndyYXBwZWROREFycmF5Q3RvciIsInNoYXBlIiwic3oiLCJjdG9yX2xpc3QiLCJSIiwiUmVmbGVjdEFwcGx5IiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIlByb2Nlc3NFbWl0V2FybmluZyIsIndhcm5pbmciLCJ3YXJuIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJzZXRNYXhMaXN0ZW5lcnMiLCJfZ2V0TWF4TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwiZG9FcnJvciIsImV2ZW50cyIsImVyIiwiaGFuZGxlciIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsIndhcm5lZCIsInciLCJlbWl0dGVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwib3JpZ2luYWxMaXN0ZW5lciIsInNoaWZ0Iiwic3BsaWNlT25lIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsIlN0cmVhbSIsIlRyYW5zZm9ybSIsIlBhc3NUaHJvdWdoIiwiY29weVByb3BzIiwiU2FmZUJ1ZmZlciIsIldyaXRlUmVxIiwiQ29ya2VkUmVxdWVzdCIsIl90aGlzIiwiZmluaXNoIiwib25Db3JrZWRGaW5pc2giLCJhc3luY1dyaXRlIiwic2V0SW1tZWRpYXRlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlc3Ryb3lJbXBsIiwibm9wIiwic3RyZWFtIiwiaXNEdXBsZXgiLCJvYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwiaHdtIiwid3JpdGFibGVId20iLCJ3cml0YWJsZUhpZ2hXYXRlck1hcmsiLCJkZWZhdWx0SHdtIiwiZmluYWxDYWxsZWQiLCJuZWVkRHJhaW4iLCJlbmRpbmciLCJmaW5pc2hlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsImRlZmF1bHRFbmNvZGluZyIsIndyaXRpbmciLCJjb3JrZWQiLCJzeW5jIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJ3cml0ZWNiIiwid3JpdGVsZW4iLCJidWZmZXJlZFJlcXVlc3QiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwicGVuZGluZ2NiIiwicHJlZmluaXNoZWQiLCJlcnJvckVtaXR0ZWQiLCJidWZmZXJlZFJlcXVlc3RDb3VudCIsImNvcmtlZFJlcXVlc3RzRnJlZSIsImdldEJ1ZmZlciIsInJlYWxIYXNJbnN0YW5jZSIsImhhc0luc3RhbmNlIiwiX3dyaXRlIiwid3JpdGV2IiwiX3dyaXRldiIsImRlc3Ryb3kiLCJmaW5hbCIsIl9maW5hbCIsInBpcGUiLCJ3cml0ZUFmdGVyRW5kIiwidmFsaWRDaHVuayIsInZhbGlkIiwiaXNCdWYiLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsImNsZWFyQnVmZmVyIiwic2V0RGVmYXVsdEVuY29kaW5nIiwiZGVjb2RlQ2h1bmsiLCJuZXdDaHVuayIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwicHJlZmluaXNoIiwibmVlZCIsImNvcmtSZXEiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95IiwiYXJyYXlMaWtlVG9BcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwiRmxvYXQzMkFycmF5IiwieiIsIlJlYWRhYmxlU3RhdGUiLCJFRSIsIkVFbGlzdGVuZXJDb3VudCIsImRlYnVnVXRpbCIsImRlYnVnbG9nIiwiQnVmZmVyTGlzdCIsIlN0cmluZ0RlY29kZXIiLCJrUHJveHlFdmVudHMiLCJldmVudCIsInJlYWRhYmxlT2JqZWN0TW9kZSIsInJlYWRhYmxlSHdtIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwibmVlZFJlYWRhYmxlIiwiZW1pdHRlZFJlYWRhYmxlIiwicmVhZGFibGVMaXN0ZW5pbmciLCJyZXN1bWVTY2hlZHVsZWQiLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiX3JlYWQiLCJza2lwQ2h1bmtDaGVjayIsInJlYWRhYmxlQWRkQ2h1bmsiLCJhZGRUb0Zyb250Iiwib25Fb2ZDaHVuayIsImNodW5rSW52YWxpZCIsImFkZENodW5rIiwibWF5YmVSZWFkTW9yZSIsIm5lZWRNb3JlRGF0YSIsImVtaXRSZWFkYWJsZSIsImlzUGF1c2VkIiwic2V0RW5jb2RpbmciLCJlbmMiLCJNQVhfSFdNIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJob3dNdWNoVG9SZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsIm1heWJlUmVhZE1vcmVfIiwiZGVzdCIsInBpcGVPcHRzIiwiZG9FbmQiLCJzdGRvdXQiLCJzdGRlcnIiLCJlbmRGbiIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJjbGVhbnVwIiwib25kcmFpbiIsInBpcGVPbkRyYWluIiwiY2xlYW5lZFVwIiwib25jbG9zZSIsIm9uZmluaXNoIiwib25lcnJvciIsIm9uZGF0YSIsImluY3JlYXNlZEF3YWl0RHJhaW4iLCJwYXVzZSIsInJlc3VtZSIsImRlc3RzIiwiZXYiLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsInBhdXNlZCIsIl9mcm9tTGlzdCIsImZyb21MaXN0UGFydGlhbCIsImhhc1N0cmluZ3MiLCJjb3B5RnJvbUJ1ZmZlclN0cmluZyIsImNvcHlGcm9tQnVmZmVyIiwibmIiLCJlbmRSZWFkYWJsZU5UIiwieHMiLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwiYWZ0ZXJUcmFuc2Zvcm0iLCJ0cyIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwiX3RyYW5zZm9ybSIsIl9mbHVzaCIsIl90aGlzMiIsImVycjIiLCJDVlV0aWxzIiwiTmRhcnJheSIsIkludGVycDJEIiwiZDIiLCJGcmFtZUdyYWJiZXIiLCJfdGhhdCIsIl92aWRlb1NpemUiLCJnZXRSZWFsV2lkdGgiLCJnZXRSZWFsSGVpZ2h0IiwiX2NhbnZhc1NpemUiLCJnZXRDYW52YXNTaXplIiwiX3NpemUiLCJfdG9wUmlnaHQiLCJnZXRUb3BSaWdodCIsIl9kYXRhIiwiX2dyYXlEYXRhIiwiX2NhbnZhc0RhdGEiLCJfZ3JheUltYWdlQXJyYXkiLCJfY2FudmFzSW1hZ2VBcnJheSIsIl90YXJnZXRJbWFnZUFycmF5IiwiX3N0ZXBTaXplWCIsIl9zdGVwU2l6ZVkiLCJ2aWRlb1NpemUiLCJjYW52YXNTaXplIiwic3RlcFNpemUiLCJ0b3BSaWdodCIsImF0dGFjaERhdGEiLCJncmFiIiwiZ2V0RnJhbWUiLCJzY2FsZUFuZENyb3AiLCJnZXRTaXplIiwiYW5nbGUiLCJ0cmFuc2Zvcm1RdWF0Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwiY3JlYXRlQ29udG91cjJEIiwiZmlyc3RWZXJ0ZXgiLCJpbnNpZGVDb250b3VycyIsIm5leHRwZWVyIiwicHJldnBlZXIiLCJDT05UT1VSX0RJUiIsIkNXX0RJUiIsIkNDV19ESVIiLCJVTktOT1dOX0RJUiIsIkRJUiIsIk9VVFNJREVfRURHRSIsIklOU0lERV9FREdFIiwidHJhY2VyIiwiZGVwdGhsYWJlbCIsImJjIiwibGMiLCJsYWJlbGluZGV4IiwiY29sb3JNYXAiLCJ2ZXJ0ZXgiLCJjYyIsInNjIiwiY29ubmVjdGVkQ291bnQiLCJkcmF3Q29udG91ciIsImZpcnN0Q29udG91ciIsInBxIiwiaXEiLCJxIiwiU2tlbGV0b25pemVyIiwic3RkbGliIiwiZm9yZWlnbiIsImltYWdlcyIsImltdWwiLCJpbkltYWdlUHRyIiwib3V0SW1hZ2VQdHIiLCJhSW1hZ2VQdHIiLCJiSW1hZ2VQdHIiLCJpbWFnZVB0ciIsIm1lbWNweSIsInNyY0ltYWdlUHRyIiwiZHN0SW1hZ2VQdHIiLCJzdWJJbWFnZVB0ciIsImVyb2RlZEltYWdlUHRyIiwidGVtcEltYWdlUHRyIiwic2tlbEltYWdlUHRyIiwibmRhcnJheSIsIkdpZlJlYWRlciIsInBhY2siLCJ0aHJvdWdoIiwicGFyc2VEYXRhVVJJIiwiZGVmYXVsdEltYWdlIiwidXJsIiwiY3Jvc3NPcmlnaW4iLCJwaXhlbHMiLCJoYW5kbGVHaWYiLCJyZWFkZXIiLCJudW1GcmFtZXMiLCJuc2hhcGUiLCJuZGF0YSIsImRlY29kZUFuZEJsaXRGcmFtZVJHQkEiLCJodHRwR2lmIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwib3ZlcnJpZGVNaW1lVHlwZSIsInJlYWR5U3RhdGUiLCJyZXNwb25zZSIsInNlbmQiLCJjb3B5QnVmZmVyIiwiZGF0YUdpZiIsImdldFBpeGVscyIsImV4dG5hbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJvUmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhaCIsImFsIiwiYmgiLCJibCIsIm5leHRTb3VyY2UiLCJuZXh0S2V5IiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX24iLCJfZCIsIl9lIiwiX2kiLCJfcyIsIl9ub25JdGVyYWJsZVJlc3QiLCJhMCIsImExIiwiYjAiLCJiMSIsInQiLCJheCIsImF5IiwibVNxIiwidGVtcEEiLCJ0ZW1wQiIsImNvc2luZSIsImFjb3MiLCJhMiIsImIyIiwiYXoiLCJieCIsImJ5IiwiYnoiLCJ6U2NhbGUiLCJxeCIsInF5IiwicXoiLCJxdyIsIml4IiwiaXkiLCJpeiIsIml3IiwicHkiLCJweiIsIl9zZXRQcm90b3R5cGVPZiIsIndlYnBhY2tQb2x5ZmlsbCIsImNoaWxkcmVuIiwiX2FycmF5V2l0aG91dEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheSIsIml0ZXIiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJfc3VwZXJQcm9wQmFzZSIsInJ1bnRpbWUiLCJPcCIsImhhc093biIsIiRTeW1ib2wiLCJpdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3JTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwidG9TdHJpbmdUYWdTeW1ib2wiLCJpbm5lckZuIiwib3V0ZXJGbiIsInRyeUxvY3NMaXN0IiwicHJvdG9HZW5lcmF0b3IiLCJHZW5lcmF0b3IiLCJnZW5lcmF0b3IiLCJDb250ZXh0IiwiX2ludm9rZSIsIm1ha2VJbnZva2VNZXRob2QiLCJ0cnlDYXRjaCIsIkdlblN0YXRlU3VzcGVuZGVkU3RhcnQiLCJHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkIiwiR2VuU3RhdGVFeGVjdXRpbmciLCJHZW5TdGF0ZUNvbXBsZXRlZCIsIkNvbnRpbnVlU2VudGluZWwiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJnZXRQcm90byIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJtYXJrIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwicmVjb3JkIiwidW53cmFwcGVkIiwicHJldmlvdXNQcm9taXNlIiwiZW5xdWV1ZSIsImNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnIiwiYXN5bmMiLCJkb25lUmVzdWx0IiwiZGVsZWdhdGUiLCJkZWxlZ2F0ZVJlc3VsdCIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwibG9jcyIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInJlc2V0VHJ5RW50cnkiLCJjb21wbGV0aW9uIiwicmVzZXQiLCJpdGVyYXRvck1ldGhvZCIsInNraXBUZW1wUmVzZXQiLCJzdG9wIiwicm9vdEVudHJ5Iiwicm9vdFJlY29yZCIsInJ2YWwiLCJleGNlcHRpb24iLCJoYW5kbGUiLCJsb2MiLCJjYXVnaHQiLCJoYXNDYXRjaCIsImhhc0ZpbmFsbHkiLCJmaW5hbGx5RW50cnkiLCJjb21wbGV0ZSIsInRocm93biIsImRlbGVnYXRlWWllbGQiLCJyZWdlbmVyYXRvclJ1bnRpbWUiLCJhY2NpZGVudGFsU3RyaWN0TW9kZSIsImEzIiwiYjMiLCJkZXQiLCJ2MCIsInYxIiwiTCIsIlUiLCJsb29rdXAiLCJyZXZMb29rdXAiLCJBcnIiLCJnZXRMZW5zIiwiYjY0IiwidmFsaWRMZW4iLCJwbGFjZUhvbGRlcnNMZW4iLCJsZW5zIiwiX2J5dGVMZW5ndGgiLCJjdXJCeXRlIiwidHJpcGxldFRvQmFzZTY0IiwibnVtIiwiZW5jb2RlQ2h1bmsiLCJ1aW50OCIsIm91dHB1dCIsImV4dHJhQnl0ZXMiLCJwYXJ0cyIsIm1heENodW5rTGVuZ3RoIiwibGVuMiIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiTmFOIiwicnQiLCJMTjIiLCJub3JtYWxpemVBcnJheSIsImFsbG93QWJvdmVSb290IiwidXAiLCJyZXNvbHZlZFBhdGgiLCJyZXNvbHZlZEFic29sdXRlIiwiaXNBYnNvbHV0ZSIsInRyYWlsaW5nU2xhc2giLCJyZWxhdGl2ZSIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInNlcCIsImRlbGltaXRlciIsImRpcm5hbWUiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJmIiwic3RhcnREb3QiLCJzdGFydFBhcnQiLCJwcmVEb3RTdGF0ZSIsImlzU2xvd0J1ZmZlciIsIkdpZldyaXRlciIsImdvcHRzIiwibG9vcF9jb3VudCIsImxvb3AiLCJnbG9iYWxfcGFsZXR0ZSIsInBhbGV0dGUiLCJjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzIiwibnVtX2NvbG9ycyIsImdwX251bV9jb2xvcnNfcG93MiIsImJhY2tncm91bmQiLCJncF9udW1fY29sb3JzIiwiaWwiLCJhZGRGcmFtZSIsImluZGV4ZWRfcGl4ZWxzIiwib3B0cyIsInVzaW5nX2xvY2FsX3BhbGV0dGUiLCJtaW5fY29kZV9zaXplIiwiZGlzcG9zYWwiLCJ1c2VfdHJhbnNwYXJlbmN5IiwidHJhbnNwYXJlbnRfaW5kZXgiLCJ0cmFuc3BhcmVudCIsIkdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0iLCJnZXRPdXRwdXRCdWZmZXIiLCJzZXRPdXRwdXRCdWZmZXIiLCJnZXRPdXRwdXRCdWZmZXJQb3NpdGlvbiIsInNldE91dHB1dEJ1ZmZlclBvc2l0aW9uIiwiaW5kZXhfc3RyZWFtIiwiY3VyX3N1YmJsb2NrIiwiY2xlYXJfY29kZSIsImNvZGVfbWFzayIsImVvaV9jb2RlIiwibmV4dF9jb2RlIiwiY3VyX2NvZGVfc2l6ZSIsImN1cl9zaGlmdCIsImN1ciIsImVtaXRfYnl0ZXNfdG9fYnVmZmVyIiwiYml0X2Jsb2NrX3NpemUiLCJlbWl0X2NvZGUiLCJpYl9jb2RlIiwiY29kZV90YWJsZSIsImN1cl9rZXkiLCJjdXJfY29kZSIsInBmMCIsImdsb2JhbF9wYWxldHRlX2ZsYWciLCJudW1fZ2xvYmFsX2NvbG9yc19wb3cyIiwibnVtX2dsb2JhbF9jb2xvcnMiLCJnbG9iYWxfcGFsZXR0ZV9vZmZzZXQiLCJnbG9iYWxfcGFsZXR0ZV9zaXplIiwibm9fZW9mIiwiZnJhbWVzIiwiYmxvY2tfc2l6ZSIsInBmMSIsInBmMiIsImxvY2FsX3BhbGV0dGVfZmxhZyIsImludGVybGFjZV9mbGFnIiwibnVtX2xvY2FsX2NvbG9yc19wb3cyIiwibnVtX2xvY2FsX2NvbG9ycyIsInBhbGV0dGVfb2Zmc2V0IiwicGFsZXR0ZV9zaXplIiwiaGFzX2xvY2FsX3BhbGV0dGUiLCJkYXRhX29mZnNldCIsImRhdGFfbGVuZ3RoIiwiaW50ZXJsYWNlZCIsImxvb3BDb3VudCIsImZyYW1lSW5mbyIsImZyYW1lX251bSIsImRlY29kZUFuZEJsaXRGcmFtZUJHUkEiLCJudW1fcGl4ZWxzIiwiR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0iLCJ0cmFucyIsImZyYW1ld2lkdGgiLCJmcmFtZXN0cmlkZSIsInhsZWZ0Iiwib3BiZWciLCJvcGVuZCIsIm9wIiwic2NhbnN0cmlkZSIsImludGVybGFjZXNraXAiLCJjb2RlX3N0cmVhbSIsIm91dHB1dF9sZW5ndGgiLCJzdWJibG9ja19zaXplIiwicHJldl9jb2RlIiwiY2hhc2VfY29kZSIsImNoYXNlX2xlbmd0aCIsImNoYXNlIiwib3BfZW5kIiwiZG9fY29udmVydCIsImNyZWF0ZVRodW5rIiwiUHJvY2VkdXJlIiwiYXJnVHlwZXMiLCJzaGltQXJncyIsImFycmF5QXJncyIsImFycmF5QmxvY2tJbmRpY2VzIiwic2NhbGFyQXJncyIsIm9mZnNldEFyZ3MiLCJvZmZzZXRBcmdJbmRleCIsImluZGV4QXJncyIsInNoYXBlQXJncyIsInByZSIsImJvZHkiLCJwb3N0IiwiY29tcGlsZUN3aXNlIiwidXNlcl9hcmdzIiwicHJvYyIsInByb2NfYXJncyIsImFyZ190eXBlIiwiYmxvY2tJbmRpY2VzIiwibHZhbHVlIiwicHJpbnRDb2RlIiwiYmxvY2tTaXplIiwiY29tcGlsZSIsInZhcnMiLCJ0aHVua05hbWUiLCJ0eXBlc2lnIiwic3RyaW5nX3R5cGVzaWciLCJzaGFwZUxlbmd0aENvbmRpdGlvbnMiLCJzaGFwZUNvbmRpdGlvbnMiLCJ0aHVuayIsImlubmVyRmlsbCIsIm5hcmdzIiwiaGFzX2luZGV4IiwicGlkeCIsIm91dGVyRmlsbCIsIm1hdGNoZWQiLCJpbmRleFN0ciIsImNvdW50TWF0Y2hlcyIsInByb2Nlc3NCbG9jayIsImJsb2NrIiwiZHR5cGVzIiwiY2FyZyIsInB0clN0ciIsImFyck51bSIsIm9mZkFyZ0luZGV4Iiwib2ZmQXJnIiwibG9jYWxTdHIiLCJhcnJTdHIiLCJyZVN0ckFyciIsInB0clN0ckFyciIsInR5cGVTdW1tYXJ5Iiwic3VtbWFyeSIsImFsbEVxdWFsIiwiZGlnaXRzIiwiZ2VuZXJhdGVDV2lzZU9wIiwiYmxvY2tCZWdpbiIsImJsb2NrRW5kIiwibG9vcEJlZ2luIiwibG9vcEVuZCIsImxvb3BPcmRlcnMiLCJuZXdPcmRlciIsImFyZ2xpc3QiLCJ6ZXJvcyIsIm9mZl9hcmciLCJpbml0X3N0cmluZyIsInRoaXNWYXJzIiwibG9vcE5hbWUiLCJ1bmlxdWVfcHJlZCIsInB0ciIsInVuaXF1ZV9lcSIsInVuaXF1ZSIsInNvcnRlZCIsIl9lbmRlZCIsImF1dG9EZXN0cm95IiwiZHJhaW4iLCJfZW5kIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsImN1c3RvbSIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJyZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0IiwiY2xlYXJJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsInJ1bklmUHJlc2VudCIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsIm1zZyIsImRlcHJlY2F0ZWQiLCJsb2NhbFN0b3JhZ2UiLCJkYXRhVXJpVG9CdWZmZXIiLCJ1cmkiLCJmaXJzdENvbW1hIiwibWV0YSIsImNoYXJzZXQiLCJpbnRlcnAxZCIsImZ4IiwiczAiLCJzMSIsIncwIiwidzEiLCJpbnRlcnAyZCIsImZ5IiwidDAiLCJ0MSIsIncwMCIsIncwMSIsIncxMCIsIncxMSIsImludGVycDNkIiwiZnoiLCJ1MCIsInUxIiwidzAwMCIsIncwMTAiLCJ3MTAwIiwidzExMCIsIncwMDEiLCJ3MDExIiwidzEwMSIsIncxMTEiLCJpbnRlcnBOZCIsImlfbG9vcCIsImQxIiwiZDMiLCJCcmVzZW5oYW0iLCJTbG9wZSIsIlVQIiwiRE9XTiIsImdldEJhcmNvZGVMaW5lIiwieDAiLCJ5MCIsIngxIiwieTEiLCJzdGVlcCIsImRlbHRhWCIsImRlbHRhWSIsInlTdGVwIiwidG9CaW5hcnlMaW5lIiwic2xvcGUiLCJzbG9wZTIiLCJleHRyZW1hIiwiY3VycmVudERpciIsInJUaHJlc2hvbGQiLCJwcmludEZyZXF1ZW5jeSIsInByaW50UGF0dGVybiIsImZpbGxDb2xvciIsImZpbGxSZWN0IiwiQmFyY29kZURpcmVjdGlvbiIsIkJhcmNvZGVSZWFkZXIiLCJTdGFydE5vdEZvdW5kRXhjZXB0aW9uIiwiQ29kZU5vdEZvdW5kRXhjZXB0aW9uIiwiUGF0dGVybk5vdEZvdW5kRXhjZXB0aW9uIiwic3VwcGxlbWVudHMiLCJfcm93IiwiY291bnRlciIsIm1heFNpbmdsZUVycm9yIiwic2luZ2xlRXJyb3IiLCJtb2R1bG8iLCJiYXJXaWR0aCIsInNjYWxlZCIsIlNJTkdMRV9DT0RFX0VSUk9SIiwiY29ycmVjdGlvbiIsIl9kZWNvZGUiLCJkaXJlY3Rpb24iLCJSZXZlcnNlIiwiRm9yd2FyZCIsImZvcm1hdCIsIkZPUk1BVCIsIl9uZXh0VW5zZXQiLCJpc1doaXRlIiwiY291bnRlcnMiLCJjb3VudGVyUG9zIiwibnVtQ291bnRlcnMiLCJDb2RlMTI4UmVhZGVyIiwiYmFyIiwic3BhY2UiLCJiZXN0TWF0Y2giLCJfY29ycmVjdCIsIkNPREVfUEFUVEVSTiIsIl9tYXRjaFBhdHRlcm4iLCJBVkdfQ09ERV9FUlJPUiIsImNhbGN1bGF0ZUNvcnJlY3Rpb24iLCJNT0RVTEVfSU5ESUNFUyIsIl9jb3JyZWN0QmFycyIsIl9uZXh0U2V0IiwiU1RBUlRfQ09ERV9BIiwiU1RBUlRfQ09ERV9DIiwic3RhcnRJbmZvIiwiX2ZpbmRTdGFydCIsImRlY29kZWRDb2RlcyIsImNoZWNrc3VtIiwiY29kZXNldCIsIkNPREVfQSIsIlNUQVJUX0NPREVfQiIsIkNPREVfQiIsIkNPREVfQyIsInNoaWZ0TmV4dCIsInJlbW92ZUxhc3RDaGFyYWN0ZXIiLCJyYXdSZXN1bHQiLCJfZGVjb2RlQ29kZSIsIlNUT1BfQ09ERSIsIkNPREVfU0hJRlQiLCJfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlIiwiZW5kSW5mbyIsInRyYWlsaW5nV2hpdGVzcGFjZUVuZCIsIl9tYXRjaFJhbmdlIiwiZXhwZWN0ZWQiLCJub3JtYWxpemVkIiwic3VtTm9ybWFsaXplZCIsInN1bUV4cGVjdGVkIiwiQ09ERV9HX1NUQVJUIiwiU1RBUlRfUEFUVEVSTiIsIk1JRERMRV9QQVRURVJOIiwiRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4iLCJDT0RFX0ZSRVFVRU5DWSIsIkVBTlJlYWRlciIsInRyeUhhcmRlciIsImVwc2lsb24iLCJjb2RlcmFuZ2UiLCJfZmluZFBhdHRlcm4iLCJsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0IiwiY29kZUZyZXF1ZW5jeSIsImluQ29kZSIsIm91dENvZGUiLCJmaXJzdERpZ2l0IiwiX2NhbGN1bGF0ZUZpcnN0RGlnaXQiLCJtaWRkbGVQYXR0ZXJuIiwiU1RPUF9QQVRURVJOIiwicmVzdWx0SW5mbyIsIl9kZWNvZGVQYXlsb2FkIiwiX2ZpbmRFbmQiLCJfY2hlY2tzdW0iLCJzdXBwbGVtZW50IiwiX2RlY29kZUV4dGVuc2lvbnMiLCJsYXN0Q29kZSIsIkFMUEhBQkVUSF9TVFJJTkciLCJBTFBIQUJFVCIsIlVpbnQxNkFycmF5IiwiY2hhciIsIkNIQVJBQ1RFUl9FTkNPRElOR1MiLCJBU1RFUklTSyIsIkNvZGUzOVJlYWRlciIsInBhdHRlcm5TdGFydCIsIl90b1BhdHRlcm4iLCJ3aGl0ZVNwYWNlTXVzdFN0YXJ0IiwibWF4TmFycm93V2lkdGgiLCJudW1XaWRlQmFycyIsIndpZGVCYXJXaWR0aCIsIl9maW5kTmV4dFdpZHRoIiwibWluV2lkdGgiLCJsYXN0U3RhcnQiLCJuZXh0U3RhcnQiLCJwYXR0ZXJuU2l6ZSIsImRlY29kZWRDaGFyIiwiX3RvQ291bnRlcnMiLCJfcGF0dGVyblRvQ2hhciIsInBhdHRlcm5zIiwiSU9RIiwiQVowOSIsIkNvZGUzOVZJTlJlYWRlciIsIl9jaGVja0NoZWNrc3VtIiwiU1RBUlRfRU5EIiwiTUlOX0VOQ09ERURfQ0hBUlMiLCJNQVhfQUNDRVBUQUJMRSIsIlBBRERJTkciLCJOZXdDb2RhYmFyUmVhZGVyIiwiX2NvdW50ZXJzIiwiYmFyVGhyZXNob2xkIiwiX2NvbXB1dGVBbHRlcm5hdGluZ1RocmVzaG9sZCIsInNwYWNlVGhyZXNob2xkIiwiX2lzU3RhcnRFbmQiLCJfc3VtQ291bnRlcnMiLCJzdGFydENvdW50ZXIiLCJlbmRDb3VudGVyIiwiX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgiLCJjaGFyQ29kZSIsImNhdGVnb3JpemF0aW9uIiwibmFycm93IiwiY291bnRzIiwid2lkZSIsIl9jaGFyVG9QYXR0ZXJuIiwia2luZCIsImNhdCIsIm5ld2tpbmQiLCJ0aHJlc2hvbGRzIiwiX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4iLCJfZmlsbENvdW50ZXJzIiwiX3ZlcmlmeVdoaXRlc3BhY2UiLCJfdmFsaWRhdGVSZXN1bHQiLCJVUENSZWFkZXIiLCJFQU44UmVhZGVyIiwiRUFOMlJlYWRlciIsIkNIRUNLX0RJR0lUX0VOQ09ESU5HUyIsImRldGVybWluZUNoZWNrRGlnaXQiLCJleHRlbnNpb25DaGVja3N1bSIsIkVBTjVSZWFkZXIiLCJVUENFUmVhZGVyIiwiX2RldGVybWluZVBhcml0eSIsIm5yU3lzdGVtIiwidXBjYSIsImxhc3REaWdpdCIsIl9jb252ZXJ0VG9VUENBIiwiTiIsIlciLCJJMm9mNVJlYWRlciIsIm5vcm1hbGl6ZUJhclNwYWNlV2lkdGgiLCJjb3VudGVyU3VtIiwiY29kZVN1bSIsImNvcnJlY3Rpb25SYXRpbyIsIk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUiIsImNvcnJlY3Rpb25SYXRpb0ludmVyc2UiLCJiYXJTcGFjZVJhdGlvIiwibmFycm93QmFyV2lkdGgiLCJjb3VudGVyUGFpciIsImNvZGVzIiwiY291bnRlckxlbmd0aCIsIl9kZWNvZGVQYWlyIiwiX3ZlcmlmeUNvdW50ZXJMZW5ndGgiLCJTVEFSVF9QQVRURVJOX0xFTkdUSCIsIlR3b09mRml2ZVJlYWRlciIsIkNvZGU5M1JlYWRlciIsImNoYXJBcnJheSIsIm5leHRDaGFyIiwibmV4dENoYXJDb2RlIiwibWF4V2VpZ2h0IiwiYXJyYXlUb0NoZWNrIiwid2VpZ2h0ZWRTdW1zIiwid2VpZ2h0IiwiY2hlY2tDaGFyIiwiX21hdGNoQ2hlY2tDaGFyIiwiX3ZlcmlmeUVuZCIsIl92ZXJpZnlDaGVja3N1bXMiLCJfZGVjb2RlRXh0ZW5kZWQiLCJBRUlPIiwicGxhaW50ZXh0Y29kZSIsIkNvZGUzMlJlYWRlciIsIm5ld19jb2RlIiwiY29kZV9maW5hbCIsImNoYXJfY29kZSIsInNlYXJjaF9kaWdpdF9jb2RlIiwiY2hhcmFjdGVyX2NvZGUiLCJkaWdpdF9jb2RlIiwiZXhwb25lbnRfbnVtYmVyIiwiY29kZV9kaWZmX2xlbmd0aCIsIlJFQURFUlMiLCJjb2RlXzEyOF9yZWFkZXIiLCJlYW5fcmVhZGVyIiwiZWFuXzVfcmVhZGVyIiwiZWFuXzJfcmVhZGVyIiwiZWFuXzhfcmVhZGVyIiwiY29kZV8zOV9yZWFkZXIiLCJjb2RlXzM5X3Zpbl9yZWFkZXIiLCJjb2RhYmFyX3JlYWRlciIsIkNvZGFiYXJSZWFkZXIiLCJ1cGNfcmVhZGVyIiwidXBjX2VfcmVhZGVyIiwiaTJvZjVfcmVhZGVyIiwiY29kZV85M19yZWFkZXIiLCJjb2RlXzMyX3JlYWRlciIsInJlZ2lzdGVyUmVhZGVyIiwiX2NhbnZhcyIsImZyZXF1ZW5jeSIsIl9iYXJjb2RlUmVhZGVycyIsImluaXRSZWFkZXJzIiwiaW5pdENvbmZpZyIsIiRkZWJ1ZyIsInJlYWRlcnMiLCJyZWFkZXJDb25maWciLCJjb25maWd1cmF0aW9uIiwicmVhZGVyT2JqIiwidmlzIiwibm9kZSIsInNob3dGcmVxdWVuY3kiLCJzaG93UGF0dGVybiIsImRpc3BsYXkiLCJnZXRFeHRlbmRlZExpbmUiLCJleHRlbmRMaW5lIiwiYW1vdW50IiwiZXh0ZW5zaW9uIiwiaW5JbWFnZVdpdGhCb3JkZXIiLCJnZXRMaW5lIiwidHJ5RGVjb2RlIiwiYmFyY29kZUxpbmUiLCJkZWNvZGVQYXR0ZXJuIiwiY29kZVJlc3VsdCIsInRyeURlY29kZUJydXRlRm9yY2UiLCJsaW5lQW5nbGUiLCJzaWRlTGVuZ3RoIiwic2xpY2VzIiwieGRpciIsInlkaXIiLCJnZXRMaW5lTGVuZ3RoIiwiZGVjb2RlRnJvbUltYWdlIiwiZGVjb2RlSW1hZ2UiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3giLCJkcmF3Qm91bmRpbmdCb3giLCJsaW5lTGVuZ3RoIiwiYXRhbjIiLCJkcmF3U2NhbmxpbmUiLCJkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyIsImJhcmNvZGVzIiwibXVsdGlwbGUiLCJzZXRSZWFkZXJzIiwiRXZlbnRJbnRlcmZhY2UiLCJnZXRFdmVudCIsImV2ZW50TmFtZSIsInN1YnNjcmliZXJzIiwiY2xlYXJFdmVudHMiLCJwdWJsaXNoU3Vic2NyaXB0aW9uIiwic3Vic2NyaXB0aW9uIiwiX3N1YnNjcmliZSIsInN1YnNjcmliZSIsInB1Ymxpc2giLCJzdWJzY3JpYmVyIiwidW5zdWJzY3JpYmUiLCJlbnVtZXJhdGVEZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiY29uc3RyYWludHMiLCJzdHJlYW1SZWYiLCJ3YWl0Rm9yVmlkZW8iLCJ2aWRlbyIsImF0dGVtcHRzIiwiY2hlY2tWaWRlbyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImluaXRDYW1lcmEiLCJzZXRBdHRyaWJ1dGUiLCJzcmNPYmplY3QiLCJwbGF5IiwiZGVwcmVjYXRlZENvbnN0cmFpbnRzIiwidmlkZW9Db25zdHJhaW50cyIsIm1pbkFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJmYWNpbmciLCJmYWNpbmdNb2RlIiwicGlja0NvbnN0cmFpbnRzIiwiZGV2aWNlSWQiLCJhdWRpbyIsImVudW1lcmF0ZVZpZGVvRGV2aWNlcyIsImRldmljZXMiLCJkZXZpY2UiLCJnZXRBY3RpdmVUcmFjayIsInRyYWNrcyIsImdldFZpZGVvVHJhY2tzIiwiUXVhZ2dhSlNDYW1lcmFBY2Nlc3MiLCJyZXF1ZXN0IiwibmV3Q29uc3RyYWludHMiLCJyZWxlYXNlIiwiZ2V0QWN0aXZlU3RyZWFtTGFiZWwiLCJ0cmFjayIsImNvbnRhaW5zIiwicGFzc2VzRmlsdGVyIiwicmVzdWx0cyIsImNhcGFjaXR5IiwiY2FwdHVyZSIsIm1hdGNoZXNDb25zdHJhaW50cyIsImJsYWNrbGlzdCIsImFkZFJlc3VsdCIsImltYWdlU2l6ZSIsInRvRGF0YVVSTCIsImdldFJlc3VsdHMiLCJEZXZDb25maWciLCJudW1PZldvcmtlcnMiLCJsb2NhdG9yIiwiTm9kZUNvbmZpZyIsInNlcXVlbmNlIiwiUHJvZENvbmZpZyIsIlF1YWdnYUNvbmZpZyIsIlF1YWdnYUNvbnRleHQiLCJDYW52YXNDb250YWluZXIiLCJDYW52YXNJbmZvIiwiYm94U2l6ZSIsIkJhcmNvZGVMb2NhdG9yIiwiZ2V0Vmlld1BvcnQiLCJIVE1MRWxlbWVudCIsIm5vZGVOYW1lIiwic2VsZWN0b3IiLCJmaW5kT3JDcmVhdGVDYW52YXMiLCJnZXRDYW52YXNBbmRDb250ZXh0IiwiaW5pdENhbnZhc2VzIiwiaW1hZ2UiLCJ2aWV3cG9ydCIsImNvbnRhaW5lciIsIkV4aWZUYWdzIiwiQXZhaWxhYmxlVGFncyIsImZpbmRUYWdzSW5PYmplY3RVUkwiLCJ0YWdzIiwib2JqZWN0VVJMVG9CbG9iIiwicmVhZFRvQnVmZmVyIiwiZmluZFRhZ3NJbkJ1ZmZlciIsImJhc2U2NFRvQXJyYXlCdWZmZXIiLCJkYXRhVXJsIiwiYXRvYiIsImJsb2IiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0FycmF5QnVmZmVyIiwiaHR0cCIsIkRPTkUiLCJzdGF0dXMiLCJmaWxlIiwic2VsZWN0ZWRUYWdzIiwiZXhpZlRhZ3MiLCJzZWxlY3RlZFRhZyIsImV4aWZUYWciLCJnZXRVaW50OCIsInJlYWRFWElGRGF0YSIsImdldFVpbnQxNiIsImdldFN0cmluZ0Zyb21CdWZmZXIiLCJ0aWZmT2Zmc2V0IiwiYmlnRW5kIiwiZmlyc3RJRkRPZmZzZXQiLCJnZXRVaW50MzIiLCJyZWFkVGFncyIsInRpZmZTdGFydCIsImRpclN0YXJ0Iiwic3RyaW5ncyIsImVudHJ5T2Zmc2V0IiwicmVhZFRhZ1ZhbHVlIiwibnVtVmFsdWVzIiwib3V0c3RyIiwiSW1hZ2VMb2FkZXIiLCJsb2FkIiwiZGlyZWN0b3J5IiwiaHRtbEltYWdlc1NyY0FycmF5IiwiaHRtbEltYWdlc0FycmF5Iiwibm90TG9hZGVkIiwiYWRkSW1hZ2UiLCJsb2FkZWQiLCJsb2FkZWRJbWciLCJub3Rsb2FkZWRJbWdzIiwiaW1nTmFtZSIsImFkZE9ubG9hZEhhbmRsZXIiLCJpbnB1dFN0cmVhbUZhY3RvcnkiLCJjcmVhdGVWaWRlb1N0cmVhbSIsIl9ldmVudE5hbWVzIiwiX2V2ZW50SGFuZGxlcnMiLCJfY2FsY3VsYXRlZFdpZHRoIiwiX2NhbGN1bGF0ZWRIZWlnaHQiLCJpbml0U2l6ZSIsInNldElucHV0U3RyZWFtIiwic2V0Q3VycmVudFRpbWUiLCJib29sIiwiY2xlYXJFdmVudEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidHJpZ2dlciIsImNyZWF0ZUxpdmVTdHJlYW0iLCJjcmVhdGVJbWFnZVN0cmVhbSIsImZyYW1lSWR4IiwiaW1nQXJyYXkiLCJiYXNlVXJsIiwiY2FsY3VsYXRlZFdpZHRoIiwiY2FsY3VsYXRlZEhlaWdodCIsImxvYWRJbWFnZXMiLCJpbWdzIiwib3JpZW50YXRpb24iLCJwdWJsaXNoRXZlbnQiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImluZCIsIkdldFBpeGVscyIsIm1pbWUiLCJCcm93c2VySW5wdXRTdHJlYW0iLCJUT19SQURJQU5TIiwiYWRqdXN0Q2FudmFzU2l6ZSIsInRhcmdldFNpemUiLCJfc3RyZWFtQ29uZmlnIiwiX3N4IiwiX3N5IiwiX2N0eCIsImRvSGFsZlNhbXBsZSIsImRyYXdhYmxlIiwiZHJhd0FuZ2xlIiwidHJhbnNsYXRlIiwid29ya2VyUG9vbCIsInVwZGF0ZVdvcmtlcnMiLCJmcmFtZUdyYWJiZXIiLCJhdmFpbGFibGVXb3JrZXIiLCJ3b3JrZXJUaHJlYWQiLCJidXN5Iiwid29ya2VyIiwiY21kIiwiY29uZmlnRm9yV29ya2VyIiwid29ya2VySW50ZXJmYWNlIiwiZmFjdG9yeSIsIlF1YWdnYSIsIm9uUHJvY2Vzc2VkIiwid29ya2VySW50ZXJmYWNlUmVhZHkiLCJnZW5lcmF0ZVdvcmtlckJsb2IiLCJmYWN0b3J5U291cmNlIiwiX19mYWN0b3J5U291cmNlX18iLCJCbG9iIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiaW5pdFdvcmtlciIsImJsb2JVUkwiLCJXb3JrZXIiLCJyZXZva2VPYmplY3RVUkwiLCJhZGp1c3RXb3JrZXJQb29sIiwiaW5jcmVhc2VCeSIsIndvcmtlcnNUb1Rlcm1pbmF0ZSIsInRlcm1pbmF0ZSIsIndvcmtlckluaXRpYWxpemVkIiwic2V0dXBJbnB1dFN0cmVhbSIsIklucHV0U3RyZWFtIiwibW92ZUJveCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyIiwibW92ZUxpbmUiLCJOb2RlSW5wdXRTdHJlYW0iLCJOb2RlRnJhbWVHcmFiYmVyIiwiQnJvd3NlckZyYW1lR3JhYmJlciIsImZyYW1lZ3JhYmJlciIsImNhbnZhc0NvbnRhaW5lciIsIlFXb3JrZXJzIiwiaW5pdGlhbGl6ZURhdGEiLCJyZWFkeSIsIm9uVUlUaHJlYWQiLCJ3b3JrZXJzVXBkYXRlZCIsImxvY2F0ZUFuZERlY29kZSIsIl9pbml0QnVmZmVycyIsIkJhcmNvZGVEZWNvZGVyIiwiX2dldFZpZXdQb3J0IiwiX2luaXRDYW52YXMiLCJpbnB1dFR5cGUiLCJDYW1lcmFBY2Nlc3MiLCJjYW5SZWNvcmQiLCJiYXJjb2RlIiwidHJhbnNmb3JtUmVzdWx0IiwicmVzdWx0Q29sbGVjdG9yIiwicmVzdWx0VG9QdWJsaXNoIiwiRXZlbnRzIiwiaGFzQ29kZVJlc3VsdCIsImdldEJvdW5kaW5nQm94ZXMiLCJkZWNvZGVSZXN1bHQiLCJwdWJsaXNoUmVzdWx0IiwiaW1hZ2VSZXN1bHQiLCJzdG9wcGVkIiwidGltZXN0YW1wIiwicGVyZm9ybWFuY2UiLCJzdGFydENvbnRpbnVvdXNVcGRhdGUiLCJfY29udGV4dCIsIlF1YWdnYUpTU3RhdGljSW50ZXJmYWNlIiwicXVhZ2dhSW5zdGFuY2UiLCJwcm9taXNlIiwiQ29uZmlnIiwiaW5pdElucHV0U3RyZWFtIiwib25EZXRlY3RlZCIsIm9mZkRldGVjdGVkIiwib2ZmUHJvY2Vzc2VkIiwicmVnaXN0ZXJSZXN1bHRDb2xsZWN0b3IiLCJkZWNvZGVTaW5nbGUiLCJyZXN1bHRDYWxsYmFjayIsImRlZmF1bHQiLCJSZXN1bHRDb2xsZWN0b3IiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7O0FDbEZBLFNBQVNBLGVBQVQsQ0FBeUJDLEdBQXpCLEVBQThCQyxHQUE5QixFQUFtQ0MsS0FBbkMsRUFBMEM7QUFDeEMsTUFBSUQsR0FBRyxJQUFJRCxHQUFYLEVBQWdCO0FBQ2RHLFVBQU0sQ0FBQ0MsY0FBUCxDQUFzQkosR0FBdEIsRUFB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LENBQVksV0FBWixFQUF5QixVQUFDNXBDLE1BQUQsRUFBWTtBQUNqQ3VoRywwQkFBYyxDQUFDdjFCLElBQWY7O0FBQ0EsZ0JBQUlnMkIsY0FBSixFQUFvQjtBQUNoQkEsNEJBQWMsQ0FBQ2xyRyxJQUFmLENBQW9CLElBQXBCLEVBQTBCa0osTUFBMUI7QUFDSDs7QUFDRDYvQixtQkFBTyxDQUFDNy9CLE1BQUQsQ0FBUDtBQUNILFdBTkQsRUFNRyxJQU5IO0FBT0F1aEcsd0JBQWMsQ0FBQzM3RSxLQUFmO0FBQ0gsU0FURCxFQVNHLElBVEgsRUFTUzI3RSxjQVRUO0FBVUgsT0FYRCxDQVdFLE9BQU9wb0QsR0FBUCxFQUFZO0FBQ1ZoUyxjQUFNLENBQUNnUyxHQUFELENBQU47QUFDSDtBQUNKLEtBZk0sQ0FBUDtBQWdCSCxHQXhIMkI7O0FBeUg1QjtBQUNBO0FBQ0EsTUFBSThvRCxPQUFKLEdBQWM7QUFDVixXQUFPWCx1QkFBUDtBQUNILEdBN0gyQjs7QUE4SDVCbGYsZUFBYSxFQUFiQSxjQTlINEI7QUErSDVCaWUsY0FBWSxFQUFaQSxhQS9INEI7QUFnSTVCMTVDLFlBQVUsRUFBVkEsOEJBaEk0QjtBQWlJNUI5N0MsY0FBWSxFQUFaQSxnQ0FqSTRCO0FBa0k1QnEzRixpQkFBZSxFQUFmQSxnQkFBZUE7QUFsSWEsQ0FBaEM7QUFxSWVaLG1HQUFmLEUsQ0FDQSIsImZpbGUiOiJxdWFnZ2EuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJRdWFnZ2FcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiUXVhZ2dhXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDY3KTtcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTsiLCJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGZyb21WYWx1ZXM6IHJlcXVpcmUoJy4vZnJvbVZhbHVlcycpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBzZXQ6IHJlcXVpcmUoJy4vc2V0JylcbiAgLCBlcXVhbHM6IHJlcXVpcmUoJy4vZXF1YWxzJylcbiAgLCBleGFjdEVxdWFsczogcmVxdWlyZSgnLi9leGFjdEVxdWFscycpXG4gICwgYWRkOiByZXF1aXJlKCcuL2FkZCcpXG4gICwgc3VidHJhY3Q6IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuICAsIHN1YjogcmVxdWlyZSgnLi9zdWInKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBtdWw6IHJlcXVpcmUoJy4vbXVsJylcbiAgLCBkaXZpZGU6IHJlcXVpcmUoJy4vZGl2aWRlJylcbiAgLCBkaXY6IHJlcXVpcmUoJy4vZGl2JylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBub3JtYWxpemU6IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbiAgLCBkb3Q6IHJlcXVpcmUoJy4vZG90JylcbiAgLCBjcm9zczogcmVxdWlyZSgnLi9jcm9zcycpXG4gICwgbGVycDogcmVxdWlyZSgnLi9sZXJwJylcbiAgLCByYW5kb206IHJlcXVpcmUoJy4vcmFuZG9tJylcbiAgLCB0cmFuc2Zvcm1NYXQyOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDInKVxuICAsIHRyYW5zZm9ybU1hdDJkOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDJkJylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbiAgLCBsaW1pdDogcmVxdWlyZSgnLi9saW1pdCcpXG59XG4iLCIvLyBUT0RPOiBjbHVzdGVyLmpzIGFuZCBjdl91dGlscy5qcyBhcmUgcHJldHR5IHRpZ2h0bHkgaW50ZXJ0d2luZWQsIG1ha2luZyBmb3IgYSBjb21wbGV4IGNvbnZlcnNpb25cbi8vIGludG8gdHlwZXNjcmlwdC4gYmUgd2FybmVkLiA6LSlcblxuaW1wb3J0IHsgY2xvbmUsIGRvdCB9IGZyb20gJ2dsLXZlYzInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSwgZG90IH07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsdXN0ZXIgZm9yIGdyb3VwaW5nIHNpbWlsYXIgb3JpZW50YXRpb25zIG9mIGRhdGFwb2ludHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNyZWF0ZShwb2ludCwgdGhyZXNob2xkKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSB7XG4gICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcG9pbnRNYXAgPSB7fTtcblxuICAgICAgICBmdW5jdGlvbiBhZGQocG9pbnRUb0FkZCkge1xuICAgICAgICAgICAgcG9pbnRNYXBbcG9pbnRUb0FkZC5pZF0gPSBwb2ludFRvQWRkO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRUb0FkZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDZW50ZXIoKSB7XG4gICAgICAgICAgICBsZXQgaTsgbGV0XG4gICAgICAgICAgICAgICAgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gcG9pbnRzW2ldLnJhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlbnRlci5yYWQgPSBzdW0gLyBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgY2VudGVyLnZlYyA9IHZlYzIuY2xvbmUoW01hdGguY29zKGNlbnRlci5yYWQpLCBNYXRoLnNpbihjZW50ZXIucmFkKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIGFkZChwb2ludCk7XG4gICAgICAgICAgICB1cGRhdGVDZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkKHBvaW50VG9BZGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50TWFwW3BvaW50VG9BZGQuaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZChwb2ludFRvQWRkKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdHMob3RoZXJQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNvc2luZSBzaW1pbGFyaXR5IHRvIGNlbnRlci1hbmdsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChvdGhlclBvaW50LnBvaW50LnZlYywgY2VudGVyLnZlYykpO1xuICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UG9pbnRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q2VudGVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlUG9pbnQobmV3UG9pbnQsIGlkLCBwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFkOiBuZXdQb2ludFtwcm9wZXJ0eV0sXG4gICAgICAgICAgICBwb2ludDogbmV3UG9pbnQsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLW1peGVkLW9wZXJhdG9ycyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuaW1wb3J0IHsgY2xvbmUgYXMgdjJjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHsgY2xvbmUgYXMgdjNjbG9uZSB9IGZyb20gJ2dsLXZlYzMnO1xuaW1wb3J0IENsdXN0ZXIyIGZyb20gJy4vY2x1c3Rlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi9hcnJheV9oZWxwZXInO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZTogdjJjbG9uZSB9O1xuY29uc3QgdmVjMyA9IHsgY2xvbmU6IHYzY2xvbmUgfTtcblxuLyoqXG4gKiBAcGFyYW0geCB4LWNvb3JkaW5hdGVcbiAqIEBwYXJhbSB5IHktY29vcmRpbmF0ZVxuICogQHJldHVybiBJbWFnZVJlZmVyZW5jZSB7eCx5fSBDb29yZGluYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbWFnZVJlZih4LCB5KSB7XG4gICAgY29uc3QgdGhhdCA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdG9WZWMyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZlYzIuY2xvbmUoW3RoaXMueCwgdGhpcy55XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvVmVjMygpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLmNsb25lKFt0aGlzLngsIHRoaXMueSwgMV0pO1xuICAgICAgICB9LFxuICAgICAgICByb3VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMueCA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy54ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy54IC0gMC41KTtcbiAgICAgICAgICAgIHRoaXMueSA9IHRoaXMueSA+IDAuMCA/IE1hdGguZmxvb3IodGhpcy55ICsgMC41KSA6IE1hdGguZmxvb3IodGhpcy55IC0gMC41KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHRoYXQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gaW50ZWdyYWwgaW1hZ2Ugb2YgYSBnaXZlbiBncmF5c2NhbGUgaW1hZ2UuXG4gKiBAcGFyYW0gaW1hZ2VEYXRhQ29udGFpbmVyIHtJbWFnZURhdGFDb250YWluZXJ9IHRoZSBpbWFnZSB0byBiZSBpbnRlZ3JhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZTIoaW1hZ2VXcmFwcGVyLCBpbnRlZ3JhbFdyYXBwZXIpIHtcbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgcG9zQSA9IDA7IGxldCBwb3NCID0gMDsgbGV0IHBvc0MgPSAwOyBsZXQgcG9zRCA9IDA7IGxldCB4OyBsZXRcbiAgICAgICAgeTtcblxuICAgIC8vIHN1bSB1cCBmaXJzdCBjb2x1bW5cbiAgICBwb3NCID0gd2lkdGg7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBICs9IHdpZHRoO1xuICAgICAgICBwb3NCICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHBvc0EgPSAwO1xuICAgIHBvc0IgPSAxO1xuICAgIHN1bSA9IDA7XG4gICAgZm9yICh4ID0gMTsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgc3VtICs9IGltYWdlRGF0YVtwb3NBXTtcbiAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQl0gKz0gc3VtO1xuICAgICAgICBwb3NBKys7XG4gICAgICAgIHBvc0IrKztcbiAgICB9XG5cbiAgICBmb3IgKHkgPSAxOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgcG9zQSA9IHkgKiB3aWR0aCArIDE7XG4gICAgICAgIHBvc0IgPSAoeSAtIDEpICogd2lkdGggKyAxO1xuICAgICAgICBwb3NDID0geSAqIHdpZHRoO1xuICAgICAgICBwb3NEID0gKHkgLSAxKSAqIHdpZHRoO1xuICAgICAgICBmb3IgKHggPSAxOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbcG9zQV1cbiAgICAgICAgICAgICAgICArPSBpbWFnZURhdGFbcG9zQV0gKyBpbnRlZ3JhbEltYWdlRGF0YVtwb3NCXSArIGludGVncmFsSW1hZ2VEYXRhW3Bvc0NdIC0gaW50ZWdyYWxJbWFnZURhdGFbcG9zRF07XG4gICAgICAgICAgICBwb3NBKys7XG4gICAgICAgICAgICBwb3NCKys7XG4gICAgICAgICAgICBwb3NDKys7XG4gICAgICAgICAgICBwb3NEKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSW50ZWdyYWxJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlcikge1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IHdpZHRoID0gaW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IGludGVncmFsSW1hZ2VEYXRhID0gaW50ZWdyYWxXcmFwcGVyLmRhdGE7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICAvLyBzdW0gdXAgZmlyc3Qgcm93XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgIHN1bSArPSBpbWFnZURhdGFbaV07XG4gICAgICAgIGludGVncmFsSW1hZ2VEYXRhW2ldID0gc3VtO1xuICAgIH1cblxuICAgIGZvciAobGV0IHYgPSAxOyB2IDwgaGVpZ2h0OyB2KyspIHtcbiAgICAgICAgc3VtID0gMDtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB3aWR0aDsgdSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdO1xuICAgICAgICAgICAgaW50ZWdyYWxJbWFnZURhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gc3VtICsgaW50ZWdyYWxJbWFnZURhdGFbKHYgLSAxKSAqIHdpZHRoICsgdV07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJlc2hvbGRJbWFnZShpbWFnZVdyYXBwZXIsIHRocmVzaG9sZCwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7IGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VEYXRhOyBjb25zdFxuICAgICAgICB0YXJnZXREYXRhID0gdGFyZ2V0V3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHRhcmdldERhdGFbbGVuZ3RoXSA9IGltYWdlRGF0YVtsZW5ndGhdIDwgdGhyZXNob2xkID8gMSA6IDA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhpc3RvZ3JhbShpbWFnZVdyYXBwZXIsIGJpdHNQZXJQaXhlbCkge1xuICAgIGlmICghYml0c1BlclBpeGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBiaXRzUGVyUGl4ZWwgPSA4O1xuICAgIH1cbiAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBsZXQgeyBsZW5ndGggfSA9IGltYWdlRGF0YTtcbiAgICBjb25zdCBiaXRTaGlmdCA9IDggLSBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgYnVja2V0Q250ID0gMSA8PCBiaXRzUGVyUGl4ZWw7XG4gICAgY29uc3QgaGlzdCA9IG5ldyBJbnQzMkFycmF5KGJ1Y2tldENudCk7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaGlzdFtpbWFnZURhdGFbbGVuZ3RoXSA+PiBiaXRTaGlmdF0rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFycGVuTGluZShsaW5lKSB7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGxpbmU7XG4gICAgbGV0IGxlZnQgPSBsaW5lWzBdO1xuICAgIGxldCBjZW50ZXIgPSBsaW5lWzFdO1xuICAgIGxldCByaWdodDtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgcmlnaHQgPSBsaW5lW2kgKyAxXTtcbiAgICAgICAgLy8gIC0xIDQgLTEga2VybmVsXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBsaW5lW2kgLSAxXSA9ICgoKGNlbnRlciAqIDIpIC0gbGVmdCAtIHJpZ2h0KSkgJiAyNTU7XG4gICAgICAgIGxlZnQgPSBjZW50ZXI7XG4gICAgICAgIGNlbnRlciA9IHJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gbGluZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZU90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwgPSA4KSB7XG4gICAgbGV0IGhpc3Q7XG4gICAgY29uc3QgYml0U2hpZnQgPSA4IC0gYml0c1BlclBpeGVsO1xuXG4gICAgZnVuY3Rpb24gcHgoaW5pdCwgZW5kKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gaW5pdDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgICAgICAgc3VtICs9IGhpc3RbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBteChpbml0LCBlbmQpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IGluaXQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBpICogaGlzdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGV0ZXJtaW5lVGhyZXNob2xkKCkge1xuICAgICAgICBjb25zdCB2ZXQgPSBbMF07XG4gICAgICAgIGxldCBwMTtcbiAgICAgICAgbGV0IHAyO1xuICAgICAgICBsZXQgcDEyO1xuICAgICAgICBsZXQgbTE7XG4gICAgICAgIGxldCBtMjtcbiAgICAgICAgbGV0IG0xMjtcbiAgICAgICAgY29uc3QgbWF4ID0gKDEgPDwgYml0c1BlclBpeGVsKSAtIDE7XG5cbiAgICAgICAgaGlzdCA9IGNvbXB1dGVIaXN0b2dyYW0oaW1hZ2VXcmFwcGVyLCBiaXRzUGVyUGl4ZWwpO1xuICAgICAgICBmb3IgKGxldCBrID0gMTsgayA8IG1heDsgaysrKSB7XG4gICAgICAgICAgICBwMSA9IHB4KDAsIGspO1xuICAgICAgICAgICAgcDIgPSBweChrICsgMSwgbWF4KTtcbiAgICAgICAgICAgIHAxMiA9IHAxICogcDI7XG4gICAgICAgICAgICBpZiAocDEyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcDEyID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0xID0gbXgoMCwgaykgKiBwMjtcbiAgICAgICAgICAgIG0yID0gbXgoayArIDEsIG1heCkgKiBwMTtcbiAgICAgICAgICAgIG0xMiA9IG0xIC0gbTI7XG4gICAgICAgICAgICB2ZXRba10gPSBtMTIgKiBtMTIgLyBwMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5SGVscGVyLm1heEluZGV4KHZldCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lVGhyZXNob2xkKCk7XG4gICAgcmV0dXJuIHRocmVzaG9sZCA8PCBiaXRTaGlmdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG90c3VUaHJlc2hvbGQoaW1hZ2VXcmFwcGVyLCB0YXJnZXRXcmFwcGVyKSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gZGV0ZXJtaW5lT3RzdVRocmVzaG9sZChpbWFnZVdyYXBwZXIpO1xuXG4gICAgdGhyZXNob2xkSW1hZ2UoaW1hZ2VXcmFwcGVyLCB0aHJlc2hvbGQsIHRhcmdldFdyYXBwZXIpO1xuICAgIHJldHVybiB0aHJlc2hvbGQ7XG59XG5cbi8vIGxvY2FsIHRocmVzaG9sZGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCaW5hcnlJbWFnZShpbWFnZVdyYXBwZXIsIGludGVncmFsV3JhcHBlciwgdGFyZ2V0V3JhcHBlcikge1xuICAgIGNvbXB1dGVJbnRlZ3JhbEltYWdlKGltYWdlV3JhcHBlciwgaW50ZWdyYWxXcmFwcGVyKTtcblxuICAgIGlmICghdGFyZ2V0V3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdGFyZ2V0V3JhcHBlciA9IGltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldFdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCBpbnRlZ3JhbEltYWdlRGF0YSA9IGludGVncmFsV3JhcHBlci5kYXRhO1xuICAgIGxldCBzdW0gPSAwOyBsZXQgdjsgbGV0IHU7IGNvbnN0IGtlcm5lbCA9IDM7IGxldCBBOyBsZXQgQjsgbGV0IEM7IGxldCBEOyBsZXQgYXZnOyBjb25zdFxuICAgICAgICBzaXplID0gKGtlcm5lbCAqIDIgKyAxKSAqIChrZXJuZWwgKiAyICsgMSk7XG5cbiAgICAvLyBjbGVhciBvdXQgdG9wICYgYm90dG9tLWJvcmRlclxuICAgIGZvciAodiA9IDA7IHYgPD0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8IHdpZHRoOyB1KyspIHtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCh2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgICAgIHRhcmdldERhdGFbKCgoaGVpZ2h0IC0gMSkgLSB2KSAqIHdpZHRoKSArIHVdID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCBsZWZ0ICYgcmlnaHQgYm9yZGVyXG4gICAgZm9yICh2ID0ga2VybmVsOyB2IDwgaGVpZ2h0IC0ga2VybmVsOyB2KyspIHtcbiAgICAgICAgZm9yICh1ID0gMDsgdSA8PSBrZXJuZWw7IHUrKykge1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgdV0gPSAwO1xuICAgICAgICAgICAgdGFyZ2V0RGF0YVsoKHYpICogd2lkdGgpICsgKHdpZHRoIC0gMSAtIHUpXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHYgPSBrZXJuZWwgKyAxOyB2IDwgaGVpZ2h0IC0ga2VybmVsIC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IGtlcm5lbCArIDE7IHUgPCB3aWR0aCAtIGtlcm5lbDsgdSsrKSB7XG4gICAgICAgICAgICBBID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgLSBrZXJuZWwgLSAxKV07XG4gICAgICAgICAgICBCID0gaW50ZWdyYWxJbWFnZURhdGFbKHYgLSBrZXJuZWwgLSAxKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIEMgPSBpbnRlZ3JhbEltYWdlRGF0YVsodiArIGtlcm5lbCkgKiB3aWR0aCArICh1IC0ga2VybmVsIC0gMSldO1xuICAgICAgICAgICAgRCA9IGludGVncmFsSW1hZ2VEYXRhWyh2ICsga2VybmVsKSAqIHdpZHRoICsgKHUgKyBrZXJuZWwpXTtcbiAgICAgICAgICAgIHN1bSA9IEQgLSBDIC0gQiArIEE7XG4gICAgICAgICAgICBhdmcgPSBzdW0gLyAoc2l6ZSk7XG4gICAgICAgICAgICB0YXJnZXREYXRhW3YgKiB3aWR0aCArIHVdID0gaW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID4gKGF2ZyArIDUpID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHVzdGVyKHBvaW50cywgdGhyZXNob2xkLCBwcm9wZXJ0eSkge1xuICAgIGxldCBpOyBsZXQgazsgbGV0IHRoaXNDbHVzdGVyOyBsZXQgcG9pbnQ7IGNvbnN0XG4gICAgICAgIGNsdXN0ZXJzID0gW107XG5cbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBwcm9wZXJ0eSA9ICdyYWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRvQ2x1c3RlcihuZXdQb2ludCkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNsdXN0ZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0aGlzQ2x1c3RlciA9IGNsdXN0ZXJzW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNDbHVzdGVyLmZpdHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NsdXN0ZXIuYWRkKG5ld1BvaW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgb3ZlciBlYWNoIGNsb3VkXG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb2ludCA9IENsdXN0ZXIyLmNyZWF0ZVBvaW50KHBvaW50c1tpXSwgaSwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIWFkZFRvQ2x1c3Rlcihwb2ludCkpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goQ2x1c3RlcjIuY3JlYXRlKHBvaW50LCB0aHJlc2hvbGQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2x1c3RlcnM7XG59XG5cbmV4cG9ydCBjb25zdCBUcmFjZXIgPSB7XG4gICAgdHJhY2UocG9pbnRzLCB2ZWMpIHtcbiAgICAgICAgbGV0IGl0ZXJhdGlvbjtcbiAgICAgICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICBsZXQgdG9wID0gW107XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGNlbnRlclBvcyA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50UG9zID0gMDtcblxuICAgICAgICBmdW5jdGlvbiB0cmFjZShpZHgsIGZvcndhcmQpIHtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGxldCB0b0lkeDtcbiAgICAgICAgICAgIGxldCBwcmVkaWN0ZWRQb3M7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRYID0gMTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZFkgPSBNYXRoLmFicyh2ZWNbMV0gLyAxMCk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2gocG9zLCBwcmVkaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLnggPiAocHJlZGljdGVkLnggLSB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnggPCAocHJlZGljdGVkLnggKyB0aHJlc2hvbGRYKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPiAocHJlZGljdGVkLnkgLSB0aHJlc2hvbGRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgcG9zLnkgPCAocHJlZGljdGVkLnkgKyB0aHJlc2hvbGRZKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmV4dCBpbmRleCBpcyB3aXRoaW4gdGhlIHZlYyBzcGVjaWZpY2F0aW9uc1xuICAgICAgICAgICAgLy8gaWYgbm90LCBjaGVjayBhcyBsb25nIGFzIHRoZSB0aHJlc2hvbGQgaXMgbWV0XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBwb2ludHNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljdGVkUG9zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyB2ZWNbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIHZlY1sxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVkaWN0ZWRQb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGZyb20ueCAtIHZlY1swXSxcbiAgICAgICAgICAgICAgICAgICAgeTogZnJvbS55IC0gdmVjWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRvSWR4ID0gZm9yd2FyZCA/IGlkeCArIDEgOiBpZHggLSAxO1xuICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICB3aGlsZSAodG8gJiYgKGZvdW5kID0gbWF0Y2godG8sIHByZWRpY3RlZFBvcykpICE9PSB0cnVlICYmIChNYXRoLmFicyh0by55IC0gZnJvbS55KSA8IHZlY1sxXSkpIHtcbiAgICAgICAgICAgICAgICB0b0lkeCA9IGZvcndhcmQgPyB0b0lkeCArIDEgOiB0b0lkeCAtIDE7XG4gICAgICAgICAgICAgICAgdG8gPSBwb2ludHNbdG9JZHhdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZm91bmQgPyB0b0lkeCA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGl0ZXJhdGlvbiA9IDA7IGl0ZXJhdGlvbiA8IG1heEl0ZXJhdGlvbnM7IGl0ZXJhdGlvbisrKSB7XG4gICAgICAgICAgICAvLyByYW5kb21seSBzZWxlY3QgcG9pbnQgdG8gc3RhcnQgd2l0aFxuICAgICAgICAgICAgY2VudGVyUG9zID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIC8vIHRyYWNlIGZvcndhcmRcbiAgICAgICAgICAgIHRvcCA9IFtdO1xuICAgICAgICAgICAgY3VycmVudFBvcyA9IGNlbnRlclBvcztcbiAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFBvcyA9IHRyYWNlKGN1cnJlbnRQb3MsIHRydWUpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcC5wdXNoKHBvaW50c1tjdXJyZW50UG9zXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2VudGVyUG9zID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgPSBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjdXJyZW50UG9zID0gdHJhY2UoY3VycmVudFBvcywgZmFsc2UpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AucHVzaChwb2ludHNbY3VycmVudFBvc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvcC5sZW5ndGggPiByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBESUxBVEUgPSAxO1xuZXhwb3J0IGNvbnN0IEVST0RFID0gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlV3JhcHBlciwgb3V0SW1hZ2VXcmFwcGVyKSB7XG4gICAgbGV0IHY7XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaW5JbWFnZURhdGEgPSBpbkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IG91dEltYWdlRGF0YSA9IG91dEltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGhlaWdodCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBjb25zdCB3aWR0aCA9IGluSW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgc3VtO1xuICAgIGxldCB5U3RhcnQxO1xuICAgIGxldCB5U3RhcnQyO1xuICAgIGxldCB4U3RhcnQxO1xuICAgIGxldCB4U3RhcnQyO1xuXG4gICAgZm9yICh2ID0gMTsgdiA8IGhlaWdodCAtIDE7IHYrKykge1xuICAgICAgICBmb3IgKHUgPSAxOyB1IDwgd2lkdGggLSAxOyB1KyspIHtcbiAgICAgICAgICAgIHlTdGFydDEgPSB2IC0gMTtcbiAgICAgICAgICAgIHlTdGFydDIgPSB2ICsgMTtcbiAgICAgICAgICAgIHhTdGFydDEgPSB1IC0gMTtcbiAgICAgICAgICAgIHhTdGFydDIgPSB1ICsgMTtcbiAgICAgICAgICAgIHN1bSA9IGluSW1hZ2VEYXRhW3lTdGFydDEgKiB3aWR0aCArIHhTdGFydDFdICsgaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0Ml1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbdiAqIHdpZHRoICsgdV1cbiAgICAgICAgICAgICsgaW5JbWFnZURhdGFbeVN0YXJ0MiAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQyXTtcbiAgICAgICAgICAgIG91dEltYWdlRGF0YVt2ICogd2lkdGggKyB1XSA9IHN1bSA+IDAgPyAxIDogMDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VXcmFwcGVyLCBvdXRJbWFnZVdyYXBwZXIpIHtcbiAgICBsZXQgdjtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBpbkltYWdlRGF0YSA9IGluSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgb3V0SW1hZ2VEYXRhID0gb3V0SW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS55O1xuICAgIGNvbnN0IHdpZHRoID0gaW5JbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCBzdW07XG4gICAgbGV0IHlTdGFydDE7XG4gICAgbGV0IHlTdGFydDI7XG4gICAgbGV0IHhTdGFydDE7XG4gICAgbGV0IHhTdGFydDI7XG5cbiAgICBmb3IgKHYgPSAxOyB2IDwgaGVpZ2h0IC0gMTsgdisrKSB7XG4gICAgICAgIGZvciAodSA9IDE7IHUgPCB3aWR0aCAtIDE7IHUrKykge1xuICAgICAgICAgICAgeVN0YXJ0MSA9IHYgLSAxO1xuICAgICAgICAgICAgeVN0YXJ0MiA9IHYgKyAxO1xuICAgICAgICAgICAgeFN0YXJ0MSA9IHUgLSAxO1xuICAgICAgICAgICAgeFN0YXJ0MiA9IHUgKyAxO1xuICAgICAgICAgICAgc3VtID0gaW5JbWFnZURhdGFbeVN0YXJ0MSAqIHdpZHRoICsgeFN0YXJ0MV0gKyBpbkltYWdlRGF0YVt5U3RhcnQxICogd2lkdGggKyB4U3RhcnQyXVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt2ICogd2lkdGggKyB1XVxuICAgICAgICAgICAgKyBpbkltYWdlRGF0YVt5U3RhcnQyICogd2lkdGggKyB4U3RhcnQxXSArIGluSW1hZ2VEYXRhW3lTdGFydDIgKiB3aWR0aCArIHhTdGFydDJdO1xuICAgICAgICAgICAgb3V0SW1hZ2VEYXRhW3YgKiB3aWR0aCArIHVdID0gc3VtID09PSA1ID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VXcmFwcGVyLCBiSW1hZ2VXcmFwcGVyLCByZXN1bHRJbWFnZVdyYXBwZXIpIHtcbiAgICBpZiAoIXJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgcmVzdWx0SW1hZ2VXcmFwcGVyID0gYUltYWdlV3JhcHBlcjtcbiAgICB9XG4gICAgbGV0IHsgbGVuZ3RoIH0gPSBhSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgYUltYWdlRGF0YSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBiSW1hZ2VEYXRhID0gYkltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGNJbWFnZURhdGEgPSByZXN1bHRJbWFnZVdyYXBwZXIuZGF0YTtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBjSW1hZ2VEYXRhW2xlbmd0aF0gPSBhSW1hZ2VEYXRhW2xlbmd0aF0gLSBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYml0d2lzZU9yKGFJbWFnZVdyYXBwZXIsIGJJbWFnZVdyYXBwZXIsIHJlc3VsdEltYWdlV3JhcHBlcikge1xuICAgIGlmICghcmVzdWx0SW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICByZXN1bHRJbWFnZVdyYXBwZXIgPSBhSW1hZ2VXcmFwcGVyO1xuICAgIH1cbiAgICBsZXQgeyBsZW5ndGggfSA9IGFJbWFnZVdyYXBwZXIuZGF0YTtcbiAgICBjb25zdCBhSW1hZ2VEYXRhID0gYUltYWdlV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGJJbWFnZURhdGEgPSBiSW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgY0ltYWdlRGF0YSA9IHJlc3VsdEltYWdlV3JhcHBlci5kYXRhO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGNJbWFnZURhdGFbbGVuZ3RoXSA9IGFJbWFnZURhdGFbbGVuZ3RoXSB8fCBiSW1hZ2VEYXRhW2xlbmd0aF07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlV3JhcHBlcikge1xuICAgIGxldCB7IGxlbmd0aCB9ID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBpbWFnZVdyYXBwZXI7XG4gICAgbGV0IHN1bSA9IDA7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgc3VtICs9IGRhdGFbbGVuZ3RoXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEdlbmVyaWMobGlzdCwgdG9wLCBzY29yZUZ1bmMpIHtcbiAgICBsZXQgaTsgbGV0IG1pbklkeCA9IDA7IGxldCBtaW4gPSAwOyBjb25zdCBxdWV1ZSA9IFtdOyBsZXQgc2NvcmU7IGxldCBoaXQ7IGxldFxuICAgICAgICBwb3M7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9wOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0gPSB7XG4gICAgICAgICAgICBzY29yZTogMCxcbiAgICAgICAgICAgIGl0ZW06IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2NvcmUgPSBzY29yZUZ1bmMuYXBwbHkodGhpcywgW2xpc3RbaV1dKTtcbiAgICAgICAgaWYgKHNjb3JlID4gbWluKSB7XG4gICAgICAgICAgICBoaXQgPSBxdWV1ZVttaW5JZHhdO1xuICAgICAgICAgICAgaGl0LnNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICBoaXQuaXRlbSA9IGxpc3RbaV07XG4gICAgICAgICAgICBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgZm9yIChwb3MgPSAwOyBwb3MgPCB0b3A7IHBvcysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW3Bvc10uc2NvcmUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcXVldWVbcG9zXS5zY29yZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSWR4ID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBxdWV1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyYXlBcnJheUZyb21JbWFnZShodG1sSW1hZ2UsIG9mZnNldFgsIGN0eCwgYXJyYXkpIHtcbiAgICBjdHguZHJhd0ltYWdlKGh0bWxJbWFnZSwgb2Zmc2V0WCwgMCwgaHRtbEltYWdlLndpZHRoLCBodG1sSW1hZ2UuaGVpZ2h0KTtcbiAgICBjb25zdCBjdHhEYXRhID0gY3R4LmdldEltYWdlRGF0YShvZmZzZXRYLCAwLCBodG1sSW1hZ2Uud2lkdGgsIGh0bWxJbWFnZS5oZWlnaHQpLmRhdGE7XG4gICAgY29tcHV0ZUdyYXkoY3R4RGF0YSwgYXJyYXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JheUFycmF5RnJvbUNvbnRleHQoY3R4LCBzaXplLCBvZmZzZXQsIGFycmF5KSB7XG4gICAgY29uc3QgY3R4RGF0YSA9IGN0eC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LCBzaXplLngsIHNpemUueSkuZGF0YTtcbiAgICBjb21wdXRlR3JheShjdHhEYXRhLCBhcnJheSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGNhbnZhc0RhdGEsIHNpemUsIG91dEFycmF5KSB7XG4gICAgbGV0IHRvcFJvd0lkeCA9IDA7XG4gICAgbGV0IGJvdHRvbVJvd0lkeCA9IHNpemUueDtcbiAgICBjb25zdCBlbmRJZHggPSBNYXRoLmZsb29yKGNhbnZhc0RhdGEubGVuZ3RoIC8gNCk7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBzaXplLnggLyAyO1xuICAgIGxldCBvdXRJbWdJZHggPSAwO1xuICAgIGNvbnN0IGluV2lkdGggPSBzaXplLng7XG4gICAgbGV0IGk7XG5cbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvdXRXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG91dEFycmF5W291dEltZ0lkeF0gPSAoXG4gICAgICAgICAgICAgICAgKDAuMjk5ICogY2FudmFzRGF0YVt0b3BSb3dJZHggKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbdG9wUm93SWR4ICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhW3RvcFJvd0lkeCAqIDQgKyAyXSlcbiAgICAgICAgICAgICAgICArICgwLjI5OSAqIGNhbnZhc0RhdGFbKHRvcFJvd0lkeCArIDEpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyh0b3BSb3dJZHggKyAxKSAqIDQgKyAxXVxuICAgICAgICAgICAgICAgICArIDAuMTE0ICogY2FudmFzRGF0YVsodG9wUm93SWR4ICsgMSkgKiA0ICsgMl0pXG4gICAgICAgICAgICAgICAgKyAoMC4yOTkgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDBdXG4gICAgICAgICAgICAgICAgICsgMC41ODcgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHgpICogNCArIDJdKVxuICAgICAgICAgICAgICAgICsgKDAuMjk5ICogY2FudmFzRGF0YVsoYm90dG9tUm93SWR4ICsgMSkgKiA0ICsgMF1cbiAgICAgICAgICAgICAgICAgKyAwLjU4NyAqIGNhbnZhc0RhdGFbKGJvdHRvbVJvd0lkeCArIDEpICogNCArIDFdXG4gICAgICAgICAgICAgICAgICsgMC4xMTQgKiBjYW52YXNEYXRhWyhib3R0b21Sb3dJZHggKyAxKSAqIDQgKyAyXSkpIC8gNDtcbiAgICAgICAgICAgIG91dEltZ0lkeCsrO1xuICAgICAgICAgICAgdG9wUm93SWR4ICs9IDI7XG4gICAgICAgICAgICBib3R0b21Sb3dJZHggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICB0b3BSb3dJZHggKz0gaW5XaWR0aDtcbiAgICAgICAgYm90dG9tUm93SWR4ICs9IGluV2lkdGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUdyYXkoaW1hZ2VEYXRhLCBvdXRBcnJheSwgY29uZmlnKSB7XG4gICAgY29uc3QgbCA9IChpbWFnZURhdGEubGVuZ3RoIC8gNCkgfCAwO1xuICAgIGNvbnN0IHNpbmdsZUNoYW5uZWwgPSBjb25maWcgJiYgY29uZmlnLnNpbmdsZUNoYW5uZWwgPT09IHRydWU7XG5cbiAgICBpZiAoc2luZ2xlQ2hhbm5lbCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBvdXRBcnJheVtpXSA9IGltYWdlRGF0YVtpICogNCArIDBdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgb3V0QXJyYXlbaV0gPSAwLjI5OSAqIGltYWdlRGF0YVtpICogNCArIDBdICsgMC41ODcgKiBpbWFnZURhdGFbaSAqIDQgKyAxXSArIDAuMTE0ICogaW1hZ2VEYXRhW2kgKiA0ICsgMl07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkSW1hZ2VBcnJheShzcmMsIGNhbGxiYWNrLCBjYW52YXMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSkge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCAwLCAwKTtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLndpZHRoICogdGhpcy5oZWlnaHQpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICBjb21wdXRlR3JheShkYXRhLCBhcnJheSk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soYXJyYXksIHtcbiAgICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICB5OiB0aGlzLmhlaWdodCxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBpbWcuc3JjID0gc3JjO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpbkltZyB7SW1hZ2VXcmFwcGVyfSBpbnB1dCBpbWFnZSB0byBiZSBzYW1wbGVkXG4gKiBAcGFyYW0gb3V0SW1nIHtJbWFnZVdyYXBwZXJ9IHRvIGJlIHN0b3JlZCBpblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFsZlNhbXBsZShpbkltZ1dyYXBwZXIsIG91dEltZ1dyYXBwZXIpIHtcbiAgICBjb25zdCBpbkltZyA9IGluSW1nV3JhcHBlci5kYXRhO1xuICAgIGNvbnN0IGluV2lkdGggPSBpbkltZ1dyYXBwZXIuc2l6ZS54O1xuICAgIGNvbnN0IG91dEltZyA9IG91dEltZ1dyYXBwZXIuZGF0YTtcbiAgICBsZXQgdG9wUm93SWR4ID0gMDtcbiAgICBsZXQgYm90dG9tUm93SWR4ID0gaW5XaWR0aDtcbiAgICBjb25zdCBlbmRJZHggPSBpbkltZy5sZW5ndGg7XG4gICAgY29uc3Qgb3V0V2lkdGggPSBpbldpZHRoIC8gMjtcbiAgICBsZXQgb3V0SW1nSWR4ID0gMDtcbiAgICB3aGlsZSAoYm90dG9tUm93SWR4IDwgZW5kSWR4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0V2lkdGg7IGkrKykge1xuICAgICAgICAgICAgb3V0SW1nW291dEltZ0lkeF0gPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgIChpbkltZ1t0b3BSb3dJZHhdICsgaW5JbWdbdG9wUm93SWR4ICsgMV0gKyBpbkltZ1tib3R0b21Sb3dJZHhdICsgaW5JbWdbYm90dG9tUm93SWR4ICsgMV0pIC8gNCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBvdXRJbWdJZHgrKztcbiAgICAgICAgICAgIHRvcFJvd0lkeCArPSAyO1xuICAgICAgICAgICAgYm90dG9tUm93SWR4ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgdG9wUm93SWR4ICs9IGluV2lkdGg7XG4gICAgICAgIGJvdHRvbVJvd0lkeCArPSBpbldpZHRoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhzdjJyZ2IoaHN2LCByZ2IgPSBbMCwgMCwgMF0pIHtcbiAgICBjb25zdCBoID0gaHN2WzBdO1xuICAgIGNvbnN0IHMgPSBoc3ZbMV07XG4gICAgY29uc3QgdiA9IGhzdlsyXTtcbiAgICBjb25zdCBjID0gdiAqIHM7XG4gICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICBjb25zdCBtID0gdiAtIGM7XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBnID0gMDtcbiAgICBsZXQgYiA9IDA7XG5cbiAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgIHIgPSBjO1xuICAgICAgICBnID0geDtcbiAgICB9IGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGcgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICBnID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfSBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgIGcgPSB4O1xuICAgICAgICBiID0gYztcbiAgICB9IGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgciA9IHg7XG4gICAgICAgIGIgPSBjO1xuICAgIH0gZWxzZSBpZiAoaCA8IDM2MCkge1xuICAgICAgICByID0gYztcbiAgICAgICAgYiA9IHg7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHJnYlswXSA9ICgociArIG0pICogMjU1KSB8IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgcmdiWzFdID0gKChnICsgbSkgKiAyNTUpIHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICByZ2JbMl0gPSAoKGIgKyBtKSAqIDI1NSkgfCAwO1xuICAgIHJldHVybiByZ2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZURpdmlzb3JzKG4pIHtcbiAgICBjb25zdCBsYXJnZURpdmlzb3JzID0gW107XG4gICAgY29uc3QgZGl2aXNvcnMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgTWF0aC5zcXJ0KG4pICsgMTsgaSsrKSB7XG4gICAgICAgIGlmIChuICUgaSA9PT0gMCkge1xuICAgICAgICAgICAgZGl2aXNvcnMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChpICE9PSBuIC8gaSkge1xuICAgICAgICAgICAgICAgIGxhcmdlRGl2aXNvcnMudW5zaGlmdChNYXRoLmZsb29yKG4gLyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpdmlzb3JzLmNvbmNhdChsYXJnZURpdmlzb3JzKTtcbn1cblxuZnVuY3Rpb24gX2NvbXB1dGVJbnRlcnNlY3Rpb24oYXJyMSwgYXJyMikge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgaiA9IDA7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaSA8IGFycjEubGVuZ3RoICYmIGogPCBhcnIyLmxlbmd0aCkge1xuICAgICAgICBpZiAoYXJyMVtpXSA9PT0gYXJyMltqXSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyMVtpXSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJyMVtpXSA+IGFycjJbal0pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUGF0Y2hTaXplKHBhdGNoU2l6ZSwgaW1nU2l6ZSkge1xuICAgIGNvbnN0IGRpdmlzb3JzWCA9IF9jb21wdXRlRGl2aXNvcnMoaW1nU2l6ZS54KTtcbiAgICBjb25zdCBkaXZpc29yc1kgPSBfY29tcHV0ZURpdmlzb3JzKGltZ1NpemUueSk7XG4gICAgY29uc3Qgd2lkZVNpZGUgPSBNYXRoLm1heChpbWdTaXplLngsIGltZ1NpemUueSk7XG4gICAgY29uc3QgY29tbW9uID0gX2NvbXB1dGVJbnRlcnNlY3Rpb24oZGl2aXNvcnNYLCBkaXZpc29yc1kpO1xuICAgIGNvbnN0IG5yT2ZQYXRjaGVzTGlzdCA9IFs4LCAxMCwgMTUsIDIwLCAzMiwgNjAsIDgwXTtcbiAgICBjb25zdCBuck9mUGF0Y2hlc01hcCA9IHtcbiAgICAgICAgJ3gtc21hbGwnOiA1LFxuICAgICAgICBzbWFsbDogNCxcbiAgICAgICAgbWVkaXVtOiAzLFxuICAgICAgICBsYXJnZTogMixcbiAgICAgICAgJ3gtbGFyZ2UnOiAxLFxuICAgIH07XG4gICAgY29uc3QgbnJPZlBhdGNoZXNJZHggPSBuck9mUGF0Y2hlc01hcFtwYXRjaFNpemVdIHx8IG5yT2ZQYXRjaGVzTWFwLm1lZGl1bTtcbiAgICBjb25zdCBuck9mUGF0Y2hlcyA9IG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF07XG4gICAgY29uc3QgZGVzaXJlZFBhdGNoU2l6ZSA9IE1hdGguZmxvb3Iod2lkZVNpZGUgLyBuck9mUGF0Y2hlcyk7XG4gICAgbGV0IG9wdGltYWxQYXRjaFNpemU7XG5cbiAgICBmdW5jdGlvbiBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoZGl2aXNvcnMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgZm91bmQgPSBkaXZpc29yc1tNYXRoLmZsb29yKGRpdmlzb3JzLmxlbmd0aCAvIDIpXTtcblxuICAgICAgICB3aGlsZSAoaSA8IChkaXZpc29ycy5sZW5ndGggLSAxKSAmJiBkaXZpc29yc1tpXSA8IGRlc2lyZWRQYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXZpc29yc1tpXSAtIGRlc2lyZWRQYXRjaFNpemUpID4gTWF0aC5hYnMoZGl2aXNvcnNbaSAtIDFdIC0gZGVzaXJlZFBhdGNoU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGRpdmlzb3JzW2kgLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSBkaXZpc29yc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzaXJlZFBhdGNoU2l6ZSAvIGZvdW5kIDwgbnJPZlBhdGNoZXNMaXN0W25yT2ZQYXRjaGVzSWR4ICsgMV0gLyBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHhdXG4gICAgICAgICAgICAmJiBkZXNpcmVkUGF0Y2hTaXplIC8gZm91bmQgPiBuck9mUGF0Y2hlc0xpc3RbbnJPZlBhdGNoZXNJZHggLSAxXSAvIG5yT2ZQYXRjaGVzTGlzdFtuck9mUGF0Y2hlc0lkeF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZvdW5kLCB5OiBmb3VuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9wdGltYWxQYXRjaFNpemUgPSBmaW5kUGF0Y2hTaXplRm9yRGl2aXNvcnMoY29tbW9uKTtcbiAgICBpZiAoIW9wdGltYWxQYXRjaFNpemUpIHtcbiAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycyhfY29tcHV0ZURpdmlzb3JzKHdpZGVTaWRlKSk7XG4gICAgICAgIGlmICghb3B0aW1hbFBhdGNoU2l6ZSkge1xuICAgICAgICAgICAgb3B0aW1hbFBhdGNoU2l6ZSA9IGZpbmRQYXRjaFNpemVGb3JEaXZpc29ycygoX2NvbXB1dGVEaXZpc29ycyhkZXNpcmVkUGF0Y2hTaXplICogbnJPZlBhdGNoZXMpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGltYWxQYXRjaFNpemU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VDU1NEaW1lbnNpb25WYWx1ZXModmFsdWUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSB7XG4gICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHZhbHVlKSxcbiAgICAgICAgdW5pdDogdmFsdWUuaW5kZXhPZignJScpID09PSB2YWx1ZS5sZW5ndGggLSAxID8gJyUnIDogJyUnLFxuICAgIH07XG5cbiAgICByZXR1cm4gZGltZW5zaW9uO1xufVxuXG5leHBvcnQgY29uc3QgX2RpbWVuc2lvbnNDb252ZXJ0ZXJzID0ge1xuICAgIHRvcChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQuaGVpZ2h0ICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpIDogbnVsbDtcbiAgICB9LFxuICAgIHJpZ2h0KGRpbWVuc2lvbiwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZGltZW5zaW9uLnVuaXQgPT09ICclJyA/IE1hdGguZmxvb3IoY29udGV4dC53aWR0aCAtIChjb250ZXh0LndpZHRoICogKGRpbWVuc2lvbi52YWx1ZSAvIDEwMCkpKSA6IG51bGw7XG4gICAgfSxcbiAgICBib3R0b20oZGltZW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBkaW1lbnNpb24udW5pdCA9PT0gJyUnID8gTWF0aC5mbG9vcihjb250ZXh0LmhlaWdodCAtIChjb250ZXh0LmhlaWdodCAqIChkaW1lbnNpb24udmFsdWUgLyAxMDApKSkgOiBudWxsO1xuICAgIH0sXG4gICAgbGVmdChkaW1lbnNpb24sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbi51bml0ID09PSAnJScgPyBNYXRoLmZsb29yKGNvbnRleHQud2lkdGggKiAoZGltZW5zaW9uLnZhbHVlIC8gMTAwKSkgOiBudWxsO1xuICAgIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUltYWdlQXJlYShpbnB1dFdpZHRoLCBpbnB1dEhlaWdodCwgYXJlYSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7IHdpZHRoOiBpbnB1dFdpZHRoLCBoZWlnaHQ6IGlucHV0SGVpZ2h0IH07XG5cbiAgICBjb25zdCBwYXJzZWRBcmVhID0gT2JqZWN0LmtleXMoYXJlYSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZWFba2V5XTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gX3BhcnNlQ1NTRGltZW5zaW9uVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZCA9IF9kaW1lbnNpb25zQ29udmVydGVyc1trZXldKHBhcnNlZCwgY29udGV4dCk7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIHJlc3VsdFtrZXldID0gY2FsY3VsYXRlZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzeDogcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzeTogcGFyc2VkQXJlYS50b3AsXG4gICAgICAgIHN3OiBwYXJzZWRBcmVhLnJpZ2h0IC0gcGFyc2VkQXJlYS5sZWZ0LFxuICAgICAgICBzaDogcGFyc2VkQXJlYS5ib3R0b20gLSBwYXJzZWRBcmVhLnRvcCxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgWFlTaXplIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbi8vIFRPRE86IFhZUG9zaXRpb24gc2hvdWxkIGJlIGFuIFhZT2JqZWN0LCBidXQgdGhhdCBicmVha3MgWFlEZWZpbml0aW9uLCB3aGljaCBicmVha3MgZHJhd1BhdGgoKSBiZWxvdy5cbmRlY2xhcmUgaW50ZXJmYWNlIFhZUG9zaXRpb24ge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENhbnZhc1N0eWxlIHtcbiAgICBjb2xvcjogc3RyaW5nO1xuICAgIGxpbmVXaWR0aDogbnVtYmVyO1xufVxuXG4vLyBYWURlZmluaXRpb24gdGVsbHMgdXMgd2hpY2ggY29tcG9uZW50IG9mIGEgZ2l2ZW4gYXJyYXkgb3Igb2JqZWN0IGlzIHRoZSBcIlhcIiBhbmQgd2hpY2ggaXMgdGhlIFwiWVwiLlxuLy8gVXN1YWxseSB0aGlzIGlzIDAgZm9yIFggYW5kIDEgZm9yIFksIGJ1dCBtaWdodCBiZSB1c2VkIGFzICd4JyBmb3IgeCBhbmQgJ3knIGZvciBZLlxuZGVjbGFyZSBpbnRlcmZhY2UgWFlEZWZpbml0aW9uIHtcbiAgICB4OiBrZXlvZiBYWVBvc2l0aW9uO1xuICAgIHk6IGtleW9mIFhZUG9zaXRpb247XG59XG5cbmRlY2xhcmUgdHlwZSBQYXRoID0gQXJyYXk8WFlQb3NpdGlvbj47XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBkcmF3UmVjdChwb3M6IFhZUG9zaXRpb24sIHNpemU6IFhZU2l6ZSwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoIHx8IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QocG9zLngsIHBvcy55LCBzaXplLngsIHNpemUueSk7XG4gICAgfSxcbiAgICBkcmF3UGF0aChwYXRoOiBQYXRoLCBkZWY6IFhZRGVmaW5pdGlvbiwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIHN0eWxlOiBDYW52YXNTdHlsZSk6IHZvaWQge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUubGluZVdpZHRoO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocGF0aFswXVtkZWYueF0sIHBhdGhbMF1bZGVmLnldKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBhdGhbal1bZGVmLnhdLCBwYXRoW2pdW2RlZi55XSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBkcmF3SW1hZ2UoaW1hZ2VEYXRhOiBBcnJheTxudW1iZXI+LCBzaXplOiBYWVNpemUsIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0RhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNpemUueCwgc2l6ZS55KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBjYW52YXNEYXRhO1xuICAgICAgICBsZXQgY2FudmFzRGF0YVBvcyA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBsZXQgaW1hZ2VEYXRhUG9zID0gaW1hZ2VEYXRhLmxlbmd0aDtcblxuICAgICAgICBpZiAoY2FudmFzRGF0YVBvcyAvIGltYWdlRGF0YVBvcyAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbWFnZURhdGFQb3MtLSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbWFnZURhdGFbaW1hZ2VEYXRhUG9zXTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IDI1NTtcbiAgICAgICAgICAgIGRhdGFbLS1jYW52YXNEYXRhUG9zXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVstLWNhbnZhc0RhdGFQb3NdID0gdmFsdWU7XG4gICAgICAgICAgICBkYXRhWy0tY2FudmFzRGF0YVBvc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHV0SW1hZ2VEYXRhKGNhbnZhc0RhdGEsIDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxufTtcbiIsImltcG9ydCB7IFR5cGVkQXJyYXkgfSBmcm9tIFwiLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2FcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGFycjogVHlwZWRBcnJheSB8IEFycmF5PGFueT4sIHZhbDogYW55KSB7XG4gICAgICAgIC8vIGFyci5maWxsKHZhbCk7XG4gICAgICAgIGxldCBsID0gYXJyLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGwtLSkge1xuICAgICAgICAgICAgYXJyW2xdID0gdmFsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNodWZmbGVzIHRoZSBjb250ZW50IG9mIGFuIGFycmF5XG4gICAgICovXG4gICAgc2h1ZmZsZTogZnVuY3Rpb24oYXJyOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBpKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBhcnJbaV07XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgICAgICAgICBhcnJbal0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHRvUG9pbnRMaXN0OiBmdW5jdGlvbihhcnI6IEFycmF5PEFycmF5PG51bWJlcj4+KSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBhcnIucmVkdWNlKChwLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBgWyR7bi5qb2luKCcsJyl9XWA7XG4gICAgICAgICAgICBwLnB1c2gocm93KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LCBbXSBhcyBBcnJheTxzdHJpbmc+KTtcbiAgICAgICAgcmV0dXJuIGBbJHtyb3dzLmpvaW4oJyxcXHJcXG4nKX1dYDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgZWxlbWVudHMgd2hpY2gncyBzY29yZSBpcyBiaWdnZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICovXG4gICAgdGhyZXNob2xkOiBmdW5jdGlvbihhcnI6IEFycmF5PG51bWJlcj4sIHRocmVzaG9sZDogbnVtYmVyLCBzY29yZUZ1bmM6ICgoc2NvcmU6IG51bWJlcikgPT4gbnVtYmVyKSkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IGFyci5yZWR1Y2UoKHByZXY6IEFycmF5PG51bWJlcj4sIG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChzY29yZUZ1bmMuYXBwbHkoYXJyLCBbbmV4dF0pID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHByZXYucHVzaChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBxdWV1ZTtcbiAgICB9LFxuXG4gICAgbWF4SW5kZXg6IGZ1bmN0aW9uKGFycjogQXJyYXk8YW55Pikge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPiBhcnJbbWF4XSkge1xuICAgICAgICAgICAgICAgIG1heCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbihhcnI6IEFycmF5PGFueT4pIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gYXJyW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfSxcblxuICAgIHN1bTogZnVuY3Rpb24oYXJyOiBBcnJheTxhbnk+IHwgVHlwZWRBcnJheSk6IG51bWJlciB7XG4gICAgICAgIGxldCBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bSArPSBhcnJbbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0sXG59O1xuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IGhzdjJyZ2IgfSBmcm9tICcuL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuL2FycmF5X2hlbHBlcic7XG5pbXBvcnQge1xuICAgIFhZU2l6ZSxcbiAgICBUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gICAgVHlwZWRBcnJheSxcbiAgICBXcmFwcGVySW5kZXhNYXBwaW5nLFxuICAgIE1vbWVudCxcbiAgICBTcGFyc2VJbWFnZVdyYXBwZXIsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCB2ZWMyID0geyBjbG9uZSB9O1xuXG50eXBlIFBvc2l0aXZlTnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyUG9zaXRpdmUodmFsOiBudW1iZXIpOiBhc3NlcnRzIHZhbCBpcyBQb3NpdGl2ZU51bWJlciB7XG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBwb3NpdGl2ZSBudW1iZXIsIHJlY2VpdmVkICR7dmFsfWApO1xuICAgIH1cbn1cblxuY2xhc3MgSW1hZ2VXcmFwcGVyIGltcGxlbWVudHMgU3BhcnNlSW1hZ2VXcmFwcGVyIHtcbiAgICBkYXRhOiBUeXBlZEFycmF5IHwgQXJyYXk8bnVtYmVyPjtcblxuICAgIHNpemU6IFhZU2l6ZTtcblxuICAgIGluZGV4TWFwcGluZz86IFdyYXBwZXJJbmRleE1hcHBpbmc7XG5cbiAgICAvLyBSZXByZXNlbnRzIGEgYmFzaWMgaW1hZ2UgY29tYmluaW5nIHRoZSBkYXRhIGFuZCBzaXplLiBJbiBhZGRpdGlvbiwgc29tZSBtZXRob2RzIGZvclxuICAgIC8vIG1hbmlwdWxhdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbi5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2l6ZTogWFlTaXplLFxuICAgICAgICBkYXRhPzogVHlwZWRBcnJheSB8IEFycmF5PG51bWJlcj4sXG4gICAgICAgIEFycmF5VHlwZTogVHlwZWRBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3RvciA9IFVpbnQ4QXJyYXksXG4gICAgICAgIGluaXRpYWxpemU/OiBib29sZWFuLFxuICAgICkge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyAoQXJyYXlUeXBlKShzaXplLnggKiBzaXplLnkpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICBBcnJheUhlbHBlci5pbml0KHRoaXMuZGF0YSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgLy8gdGVzdHMgaWYgYSBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGltYWdlLCBleHRlbmRlZCBvdXQgYnkgYSBib3JkZXIgb24gZWFjaCBzaWRlXG4gICAgaW5JbWFnZVdpdGhCb3JkZXIoaW1nUmVmOiBYWVNpemUsIGJvcmRlcjogUG9zaXRpdmVOdW1iZXIgPSAwKTogYm9vbGVhbiB7XG4gICAgICAgIGFzc2VydE51bWJlclBvc2l0aXZlKGJvcmRlcik7XG4gICAgICAgIC8vIFRPRE86IGNvZGVfMTI4IHN0YXJ0cyBmYWlsaW5nIG1pc2VyYWJseSB3aGVuIGkgb25seSBhbGxvdyBpbWdSZWYgdG8gY29udGFpbiBwb3NpdGl2ZSBudW1iZXJzLlxuICAgICAgICAvLyBUT0RPOiB0aGlzIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIG1lLCB3aHkgZG9lcyBpdCBnbyBuZWdhdGl2ZT8gIFRlc3RzIGFyZSBub3QgYWZmZWN0ZWQgYnlcbiAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlLCBidXQgdGhlIHdob2xlIGNvZGVfMTI4IHJlYWRlciBibG93cyB1cCB3aGVuIGkgdGhyb3cgb24gbmVnYXRpdmUgaW1nUmVmLlxuICAgICAgICAvLyBhc3NlcnROdW1iZXJQb3NpdGl2ZShpbWdSZWYueCk7XG4gICAgICAgIC8vIGFzc2VydE51bWJlclBvc2l0aXZlKGltZ1JlZi55KTtcbiAgICAgICAgcmV0dXJuIChpbWdSZWYueCA+PSAwKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55ID49IDApXG4gICAgICAgICAgICAmJiAoaW1nUmVmLnggPCAodGhpcy5zaXplLnggKyAoYm9yZGVyICogMikpKVxuICAgICAgICAgICAgJiYgKGltZ1JlZi55IDwgKHRoaXMuc2l6ZS55ICsgKGJvcmRlciAqIDIpKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBmcm9tIFRISVMgSW1hZ2VXcmFwcGVyIHRvIHRoZSBuZXcgaW1hZ2VXcmFwcGVyIHBhcmFtZXRlciwgc3RhcnRpbmcgYXQgZnJvbSwgc3RvcHBpbmcgYXRcbiAgICAvLyBlbmQgb2YgbmV3IGltYWdlV3JhcHBlciBzaXplLlxuICAgIHN1YkltYWdlQXNDb3B5KGltYWdlV3JhcHBlcjogSW1hZ2VXcmFwcGVyLCBmcm9tOiBYWVNpemUpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLngpO1xuICAgICAgICBhc3NlcnROdW1iZXJQb3NpdGl2ZShmcm9tLnkpO1xuICAgICAgICBjb25zdCB7IHg6IHNpemVYLCB5OiBzaXplWSB9ID0gaW1hZ2VXcmFwcGVyLnNpemU7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgc2l6ZVg7IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBzaXplWTsgeSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLmRhdGFbeSAqIHNpemVYICsgeF0gPSB0aGlzLmRhdGFbKGZyb20ueSArIHkpICogdGhpcy5zaXplLnggKyBmcm9tLnggKyB4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1hZ2VXcmFwcGVyO1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIHJlYWxseSBwcm9iYWJseSBzaG91bGQgY2FsbCBpbnRvIEltYWdlV3JhcHBlciBzb21ld2hlcmUgdG8gbWFrZVxuICAgICAgICAvLyBzdXJlIHRoYXQgYWxsIG9mIGl0J3MgcGFyYW1ldGVycyBhcmUgc2V0IHByb3Blcmx5LCBzb21ldGhpbmcgbGlrZVxuICAgICAgICAvLyBJbWFnZVdyYXBwZXIuVXBkYXRlRnJvbSgpXG4gICAgICAgIC8vIHRoYXQgbWlnaHQgdGFrZSBhIHByb3ZpZGVkIGRhdGEgYW5kIHNpemUsIGFuZCBtYWtlIHN1cmUgdGhlcmUncyBubyBpbnZhbGlkIGluZGV4TWFwcGluZ1xuICAgICAgICAvLyBoYW5naW5nIGFyb3VuZCwgYW5kIHN1Y2guXG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZVxuICAgIGdldCh4OiBudW1iZXIsIHk6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF07XG4gICAgfVxuXG4gICAgLy8gUmV0cmlldmUgYSBncmF5c2NhbGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBpeGVsIHBvc2l0aW9uIG9mIHRoZSBpbWFnZSAoc2FmZSwgd2hhdGV2ZXIgdGhhdFxuICAgIC8vIG1lYW5zKVxuICAgIGdldFNhZmUoeDogbnVtYmVyLCB5OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICAvLyBjYWNoZSBpbmRleE1hcHBpbmcgYmVjYXVzZSBpZiB3ZSdyZSB1c2luZyBpdCBvbmNlLCB3ZSdsbCBwcm9iYWJseSBuZWVkIGl0IGEgYnVuY2ggbW9yZVxuICAgICAgICAvLyB0b29cbiAgICAgICAgaWYgKCF0aGlzLmluZGV4TWFwcGluZykge1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemUueDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpXSA9IGk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleE1hcHBpbmcueFtpICsgdGhpcy5zaXplLnhdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplLnk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaV0gPSBpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBwaW5nLnlbaSArIHRoaXMuc2l6ZS55XSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVsodGhpcy5pbmRleE1hcHBpbmcueVt5ICsgdGhpcy5zaXplLnldKSAqIHRoaXMuc2l6ZS54ICsgdGhpcy5pbmRleE1hcHBpbmcueFt4ICsgdGhpcy5zaXplLnhdXTtcbiAgICB9XG5cbiAgICAvLyBTZXRzIGEgZ2l2ZW4gcGl4ZWwgcG9zaXRpb24gaW4gdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBncmF5c2NhbGUgdmFsdWVcbiAgICBzZXQoeDogbnVtYmVyLCB5OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICB0aGlzLmRhdGFbeSAqIHRoaXMuc2l6ZS54ICsgeF0gPSB2YWx1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBTZXRzIHRoZSBib3JkZXIgb2YgdGhlIGltYWdlICgxIHBpeGVsKSB0byB6ZXJvXG4gICAgemVyb0JvcmRlcigpOiBJbWFnZVdyYXBwZXIge1xuICAgICAgICBjb25zdCB7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbXVsdGktYXNzaWduXG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB0aGlzLmRhdGFbKGhlaWdodCAtIDEpICogd2lkdGggKyBpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICAgIHRoaXMuZGF0YVtpICogd2lkdGhdID0gdGhpcy5kYXRhW2kgKiB3aWR0aCArICh3aWR0aCAtIDEpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhNYXBwaW5nO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIGVudGlyZWx5IHRvbyBsYXJnZSBmb3IgbWUgdG8gcmVhc29uIG91dCByaWdodCBhdCB0aGlzIG1vbWVudCB0aGF0IGknbSBoYW5kbGluZ1xuICAgIC8vIGFsbCB0aGUgcmVzdCBvZiBpdCwgc28gdGhpcyBpcyBhIHZlcmJhdGltIGNvcHkgb2YgdGhlIGphdmFzY3JpcHQgc291cmNlLCB3aXRoIG9ubHkgdHdlYWtzXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGdldCBpdCB0byBydW4sIG5vIHRob3VnaHQgcHV0IGludG8gaXQgeWV0LlxuICAgIG1vbWVudHMobGFiZWxDb3VudDogbnVtYmVyKTogQXJyYXk8TW9tZW50PiB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemUueTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLnNpemUueDtcbiAgICAgICAgbGV0IHZhbDtcbiAgICAgICAgbGV0IHlzcTtcbiAgICAgICAgY29uc3QgbGFiZWxTdW06IEFycmF5PE1vbWVudD4gPSBbXTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBsYWJlbDtcbiAgICAgICAgbGV0IG11MTE7XG4gICAgICAgIGxldCBtdTAyO1xuICAgICAgICBsZXQgbXUyMDtcbiAgICAgICAgbGV0IHhfO1xuICAgICAgICBsZXQgeV87XG4gICAgICAgIGxldCB0bXA7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogQXJyYXk8TW9tZW50PiA9IFtdO1xuICAgICAgICBjb25zdCB7IFBJIH0gPSBNYXRoO1xuICAgICAgICBjb25zdCBQSV80ID0gUEkgLyA0O1xuXG4gICAgICAgIGlmIChsYWJlbENvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbFN1bVtpXSA9IHtcbiAgICAgICAgICAgICAgICBtMDA6IDAsXG4gICAgICAgICAgICAgICAgbTAxOiAwLFxuICAgICAgICAgICAgICAgIG0xMDogMCxcbiAgICAgICAgICAgICAgICBtMTE6IDAsXG4gICAgICAgICAgICAgICAgbTAyOiAwLFxuICAgICAgICAgICAgICAgIG0yMDogMCxcbiAgICAgICAgICAgICAgICB0aGV0YTogMCxcbiAgICAgICAgICAgICAgICByYWQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICB5c3EgPSB5ICogeTtcbiAgICAgICAgICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gZGF0YVt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW3ZhbCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMDAgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwubTAxICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0xMCArPSB4O1xuICAgICAgICAgICAgICAgICAgICBsYWJlbC5tMTEgKz0geCAqIHk7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0wMiArPSB5c3E7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLm0yMCArPSB4ICogeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsYWJlbCA9IGxhYmVsU3VtW2ldO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFsc1xuICAgICAgICAgICAgaWYgKCFpc05hTihsYWJlbC5tMDApICYmIGxhYmVsLm0wMCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHhfID0gbGFiZWwubTEwIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIHlfID0gbGFiZWwubTAxIC8gbGFiZWwubTAwO1xuICAgICAgICAgICAgICAgIG11MTEgPSBsYWJlbC5tMTEgLyBsYWJlbC5tMDAgLSB4XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MDIgPSBsYWJlbC5tMDIgLyBsYWJlbC5tMDAgLSB5XyAqIHlfO1xuICAgICAgICAgICAgICAgIG11MjAgPSBsYWJlbC5tMjAgLyBsYWJlbC5tMDAgLSB4XyAqIHhfO1xuICAgICAgICAgICAgICAgIHRtcCA9IChtdTAyIC0gbXUyMCkgLyAoMiAqIG11MTEpO1xuICAgICAgICAgICAgICAgIHRtcCA9IDAuNSAqIE1hdGguYXRhbih0bXApICsgKG11MTEgPj0gMCA/IFBJXzQgOiAtUElfNCkgKyBQSTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgbGFiZWwudGhldGEgPSAodG1wICogMTgwIC8gUEkgKyA5MCkgJSAxODAgLSA5MDtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwudGhldGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnRoZXRhICs9IDE4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFiZWwucmFkID0gdG1wID4gUEkgPyB0bXAgLSBQSSA6IHRtcDtcbiAgICAgICAgICAgICAgICBsYWJlbC52ZWMgPSB2ZWMyLmNsb25lKFtNYXRoLmNvcyh0bXApLCBNYXRoLnNpbih0bXApXSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIGEgVWludDhDbGFtcGVkQXJyYXkgY29udGFpbmluZyB0aGlzIGdyYXlzY2FsZSBpbWFnZSBjb252ZXJ0ZWQgdG8gUkdCQSBmb3JtXG4gICAgZ2V0QXNSR0JBKHNjYWxlID0gMS4wKTogVWludDhDbGFtcGVkQXJyYXkge1xuICAgICAgICBjb25zdCByZXQgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoNCAqIHRoaXMuc2l6ZS54ICogdGhpcy5zaXplLnkpO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZS55OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsID0geSAqIHRoaXMuc2l6ZS54ICsgeDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQoeCwgeSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgMF0gPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldFtwaXhlbCAqIDQgKyAxXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0W3BpeGVsICogNCArIDJdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICByZXRbcGl4ZWwgKiA0ICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvLyBEaXNwbGF5IHRoaXMgSW1hZ2VXcmFwcGVyIGluIGEgZ2l2ZW4gQ2FudmFzIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBzY2FsZVxuICAgIHNob3coY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgc2NhbGUgPSAxLjApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBnZXQgY2FudmFzIGNvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcmFtZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0QXNSR0JBKHNjYWxlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuc2l6ZS54O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuc2l6ZS55O1xuICAgICAgICBjb25zdCBuZXdGcmFtZSA9IG5ldyBJbWFnZURhdGEoZGF0YSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgIGN0eC5wdXRJbWFnZURhdGEobmV3RnJhbWUsIDAsIDApO1xuICAgIH1cblxuICAgIC8vIERpc3BsYXlzIGEgc3BlY2lmaWVkIFN1YkltYWdlIGFyZWEgaW4gYSBnaXZlbiBjYW52YXMuIFRoaXMgZGlmZmVycyBkcmFzdGljYWxseSBmcm9tXG4gICAgLy8gY3JlYXRpbmcgYSBuZXcgU3ViSW1hZ2UgYW5kIHVzaW5nIGl0J3Mgc2hvdygpIG1ldGhvZC4gV2h5PyBJIGRvbid0IGhhdmUgdGhlIGFuc3dlciB0byB0aGF0XG4gICAgLy8geWV0LiAgSSBzdXNwZWN0IHRoZSBIU1YvUkdCIG9wZXJhdGlvbnMgaW52b2x2ZWQgaGVyZSBhcmUgbWFraW5nIGl0IHNpZ25pZmljYW50bHkgZGlmZmVyZW50LFxuICAgIC8vIGJ1dCB1bnRpbCBJIGNhbiB2aXN1YWxpemUgdGhlc2UgZnVuY3Rpb25zIHNpZGUgYnkgc2lkZSwgSSdtIGp1c3QgZ29pbmcgdG8gY29weSB0aGUgZXhpc3RpbmdcbiAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICBvdmVybGF5KGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIGluU2NhbGU6IG51bWJlciwgZnJvbTogWFlTaXplKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkU2NhbGUgPSAoaW5TY2FsZSA8IDAgfHwgaW5TY2FsZSA+IDM2MCkgPyAzNjAgOiBpblNjYWxlO1xuICAgICAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgd2hpdGVSZ2IgPSBbMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIGNvbnN0IGJsYWNrUmdiID0gWzAsIDAsIDBdO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJhbWUgPSBjdHguZ2V0SW1hZ2VEYXRhKGZyb20ueCwgZnJvbS55LCB0aGlzLnNpemUueCwgdGhpcy5zaXplLnkpO1xuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGZyYW1lO1xuICAgICAgICBsZXQgeyBsZW5ndGggfSA9IHRoaXMuZGF0YTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBoc3ZbMF0gPSB0aGlzLmRhdGFbbGVuZ3RoXSAqIGFkanVzdGVkU2NhbGU7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIHJlc3VsdCA9IGhzdlswXSA8PSAwID8gd2hpdGVSZ2IgOiBoc3ZbMF0gPj0gMzYwID8gYmxhY2tSZ2IgOiBoc3YycmdiKGhzdiwgcmdiKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGxlbmd0aCAqIDQ7XG4gICAgICAgICAgICBbZGF0YVtwb3NdLCBkYXRhW3BvcyArIDFdLCBkYXRhW3BvcyArIDJdXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGRhdGFbcG9zICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShmcmFtZSwgZnJvbS54LCBmcm9tLnkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VXcmFwcGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4xNSc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZyxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXHMrLyxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXHMrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VTb3J0QnkocmVzdWx0LCBmdW5jdGlvbihvYmplY3QsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnBpY2tgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiAgYF8ucGlja0J5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgcGF0aCkpIHtcbiAgICAgICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQWxsQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICAgKiBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXhPZiA9IGNvbXBhcmF0b3IgPyBiYXNlSW5kZXhPZldpdGggOiBiYXNlSW5kZXhPZixcbiAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgc2VlbiA9IGFycmF5O1xuXG4gICAgICBpZiAoYXJyYXkgPT09IHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBjb3B5QXJyYXkodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IDAsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tSW5kZXggPSBpbmRleE9mKHNlZW4sIGNvbXB1dGVkLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpKSA+IC0xKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChzZWVuLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID8gaW5kZXhlcy5sZW5ndGggOiAwLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICAgICAqIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVwZWF0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlcGVhdChzdHJpbmcsIG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIGlmICghc3RyaW5nIHx8IG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICAvLyBMZXZlcmFnZSB0aGUgZXhwb25lbnRpYXRpb24gYnkgc3F1YXJpbmcgYWxnb3JpdGhtIGZvciBhIGZhc3RlciByZXBlYXQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXhwb25lbnRpYXRpb25fYnlfc3F1YXJpbmcgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG4gJSAyKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBuID0gbmF0aXZlRmxvb3IobiAvIDIpO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVTaXplYCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4pIHtcbiAgICAgIHZhciBhcnJheSA9IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICAgIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG4gICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0RGF0YWAgd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0RGF0YSA9ICFtZXRhTWFwID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBkYXRhKSB7XG4gICAgICBtZXRhTWFwLnNldChmdW5jLCBkYXRhKTtcbiAgICAgIHJldHVybiBmdW5jO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICAgICAgc3RhcnQgPj4+PSAwO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiAhcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhgIHdoaWNoXG4gICAgICogcGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIG9mIGBhcnJheWAgdG8gZGV0ZXJtaW5lIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyBsb3cgOiBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMSxcbiAgICAgICAgICAgICAgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuXG4gICAgICAgICAgaWYgKGNvbXB1dGVkICE9PSBudWxsICYmICFpc1N5bWJvbChjb21wdXRlZCkgJiZcbiAgICAgICAgICAgICAgKHJldEhpZ2hlc3QgPyAoY29tcHV0ZWQgPD0gdmFsdWUpIDogKGNvbXB1dGVkIDwgdmFsdWUpKSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkSW5kZXhCeWAgYW5kIGBfLnNvcnRlZExhc3RJbmRleEJ5YFxuICAgICAqIHdoaWNoIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZVxuICAgICAqIHRoZWlyIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgdmFsSXNOYU4gPSB2YWx1ZSAhPT0gdmFsdWUsXG4gICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSksXG4gICAgICAgICAgdmFsSXNVbmRlZmluZWQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKGFycmF5W21pZF0pLFxuICAgICAgICAgICAgb3RoSXNEZWZpbmVkID0gY29tcHV0ZWQgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG90aElzTnVsbCA9IGNvbXB1dGVkID09PSBudWxsLFxuICAgICAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBjb21wdXRlZCA9PT0gY29tcHV0ZWQsXG4gICAgICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcblxuICAgICAgICBpZiAodmFsSXNOYU4pIHtcbiAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1VuZGVmaW5lZCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIChyZXRIaWdoZXN0IHx8IG90aElzRGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc051bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdGhJc051bGwgfHwgb3RoSXNTeW1ib2wpIHtcbiAgICAgICAgICBzZXRMb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRMb3cgPSByZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0TG93KSB7XG4gICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWluKGhpZ2gsIE1BWF9BUlJBWV9JTkRFWCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydGVkVW5pcWAgYW5kIGBfLnNvcnRlZFVuaXFCeWAgd2l0aG91dFxuICAgICAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgaWYgKCFpbmRleCB8fCAhZXEoY29tcHV0ZWQsIHNlZW4pKSB7XG4gICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b051bWJlcmAgd2hpY2ggZG9lc24ndCBlbnN1cmUgY29ycmVjdFxuICAgICAqIGNvbnZlcnNpb25zIG9mIGJpbmFyeSwgaGV4YWRlY2ltYWwsIG9yIG9jdGFsIHN0cmluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VUb051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICByZXR1cm4gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICAgICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgICAgIGlmIChzZXQpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgcmV0dXJuIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB1cGRhdGVyKGJhc2VHZXQob2JqZWN0LCBwYXRoKSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kcm9wV2hpbGVgIGFuZCBgXy50YWtlV2hpbGVgXG4gICAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEcm9wXSBTcGVjaWZ5IGRyb3BwaW5nIGVsZW1lbnRzIGluc3RlYWQgb2YgdGFraW5nIHRoZW0uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VXaGlsZShhcnJheSwgcHJlZGljYXRlLCBpc0Ryb3AsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xO1xuXG4gICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJlxuICAgICAgICBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7fVxuXG4gICAgICByZXR1cm4gaXNEcm9wXG4gICAgICAgID8gYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gMCA6IGluZGV4KSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IGxlbmd0aCkpXG4gICAgICAgIDogYmFzZVNsaWNlKGFycmF5LCAoZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCksIChmcm9tUmlnaHQgPyBsZW5ndGggOiBpbmRleCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGB3cmFwcGVyVmFsdWVgIHdoaWNoIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAgICAqIHBlcmZvcm1pbmcgYSBzZXF1ZW5jZSBvZiBhY3Rpb25zIG9uIHRoZSB1bndyYXBwZWQgYHZhbHVlYCwgd2hlcmUgZWFjaFxuICAgICAqIHN1Y2Nlc3NpdmUgYWN0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYWN0aW9ucyBBY3Rpb25zIHRvIHBlcmZvcm0gdG8gcmVzb2x2ZSB0aGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV3JhcHBlclZhbHVlKHZhbHVlLCBhY3Rpb25zKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnZhbHVlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlSZWR1Y2UoYWN0aW9ucywgZnVuY3Rpb24ocmVzdWx0LCBhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbi5mdW5jLmFwcGx5KGFjdGlvbi50aGlzQXJnLCBhcnJheVB1c2goW3Jlc3VsdF0sIGFjdGlvbi5hcmdzKSk7XG4gICAgICB9LCByZXN1bHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy54b3JgLCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VYb3IoYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVVuaXEoYXJyYXlzWzBdKSA6IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgICAgIG90aEluZGV4ID0gLTE7XG5cbiAgICAgICAgd2hpbGUgKCsrb3RoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBiYXNlRGlmZmVyZW5jZShyZXN1bHRbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZSwgY29tcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4ocmVzdWx0LCAxKSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCxcbiAgICAgICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGFuIGVtcHR5IGFycmF5IGlmIGl0J3Mgbm90IGFuIGFycmF5IGxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgdGhlIGNhc3QgYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSA/IHZhbHVlIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGNhc3QgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGlkZW50aXR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBgYmFzZVJlc3RgIGFsaWFzIHdoaWNoIGNhbiBiZSByZXBsYWNlZCB3aXRoIGBpZGVudGl0eWAgYnkgbW9kdWxlXG4gICAgICogcmVwbGFjZW1lbnQgcGx1Z2lucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgYXJyYXlgIHRvIGEgc2xpY2UgaWYgaXQncyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBzbGljZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BjbGVhclRpbWVvdXRgXShodHRwczovL21kbi5pby9jbGVhclRpbWVvdXQpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcnxPYmplY3R9IGlkIFRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdCBvZiB0aGUgdGltZXIgdG8gY2xlYXIuXG4gICAgICovXG4gICAgdmFyIGNsZWFyVGltZW91dCA9IGN0eENsZWFyVGltZW91dCB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgICAgIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICAgIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICAgICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICAgICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAgICAgKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAgICAgKlxuICAgICAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gICAgICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICAgICAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gICAgICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAgICAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cyxcbiAgICAgKiBwbGFjZWhvbGRlcnMsIGFuZCBwcm92aWRlZCBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpIHtcbiAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLFxuICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgIGxlZnRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlZnRMZW5ndGggKyByYW5nZUxlbmd0aCksXG4gICAgICAgICAgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuXG4gICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlZnRJbmRleCsrXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGNvbXBvc2VBcmdzYCBleGNlcHQgdGhhdCB0aGUgYXJndW1lbnRzIGNvbXBvc2l0aW9uXG4gICAgICogaXMgdGFpbG9yZWQgZm9yIGBfLnBhcnRpYWxSaWdodGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIGFwcGVuZCB0byB0aG9zZSBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBob2xkZXJzIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtcyB7Ym9vbGVhbn0gW2lzQ3VycmllZF0gU3BlY2lmeSBjb21wb3NpbmcgZm9yIGEgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21wb3NlZCBhcmd1bWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcG9zZUFyZ3NSaWdodChhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNJbmRleCA9IC0xLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICByaWdodEluZGV4ID0gLTEsXG4gICAgICAgICAgcmlnaHRMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGgsXG4gICAgICAgICAgcmFuZ2VMZW5ndGggPSBuYXRpdmVNYXgoYXJnc0xlbmd0aCAtIGhvbGRlcnNMZW5ndGgsIDApLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KHJhbmdlTGVuZ3RoICsgcmlnaHRMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrYXJnc0luZGV4IDwgcmFuZ2VMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2FyZ3NJbmRleF0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgd2hpbGUgKCsrcmlnaHRJbmRleCA8IHJpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraG9sZGVyc0luZGV4IDwgaG9sZGVyc0xlbmd0aCkge1xuICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgIHJlc3VsdFtvZmZzZXQgKyBob2xkZXJzW2hvbGRlcnNJbmRleF1dID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gICAgICB2YXIgaXNOZXcgPSAhb2JqZWN0O1xuICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV3KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFnZ3JlZ2F0b3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIHNldHRlciwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGludm9rZSBpdCB3aXRoIHRoZSBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgICAgID8gc3RyaW5nVG9BcnJheShzdHJpbmcpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IHN0clN5bWJvbHNbMF1cbiAgICAgICAgICA6IHN0cmluZy5jaGFyQXQoMCk7XG5cbiAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDEpLmpvaW4oJycpXG4gICAgICAgICAgOiBzdHJpbmcuc2xpY2UoMSk7XG5cbiAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmNhbWVsQ2FzZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lIGVhY2ggd29yZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3VuZGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvdW5kZXIoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCAnJykpLCBjYWxsYmFjaywgJycpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBpbnN0YW5jZSBvZiBgQ3RvcmAgcmVnYXJkbGVzcyBvZlxuICAgICAqIHdoZXRoZXIgaXQgd2FzIGludm9rZWQgYXMgcGFydCBvZiBhIGBuZXdgIGV4cHJlc3Npb24gb3IgYnkgYGNhbGxgIG9yIGBhcHBseWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IEN0b3IgVGhlIGNvbnN0cnVjdG9yIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdG9yKEN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gVXNlIGEgYHN3aXRjaGAgc3RhdGVtZW50IHRvIHdvcmsgd2l0aCBjbGFzcyBjb25zdHJ1Y3RvcnMuIFNlZVxuICAgICAgICAvLyBodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWZ1bmN0aW9uLW9iamVjdHMtY2FsbC10aGlzYXJndW1lbnQtYXJndW1lbnRzbGlzdFxuICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDdG9yO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0pO1xuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGNhc2UgNzogcmV0dXJuIG5ldyBDdG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0sIGFyZ3NbNl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGJhc2VDcmVhdGUoQ3Rvci5wcm90b3R5cGUpLFxuICAgICAgICAgICAgcmVzdWx0ID0gQ3Rvci5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG5cbiAgICAgICAgLy8gTWltaWMgdGhlIGNvbnN0cnVjdG9yJ3MgYHJldHVybmAgYmVoYXZpb3IuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2VzNS5naXRodWIuaW8vI3gxMy4yLjIgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiB0aGlzQmluZGluZztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGVuYWJsZSBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcml0eSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgIHZhciBDdG9yID0gY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlcik7XG5cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhvbGRlcnMgPSAobGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlcilcbiAgICAgICAgICA/IFtdXG4gICAgICAgICAgOiByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJncywgaG9sZGVycywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5IC0gbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgIHZhciBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8uZmxvd2Agb3IgYF8uZmxvd1JpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxvdyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGbG93KGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmNzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHByZXJlcSA9IExvZGFzaFdyYXBwZXIucHJvdG90eXBlLnRocnU7XG5cbiAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgIGZ1bmNzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIHZhciBmdW5jID0gZnVuY3NbaW5kZXhdO1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmVyZXEgJiYgIXdyYXBwZXIgJiYgZ2V0RnVuY05hbWUoZnVuYykgPT0gJ3dyYXBwZXInKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBMb2Rhc2hXcmFwcGVyKFtdLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSB3cmFwcGVyID8gaW5kZXggOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZnVuYyA9IGZ1bmNzW2luZGV4XTtcblxuICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLFxuICAgICAgICAgICAgICBkYXRhID0gZnVuY05hbWUgPT0gJ3dyYXBwZXInID8gZ2V0RGF0YShmdW5jKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChkYXRhICYmIGlzTGF6aWFibGUoZGF0YVswXSkgJiZcbiAgICAgICAgICAgICAgICBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmXG4gICAgICAgICAgICAgICAgIWRhdGFbNF0ubGVuZ3RoICYmIGRhdGFbOV0gPT0gMVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSB3cmFwcGVyW2dldEZ1bmNOYW1lKGRhdGFbMF0pXS5hcHBseSh3cmFwcGVyLCBkYXRhWzNdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JhcHBlciA9IChmdW5jLmxlbmd0aCA9PSAxICYmIGlzTGF6aWFibGUoZnVuYykpXG4gICAgICAgICAgICAgID8gd3JhcHBlcltmdW5jTmFtZV0oKVxuICAgICAgICAgICAgICA6IHdyYXBwZXIudGhydShmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgICBpZiAod3JhcHBlciAmJiBhcmdzLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5wbGFudCh2YWx1ZSkudmFsdWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbGVuZ3RoID8gZnVuY3NbaW5kZXhdLmFwcGx5KHRoaXMsIGFyZ3MpIDogdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuY3NbaW5kZXhdLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCBvcHRpb25hbCBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCwgcGFydGlhbCBhcHBsaWNhdGlvbiwgYW5kIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNSaWdodF0gVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWRcbiAgICAgKiAgdG8gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc1JpZ2h0XSBUaGUgYHBhcnRpYWxzUmlnaHRgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSHlicmlkKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQXJ5ID0gYml0bWFzayAmIFdSQVBfQVJZX0ZMQUcsXG4gICAgICAgICAgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsXG4gICAgICAgICAgaXNDdXJyaWVkID0gYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpLFxuICAgICAgICAgIGlzRmxpcCA9IGJpdG1hc2sgJiBXUkFQX0ZMSVBfRkxBRyxcbiAgICAgICAgICBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogY3JlYXRlQ3RvcihmdW5jKTtcblxuICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0N1cnJpZWQpIHtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksXG4gICAgICAgICAgICAgIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxzKSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFsc1JpZ2h0KSB7XG4gICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzQ291bnQ7XG4gICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgbmV3SG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKGFyZ3MsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUmVjdXJyeShcbiAgICAgICAgICAgIGZ1bmMsIGJpdG1hc2ssIGNyZWF0ZUh5YnJpZCwgd3JhcHBlci5wbGFjZWhvbGRlciwgdGhpc0FyZyxcbiAgICAgICAgICAgIGFyZ3MsIG5ld0hvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsXG4gICAgICAgICAgICBmbiA9IGlzQmluZEtleSA/IHRoaXNCaW5kaW5nW2Z1bmNdIDogZnVuYztcblxuICAgICAgICBsZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKGFyZ1Bvcykge1xuICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGbGlwICYmIGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnkgJiYgYXJ5IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJncy5sZW5ndGggPSBhcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgIGZuID0gQ3RvciB8fCBjcmVhdGVDdG9yKGZuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uaW52ZXJ0QnlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdG9JdGVyYXRlZSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSBpdGVyYXRlZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52ZXJ0ZXIoc2V0dGVyLCB0b0l0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCB0b0l0ZXJhdGVlKGl0ZXJhdGVlKSwge30pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIG1hdGhlbWF0aWNhbCBvcGVyYXRpb24gb24gdHdvIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3BlcmF0b3IgVGhlIGZ1bmN0aW9uIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHVzZWQgZm9yIGB1bmRlZmluZWRgIGFyZ3VtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hdGhPcGVyYXRpb24ob3BlcmF0b3IsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvdGhlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb1N0cmluZyhvdGhlcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIG90aGVyID0gYmFzZVRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5vdmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gYXJyYXlGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG92ZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlT3ZlcihhcnJheUZ1bmMpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gYXJyYXlGdW5jKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZSwgdGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgcGFkZGluZyBmb3IgYHN0cmluZ2AgYmFzZWQgb24gYGxlbmd0aGAuIFRoZSBgY2hhcnNgIHN0cmluZ1xuICAgICAqIGlzIHRydW5jYXRlZCBpZiB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZXhjZWVkcyBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgY2hhcnMgPSBjaGFycyA9PT0gdW5kZWZpbmVkID8gJyAnIDogYmFzZVRvU3RyaW5nKGNoYXJzKTtcblxuICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgaWYgKGNoYXJzTGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY2hhcnNMZW5ndGggPyBiYXNlUmVwZWF0KGNoYXJzLCBsZW5ndGgpIDogY2hhcnM7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVJlcGVhdChjaGFycywgbmF0aXZlQ2VpbChsZW5ndGggLyBzdHJpbmdTaXplKGNoYXJzKSkpO1xuICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpXG4gICAgICAgID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0KSwgMCwgbGVuZ3RoKS5qb2luKCcnKVxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmdcbiAgICAgKiBvZiBgdGhpc0FyZ2AgYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFscyBUaGUgYXJndW1lbnRzIHRvIHByZXBlbmQgdG8gdGhvc2UgcHJvdmlkZWQgdG9cbiAgICAgKiAgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSxcbiAgICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgbGVmdEluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSxcbiAgICAgICAgICAgIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcblxuICAgICAgICB3aGlsZSAoKytsZWZ0SW5kZXggPCBsZWZ0TGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoYXJnc0xlbmd0aC0tKSB7XG4gICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmbiwgaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdGFydCwgZW5kLCBzdGVwKSkge1xuICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHJlbGF0aW9uYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVsYXRpb25hbCBvcGVyYXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG90aGVyID09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIG90aGVyID0gdG9OdW1iZXIob3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gY29udGludWUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwRnVuYyBUaGUgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBgZnVuY2Agd3JhcHBlci5cbiAgICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjdXJyeShmdW5jLCBiaXRtYXNrLCB3cmFwRnVuYywgcGxhY2Vob2xkZXIsIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRyxcbiAgICAgICAgICBuZXdIb2xkZXJzID0gaXNDdXJyeSA/IGhvbGRlcnMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZCA6IGhvbGRlcnMsXG4gICAgICAgICAgbmV3UGFydGlhbHMgPSBpc0N1cnJ5ID8gcGFydGlhbHMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbmV3UGFydGlhbHNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBwYXJ0aWFscztcblxuICAgICAgYml0bWFzayB8PSAoaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcblxuICAgICAgaWYgKCEoYml0bWFzayAmIFdSQVBfQ1VSUllfQk9VTkRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBuZXdQYXJ0aWFscywgbmV3SG9sZGVycywgbmV3UGFydGlhbHNSaWdodCxcbiAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIHZhciByZXN1bHQgPSB3cmFwRnVuYy5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgaWYgKGlzTGF6aWFibGUoZnVuYykpIHtcbiAgICAgICAgc2V0RGF0YShyZXN1bHQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHJlc3VsdCwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ucm91bmRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYE1hdGhgIG1ldGhvZCB0byB1c2Ugd2hlbiByb3VuZGluZy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByb3VuZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IE1hdGhbbWV0aG9kTmFtZV07XG4gICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09IG51bGwgPyAwIDogbmF0aXZlTWluKHRvSW50ZWdlcihwcmVjaXNpb24pLCAyOTIpO1xuICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAvLyBTaGlmdCB3aXRoIGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGF2b2lkIGZsb2F0aW5nLXBvaW50IGlzc3Vlcy5cbiAgICAgICAgICAvLyBTZWUgW01ETl0oaHR0cHM6Ly9tZG4uaW8vcm91bmQjRXhhbXBsZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArICdlJykuc3BsaXQoJ2UnKSxcbiAgICAgICAgICAgICAgdmFsdWUgPSBmdW5jKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcblxuICAgICAgICAgIHBhaXIgPSAodG9TdHJpbmcodmFsdWUpICsgJ2UnKS5zcGxpdCgnZScpO1xuICAgICAgICAgIHJldHVybiArKHBhaXJbMF0gKyAnZScgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuYyhudW1iZXIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAgICAgKi9cbiAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLnRvUGFpcnNgIG9yIGBfLnRvUGFpcnNJbmAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFpcnMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVG9QYWlycyhrZXlzRnVuYykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKG9iamVjdCk7XG4gICAgICAgIGlmICh0YWcgPT0gbWFwVGFnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09IHNldFRhZykge1xuICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2VUb1BhaXJzKG9iamVjdCwga2V5c0Z1bmMob2JqZWN0KSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGVpdGhlciBjdXJyaWVzIG9yIGludm9rZXMgYGZ1bmNgIHdpdGggb3B0aW9uYWxcbiAgICAgKiBgdGhpc2AgYmluZGluZyBhbmQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gb3IgbWV0aG9kIG5hbWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgICAxIC0gYF8uYmluZGBcbiAgICAgKiAgICAyIC0gYF8uYmluZEtleWBcbiAgICAgKiAgICA0IC0gYF8uY3VycnlgIG9yIGBfLmN1cnJ5UmlnaHRgIG9mIGEgYm91bmQgZnVuY3Rpb25cbiAgICAgKiAgICA4IC0gYF8uY3VycnlgXG4gICAgICogICAxNiAtIGBfLmN1cnJ5UmlnaHRgXG4gICAgICogICAzMiAtIGBfLnBhcnRpYWxgXG4gICAgICogICA2NCAtIGBfLnBhcnRpYWxSaWdodGBcbiAgICAgKiAgMTI4IC0gYF8ucmVhcmdgXG4gICAgICogIDI1NiAtIGBfLmFyeWBcbiAgICAgKiAgNTEyIC0gYF8uZmxpcGBcbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbaG9sZGVyc10gVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnUG9zXSBUaGUgYXJndW1lbnQgcG9zaXRpb25zIG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcnldIFRoZSBhcml0eSBjYXAgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKCFpc0JpbmRLZXkgJiYgdHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGFydGlhbHMgPyBwYXJ0aWFscy5sZW5ndGggOiAwO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpO1xuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnkgPSBhcnkgPT09IHVuZGVmaW5lZCA/IGFyeSA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5KSwgMCk7XG4gICAgICBhcml0eSA9IGFyaXR5ID09PSB1bmRlZmluZWQgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICBsZW5ndGggLT0gaG9sZGVycyA/IGhvbGRlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICB2YXIgcGFydGlhbHNSaWdodCA9IHBhcnRpYWxzLFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcblxuICAgICAgICBwYXJ0aWFscyA9IGhvbGRlcnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB2YXIgZGF0YSA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGdldERhdGEoZnVuYyk7XG5cbiAgICAgIHZhciBuZXdEYXRhID0gW1xuICAgICAgICBmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LFxuICAgICAgICBhcmdQb3MsIGFyeSwgYXJpdHlcbiAgICAgIF07XG5cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIG1lcmdlRGF0YShuZXdEYXRhLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGZ1bmMgPSBuZXdEYXRhWzBdO1xuICAgICAgYml0bWFzayA9IG5ld0RhdGFbMV07XG4gICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgIHBhcnRpYWxzID0gbmV3RGF0YVszXTtcbiAgICAgIGhvbGRlcnMgPSBuZXdEYXRhWzRdO1xuICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gKGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aClcbiAgICAgICAgOiBuYXRpdmVNYXgobmV3RGF0YVs5XSAtIGxlbmd0aCwgMCk7XG5cbiAgICAgIGlmICghYXJpdHkgJiYgYml0bWFzayAmIChXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0NVUlJZX0ZMQUcgfCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpO1xuICAgICAgfVxuICAgICAgaWYgKCFiaXRtYXNrIHx8IGJpdG1hc2sgPT0gV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICB9IGVsc2UgaWYgKGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHIHx8IGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgIH0gZWxzZSBpZiAoKGJpdG1hc2sgPT0gV1JBUF9QQVJUSUFMX0ZMQUcgfHwgYml0bWFzayA9PSAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX1BBUlRJQUxfRkxBRykpICYmICFob2xkZXJzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQsIG5ld0RhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICByZXR1cm4gc2V0V3JhcFRvU3RyaW5nKHNldHRlcihyZXN1bHQsIG5ld0RhdGEpLCBmdW5jLCBiaXRtYXNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAgICAgKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICAgICAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgcmV0dXJuIHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNEZWVwYCB0byBjdXN0b21pemUgaXRzIGBfLm1lcmdlYCB1c2UgdG8gbWVyZ2Ugc291cmNlXG4gICAgICogb2JqZWN0cyBpbnRvIGRlc3RpbmF0aW9uIG9iamVjdHMgdGhhdCBhcmUgcGFzc2VkIHRocnUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBzcmNWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKSB7XG4gICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgIGJhc2VNZXJnZShvYmpWYWx1ZSwgc3JjVmFsdWUsIHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSwgc3RhY2spO1xuICAgICAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8ub21pdGAgdG8gY3VzdG9taXplIGl0cyBgXy5jbG9uZURlZXBgIHVzZSB0byBvbmx5IGNsb25lIHBsYWluXG4gICAgICogb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHVuY2xvbmVkIHZhbHVlIG9yIGB1bmRlZmluZWRgIHRvIGRlZmVyIGNsb25pbmcgdG8gYF8uY2xvbmVEZWVwYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgICAgIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgICAgIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gICAgICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICAgICAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgICAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCBmbGF0dGVucyB0aGUgcmVzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICAgICAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgcmV0dXJuIG1ldGFNYXAuZ2V0KGZ1bmMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYW1lIG9mIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGdW5jTmFtZShmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gKGZ1bmMubmFtZSArICcnKSxcbiAgICAgICAgICBhcnJheSA9IHJlYWxOYW1lc1tyZXN1bHRdLFxuICAgICAgICAgIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQpID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBkYXRhID0gYXJyYXlbbGVuZ3RoXSxcbiAgICAgICAgICAgIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgaWYgKG90aGVyRnVuYyA9PSBudWxsIHx8IG90aGVyRnVuYyA9PSBmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEubmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhcmd1bWVudCBwbGFjZWhvbGRlciB2YWx1ZSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgdmFyIG9iamVjdCA9IGhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLCAncGxhY2Vob2xkZXInKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICByZXR1cm4gb2JqZWN0LnBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIFwiaXRlcmF0ZWVcIiBmdW5jdGlvbi4gSWYgYF8uaXRlcmF0ZWVgIGlzIGN1c3RvbWl6ZWQsXG4gICAgICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjdXN0b20gbWV0aG9kLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgYmFzZUl0ZXJhdGVlYC5cbiAgICAgKiBJZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCB0aGUgY2hvc2VuIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCB0aGVtIGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgdGhlIGNyZWF0ZWQgaXRlcmF0ZWUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjaG9zZW4gZnVuY3Rpb24gb3IgaXRzIHJlc3VsdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2guaXRlcmF0ZWUgfHwgaXRlcmF0ZWU7XG4gICAgICByZXN1bHQgPSByZXN1bHQgPT09IGl0ZXJhdGVlID8gYmFzZUl0ZXJhdGVlIDogcmVzdWx0O1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByZXN1bHQoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgICAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gICAgICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICAgICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICAgICAgOiBkYXRhLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICAgICAqL1xuICAgIHZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICAgKi9cbiAgICB2YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuICAgIC8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbiAgICBpZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAgICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgICAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgICAgIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICAgICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2aWV3LCBhcHBseWluZyBhbnkgYHRyYW5zZm9ybXNgIHRvIHRoZSBgc3RhcnRgIGFuZCBgZW5kYCBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybXMgVGhlIHRyYW5zZm9ybWF0aW9ucyB0byBhcHBseSB0byB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgc3RhcnRgIGFuZCBgZW5kYFxuICAgICAqICBwb3NpdGlvbnMgb2YgdGhlIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmlldyhzdGFydCwgZW5kLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSxcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdkcm9wJzogICAgICBzdGFydCArPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICdkcm9wUmlnaHQnOiBlbmQgLT0gc2l6ZTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZSc6ICAgICAgZW5kID0gbmF0aXZlTWluKGVuZCwgc3RhcnQgKyBzaXplKTsgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndGFrZVJpZ2h0Jzogc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUpOyBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgJ3N0YXJ0Jzogc3RhcnQsICdlbmQnOiBlbmQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB3cmFwcGVyIGRldGFpbHMgZnJvbSB0aGUgYHNvdXJjZWAgYm9keSBjb21tZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIFRoZSBzb3VyY2UgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdyYXBwZXIgZGV0YWlscy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRXcmFwRGV0YWlscyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaCA9IHNvdXJjZS5tYXRjaChyZVdyYXBEZXRhaWxzKTtcbiAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICAgICAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICAgICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICAgICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA6IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgICAgIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgICAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgICAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgICAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBzZXRUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgd3JhcHBlciBgZGV0YWlsc2AgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIGBzb3VyY2VgIGJvZHkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIGluc2VydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzb3VyY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZGV0YWlscy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/ICcmICcgOiAnJykgKyBkZXRhaWxzW2xhc3RJbmRleF07XG4gICAgICBkZXRhaWxzID0gZGV0YWlscy5qb2luKGxlbmd0aCA+IDIgPyAnLCAnIDogJyAnKTtcbiAgICAgIHJldHVybiBzb3VyY2UucmVwbGFjZShyZVdyYXBDb21tZW50LCAne1xcbi8qIFt3cmFwcGVkIHdpdGggJyArIGRldGFpbHMgKyAnXSAqL1xcbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAgICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICAgIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gICAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICAgIDogKHZhbHVlID09PSBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBhIGxhenkgY291bnRlcnBhcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGF6aWFibGUoZnVuYykge1xuICAgICAgdmFyIGZ1bmNOYW1lID0gZ2V0RnVuY05hbWUoZnVuYyksXG4gICAgICAgICAgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mIG90aGVyICE9ICdmdW5jdGlvbicgfHwgIShmdW5jTmFtZSBpbiBMYXp5V3JhcHBlci5wcm90b3R5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmdW5jID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gZ2V0RGF0YShvdGhlcik7XG4gICAgICByZXR1cm4gISFkYXRhICYmIGZ1bmMgPT09IGRhdGFbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGlzIGNhcGFibGUgb2YgYmVpbmcgbWFza2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2thYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICAgICAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICAgICAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgICAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0aGUgZnVuY3Rpb24gbWV0YWRhdGEgb2YgYHNvdXJjZWAgaW50byBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBNZXJnaW5nIG1ldGFkYXRhIHJlZHVjZXMgdGhlIG51bWJlciBvZiB3cmFwcGVycyB1c2VkIHRvIGludm9rZSBhIGZ1bmN0aW9uLlxuICAgICAqIFRoaXMgaXMgcG9zc2libGUgYmVjYXVzZSBtZXRob2RzIGxpa2UgYF8uYmluZGAsIGBfLmN1cnJ5YCwgYW5kIGBfLnBhcnRpYWxgXG4gICAgICogbWF5IGJlIGFwcGxpZWQgcmVnYXJkbGVzcyBvZiBleGVjdXRpb24gb3JkZXIuIE1ldGhvZHMgbGlrZSBgXy5hcnlgIGFuZFxuICAgICAqIGBfLnJlYXJnYCBtb2RpZnkgZnVuY3Rpb24gYXJndW1lbnRzLCBtYWtpbmcgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlXG4gICAgICogZXhlY3V0ZWQgaW1wb3J0YW50LCBwcmV2ZW50aW5nIHRoZSBtZXJnaW5nIG9mIG1ldGFkYXRhLiBIb3dldmVyLCB3ZSBtYWtlXG4gICAgICogYW4gZXhjZXB0aW9uIGZvciBhIHNhZmUgY29tYmluZWQgY2FzZSB3aGVyZSBjdXJyaWVkIGZ1bmN0aW9ucyBoYXZlIGBfLmFyeWBcbiAgICAgKiBhbmQgb3IgYF8ucmVhcmdgIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgVGhlIGRlc3RpbmF0aW9uIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgc291cmNlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGF0YWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgdmFyIGJpdG1hc2sgPSBkYXRhWzFdLFxuICAgICAgICAgIHNyY0JpdG1hc2sgPSBzb3VyY2VbMV0sXG4gICAgICAgICAgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLFxuICAgICAgICAgIGlzQ29tbW9uID0gbmV3Qml0bWFzayA8IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyB8IFdSQVBfQVJZX0ZMQUcpO1xuXG4gICAgICB2YXIgaXNDb21ibyA9XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRykgJiYgKGJpdG1hc2sgPT0gV1JBUF9SRUFSR19GTEFHKSAmJiAoZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSkgfHxcbiAgICAgICAgKChzcmNCaXRtYXNrID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSkgJiYgKHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdKSAmJiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcpKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSBpZiBtZXRhZGF0YSBjYW4ndCBiZSBtZXJnZWQuXG4gICAgICBpZiAoIShpc0NvbW1vbiB8fCBpc0NvbWJvKSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYHRoaXNBcmdgIGlmIGF2YWlsYWJsZS5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcpIHtcbiAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgLy8gU2V0IHdoZW4gY3VycnlpbmcgYSBib3VuZCBmdW5jdGlvbi5cbiAgICAgICAgbmV3Qml0bWFzayB8PSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcgPyAwIDogV1JBUF9DVVJSWV9CT1VORF9GTEFHO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIGFyZ3VtZW50cy5cbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVszXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbHMgPSBkYXRhWzNdO1xuICAgICAgICBkYXRhWzNdID0gcGFydGlhbHMgPyBjb21wb3NlQXJncyhwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs0XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgfVxuICAgICAgLy8gQ29tcG9zZSBwYXJ0aWFsIHJpZ2h0IGFyZ3VtZW50cy5cbiAgICAgIHZhbHVlID0gc291cmNlWzVdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgZGF0YVs1XSA9IHBhcnRpYWxzID8gY29tcG9zZUFyZ3NSaWdodChwYXJ0aWFscywgdmFsdWUsIHNvdXJjZVs2XSkgOiB2YWx1ZTtcbiAgICAgICAgZGF0YVs2XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVs1XSwgUExBQ0VIT0xERVIpIDogc291cmNlWzZdO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgYXJnUG9zYCBpZiBhdmFpbGFibGUuXG4gICAgICB2YWx1ZSA9IHNvdXJjZVs3XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkYXRhWzddID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcnlgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgIGlmIChzcmNCaXRtYXNrICYgV1JBUF9BUllfRkxBRykge1xuICAgICAgICBkYXRhWzhdID0gZGF0YVs4XSA9PSBudWxsID8gc291cmNlWzhdIDogbmF0aXZlTWluKGRhdGFbOF0sIHNvdXJjZVs4XSk7XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcml0eWAgaWYgb25lIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgIGlmIChkYXRhWzldID09IG51bGwpIHtcbiAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGZ1bmNgIGFuZCBtZXJnZSBiaXRtYXNrcy5cbiAgICAgIGRhdGFbMF0gPSBzb3VyY2VbMF07XG4gICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gICAgICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIGdldCB0aGUgcGFyZW50IHZhbHVlIG9mLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyZW50KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW9yZGVyIGBhcnJheWAgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXhlcyB3aGVyZSB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBmaXJzdCBpbmRleCBpcyBhc3NpZ25lZCBhcyB0aGUgZmlyc3QgZWxlbWVudCwgdGhlIGVsZW1lbnQgYXRcbiAgICAgKiB0aGUgc2Vjb25kIGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBzZWNvbmQgZWxlbWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcmVvcmRlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcnJheSBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGluZGV4ZXMubGVuZ3RoLCBhcnJMZW5ndGgpLFxuICAgICAgICAgIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGlzSW5kZXgoaW5kZXgsIGFyckxlbmd0aCkgPyBvbGRBcnJheVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYWZlR2V0KG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBtZXRhZGF0YSBmb3IgYGZ1bmNgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIHRoaXMgZnVuY3Rpb24gYmVjb21lcyBob3QsIGkuZS4gaXMgaW52b2tlZCBhIGxvdCBpbiBhIHNob3J0XG4gICAgICogcGVyaW9kIG9mIHRpbWUsIGl0IHdpbGwgdHJpcCBpdHMgYnJlYWtlciBhbmQgdHJhbnNpdGlvbiB0byBhbiBpZGVudGl0eVxuICAgICAqIGZ1bmN0aW9uIHRvIGF2b2lkIGdhcmJhZ2UgY29sbGVjdGlvbiBwYXVzZXMgaW4gVjguIFNlZVxuICAgICAqIFtWOCBpc3N1ZSAyMDcwXShodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0yMDcwKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcblxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHRoZSBnbG9iYWwgW2BzZXRUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vc2V0VGltZW91dCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBzZXRUaW1lb3V0ID0gY3R4U2V0VGltZW91dCB8fCBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgd3JhcHBlcmAgdG8gbWltaWMgdGhlIHNvdXJjZSBvZiBgcmVmZXJlbmNlYFxuICAgICAqIHdpdGggd3JhcHBlciBkZXRhaWxzIGluIGEgY29tbWVudCBhdCB0aGUgdG9wIG9mIHRoZSBzb3VyY2UgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlZmVyZW5jZSBUaGUgcmVmZXJlbmNlIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGB3cmFwcGVyYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICB2YXIgc291cmNlID0gKHJlZmVyZW5jZSArICcnKTtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyh3cmFwcGVyLCBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIHVwZGF0ZVdyYXBEZXRhaWxzKGdldFdyYXBEZXRhaWxzKHNvdXJjZSksIGJpdG1hc2spKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gICAgICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gICAgICogbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICB2YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgICB9XG4gICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICAgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB3cmFwcGVyIGBkZXRhaWxzYCBiYXNlZCBvbiBgYml0bWFza2AgZmxhZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gZGV0YWlscyBUaGUgZGV0YWlscyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGRldGFpbHNgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgIGFycmF5RWFjaCh3cmFwRmxhZ3MsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJ18uJyArIHBhaXJbMF07XG4gICAgICAgIGlmICgoYml0bWFzayAmIHBhaXJbMV0pICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgIGRldGFpbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRldGFpbHMuc29ydCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgd3JhcHBlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3cmFwcGVyIFRoZSB3cmFwcGVyIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB3cmFwcGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDbG9uZSh3cmFwcGVyKSB7XG4gICAgICBpZiAod3JhcHBlciBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHdyYXBwZXIuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9faW5kZXhfXyAgPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgIHJlc3VsdC5fX3ZhbHVlc19fID0gd3JhcHBlci5fX3ZhbHVlc19fO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gZ3JvdXBzIHRoZSBsZW5ndGggb2YgYHNpemVgLlxuICAgICAqIElmIGBhcnJheWAgY2FuJ3QgYmUgc3BsaXQgZXZlbmx5LCB0aGUgZmluYWwgY2h1bmsgd2lsbCBiZSB0aGUgcmVtYWluaW5nXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9MV0gVGhlIGxlbmd0aCBvZiBlYWNoIGNodW5rXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjaHVua3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2h1bmsoWydhJywgJ2InLCAnYycsICdkJ10sIDIpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbJ2MnLCAnZCddXVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMyk7XG4gICAgICogLy8gPT4gW1snYScsICdiJywgJ2MnXSwgWydkJ11dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUsIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoYXJyYXksIHNpemUsIGd1YXJkKSA6IHNpemUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc2l6ZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbmF0aXZlTWF4KHRvSW50ZWdlcihzaXplKSwgMCk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzaXplIDwgMSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShuYXRpdmVDZWlsKGxlbmd0aCAvIHNpemUpKTtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGJhc2VTbGljZShhcnJheSwgaW5kZXgsIChpbmRleCArPSBzaXplKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAgICAgKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFycmF5IGNvbmNhdGVuYXRpbmcgYGFycmF5YCB3aXRoIGFueSBhZGRpdGlvbmFsIGFycmF5c1xuICAgICAqIGFuZC9vciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGNvbmNhdGVuYXRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzFdO1xuICAgICAqIHZhciBvdGhlciA9IF8uY29uY2F0KGFycmF5LCAyLCBbM10sIFtbNF1dKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGggLSAxKSxcbiAgICAgICAgICBhcnJheSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVB1c2goaXNBcnJheShhcnJheSkgPyBjb3B5QXJyYXkoYXJyYXkpIDogW2FycmF5XSwgYmFzZUZsYXR0ZW4oYXJncywgMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8ud2l0aG91dCwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKi9cbiAgICB2YXIgZGlmZmVyZW5jZSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxBbGxCeWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMl1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZGlmZmVyZW5jZUJ5KFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgW3sgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kaWZmZXJlbmNlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgb3JkZXIgYW5kXG4gICAgICogcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGNvbXBhcmF0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbFdpdGhgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5kaWZmZXJlbmNlV2l0aChvYmplY3RzLCBbeyAneCc6IDEsICd5JzogMiB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdCh2YWx1ZXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgIG4gPSBsZW5ndGggLSBuO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZXhjbHVkaW5nIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqIEVsZW1lbnRzIGFyZSBkcm9wcGVkIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyb3BSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wV2hpbGUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxscyBlbGVtZW50cyBvZiBgYXJyYXlgIHdpdGggYHZhbHVlYCBmcm9tIGBzdGFydGAgdXAgdG8sIGJ1dCBub3RcbiAgICAgKiBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXy5maWxsKGFycmF5LCAnYScpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYScsICdhJ11cbiAgICAgKlxuICAgICAqIF8uZmlsbChBcnJheSgzKSwgMik7XG4gICAgICogLy8gPT4gWzIsIDIsIDJdXG4gICAgICpcbiAgICAgKiBfLmZpbGwoWzQsIDYsIDgsIDEwXSwgJyonLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbNCwgJyonLCAnKicsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgJiYgdHlwZW9mIHN0YXJ0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGaWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEluZGV4YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzXG4gICAgICogb2YgYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1hcnJheS5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdwZWJibGVzJzsgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0SW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGZyb21JbmRleCA8IDBcbiAgICAgICAgICA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMClcbiAgICAgICAgICA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVucyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbkRlZXAoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgZmxhdHRlbiBgYXJyYXlgIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCBbMiwgWzMsIFs0XV0sIDVdXTtcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW5EZXB0aChhcnJheSwgMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIFs0XSwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVwdGgoYXJyYXksIGRlcHRoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLnRvUGFpcnNgOyB0aGlzIG1ldGhvZCByZXR1cm5zIGFuIG9iamVjdCBjb21wb3NlZFxuICAgICAqIGZyb20ga2V5LXZhbHVlIGBwYWlyc2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZnJvbVBhaXJzKFtbJ2EnLCAxXSwgWydiJywgMl1dKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0W3BhaXJbMF1dID0gcGFpclsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGZpcnN0XG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaGVhZChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uaGVhZChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGVhZChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gICAgICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8uaW5kZXhPZihbMSwgMiwgMSwgMl0sIDIsIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluaXRpYWwoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0aWFsKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBhcmUgaW5jbHVkZWQgaW4gYWxsIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gICAgICogLy8gPT4gWzJdXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvblxuICAgICAqIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFsyLjEsIDEuMl0sIFsyLjMsIDMuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsyLjFdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmludGVyc2VjdGlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpLFxuICAgICAgICAgIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG5cbiAgICAgIGlmIChpdGVyYXRlZSA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludGVyc2VjdGlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlc1xuICAgICAqIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09ICdmdW5jdGlvbicgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgICAgICA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbGwgZWxlbWVudHMgaW4gYGFycmF5YCBpbnRvIGEgc3RyaW5nIHNlcGFyYXRlZCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2VwYXJhdG9yPScsJ10gVGhlIGVsZW1lbnQgc2VwYXJhdG9yLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGpvaW5lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uam9pbihbJ2EnLCAnYicsICdjJ10sICd+Jyk7XG4gICAgICogLy8gPT4gJ2F+Yn5jJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpvaW4oYXJyYXksIHNlcGFyYXRvcikge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyAnJyA6IG5hdGl2ZUpvaW4uY2FsbChhcnJheSwgc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubGFzdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbmRleE9mYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGFycmF5YCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMSwgMl0sIDIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIC8vIFNlYXJjaCBmcm9tIHRoZSBgZnJvbUluZGV4YC5cbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA8IDAgPyBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICAgICAgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KVxuICAgICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGVsZW1lbnQgYXQgaW5kZXggYG5gIG9mIGBhcnJheWAuIElmIGBuYCBpcyBuZWdhdGl2ZSwgdGhlIG50aFxuICAgICAqIGVsZW1lbnQgZnJvbSB0aGUgZW5kIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MF0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgMSk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiBfLm50aChhcnJheSwgLTIpO1xuICAgICAqIC8vID0+ICdjJztcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBudGgoYXJyYXksIG4pIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VOdGgoYXJyYXksIHRvSW50ZWdlcihuKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZ2l2ZW4gdmFsdWVzIGZyb20gYGFycmF5YCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy53aXRob3V0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucmVtb3ZlYFxuICAgICAqIHRvIHJlbW92ZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGJ5IHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsKGFycmF5LCAnYScsICdjJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYicsICdiJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdhJywgJ2InLCAnYyddO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsKGFycmF5LCBbJ2EnLCAnYyddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGwoYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIGFuZCBgdmFsdWVzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VCeWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAzIH0sIHsgJ3gnOiAxIH1dO1xuICAgICAqXG4gICAgICogXy5wdWxsQWxsQnkoYXJyYXksIFt7ICd4JzogMSB9LCB7ICd4JzogMyB9XSwgJ3gnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wdWxsQWxsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgIHRvIGB2YWx1ZXNgLiBUaGUgY29tcGFyYXRvciBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5kaWZmZXJlbmNlV2l0aGAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMywgJ3knOiA0IH0sIHsgJ3gnOiA1LCAneSc6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxXaXRoKGFycmF5LCBbeyAneCc6IDMsICd5JzogNCB9XSwgXy5pc0VxdWFsKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDUsICd5JzogNiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHB1bGxBbGxXaXRoKGFycmF5LCB2YWx1ZXMsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gYGFycmF5YCBjb3JyZXNwb25kaW5nIHRvIGBpbmRleGVzYCBhbmQgcmV0dXJucyBhblxuICAgICAqIGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmF0YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBbaW5kZXhlc10gVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnYScsICdiJywgJ2MnLCAnZCddO1xuICAgICAqIHZhciBwdWxsZWQgPSBfLnB1bGxBdChhcnJheSwgWzEsIDNdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYyddXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhwdWxsZWQpO1xuICAgICAqIC8vID0+IFsnYicsICdkJ11cbiAgICAgKi9cbiAgICB2YXIgcHVsbEF0ID0gZmxhdFJlc3QoZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBiYXNlQXQoYXJyYXksIGluZGV4ZXMpO1xuXG4gICAgICBiYXNlUHVsbEF0KGFycmF5LCBhcnJheU1hcChpbmRleGVzLCBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gaXNJbmRleChpbmRleCwgbGVuZ3RoKSA/ICtpbmRleCA6IGluZGV4O1xuICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIGBhcnJheWAgdGhhdCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3JcbiAgICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAgICAgKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gICAgICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpO1xuICAgICAqIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnNlcyBgYXJyYXlgIHNvIHRoYXQgdGhlIGZpcnN0IGVsZW1lbnQgYmVjb21lcyB0aGUgbGFzdCwgdGhlIHNlY29uZFxuICAgICAqIGVsZW1lbnQgYmVjb21lcyB0aGUgc2Vjb25kIHRvIGxhc3QsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAgYW5kIGlzIGJhc2VkIG9uXG4gICAgICogW2BBcnJheSNyZXZlcnNlYF0oaHR0cHM6Ly9tZG4uaW8vQXJyYXkvcmV2ZXJzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLnJldmVyc2UoYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgIHJldHVybiBhcnJheSA9PSBudWxsID8gYXJyYXkgOiBuYXRpdmVSZXZlcnNlLmNhbGwoYXJyYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIHVzZWQgaW5zdGVhZCBvZlxuICAgICAqIFtgQXJyYXkjc2xpY2VgXShodHRwczovL21kbi5pby9BcnJheS9zbGljZSkgdG8gZW5zdXJlIGRlbnNlIGFycmF5cyBhcmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBsb3dlc3QgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4KFszMCwgNTBdLCA0MCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ueDsgfSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb3J0ZWRJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IHBlcmZvcm1zIGEgYmluYXJ5XG4gICAgICogc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGVxKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaGlnaGVzdFxuICAgICAqIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0b1xuICAgICAqIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXgoWzQsIDUsIDUsIDUsIDZdLCA1KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4KGFycmF5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydGVkTGFzdEluZGV4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlIHRoZWlyXG4gICAgICogc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogNCB9LCB7ICd4JzogNSB9XTtcbiAgICAgKlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleEJ5KG9iamVjdHMsIHsgJ3gnOiA0IH0sICd4Jyk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5sYXN0SW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhPZihbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSkgLSAxO1xuICAgICAgICBpZiAoZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcShbMSwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcUJ5YCBleGNlcHQgdGhhdCBpdCdzIGRlc2lnbmVkIGFuZCBvcHRpbWl6ZWRcbiAgICAgKiBmb3Igc29ydGVkIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkVW5pcUJ5KFsxLjEsIDEuMiwgMi4zLCAyLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4xLCAyLjNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBidXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFpbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDEsIGxlbmd0aCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHRha2UuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggZWxlbWVudHMgdGFrZW4gZnJvbSB0aGUgZW5kLiBFbGVtZW50cyBhcmVcbiAgICAgKiB0YWtlbiB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsncGViYmxlcyddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodFdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBiZWdpbm5pbmcuIEVsZW1lbnRzXG4gICAgICogYXJlIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9yZGVyLCBmcm9tIGFsbCBnaXZlbiBhcnJheXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb24oWzJdLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pb25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBvZiBlYWNoIGBhcnJheXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnlcbiAgICAgKiB3aGljaCB1bmlxdWVuZXNzIGlzIGNvbXB1dGVkLiBSZXN1bHQgdmFsdWVzIGFyZSBjaG9zZW4gZnJvbSB0aGUgZmlyc3RcbiAgICAgKiBhcnJheSBpbiB3aGljaCB0aGUgdmFsdWUgb2NjdXJzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDpcbiAgICAgKiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pb25CeShbMi4xXSwgWzEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlvbkJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB1bmlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoaXRlcmF0ZWUpKSB7XG4gICAgICAgIGl0ZXJhdGVlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY29tcGFyYXRvcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgZWxlbWVudHMgb2YgYGFycmF5c2AuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tXG4gICAgICogdGhlIGZpcnN0IGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaW9uV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBpcyBrZXB0LiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyXG4gICAgICogaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcShbMiwgMSwgMl0pO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gICAgICogb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcUJ5KFsyLjEsIDEuMiwgMi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMSwgMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy51bmlxQnkoW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5LlRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnVuaXFXaXRoKG9iamVjdHMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGFuIGFycmF5IG9mIGdyb3VwZWRcbiAgICAgKiBlbGVtZW50cyBhbmQgY3JlYXRlcyBhbiBhcnJheSByZWdyb3VwaW5nIHRoZSBlbGVtZW50cyB0byB0aGVpciBwcmUtemlwXG4gICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjIuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgemlwcGVkID0gXy56aXAoWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMSwgdHJ1ZV0sIFsnYicsIDIsIGZhbHNlXV1cbiAgICAgKlxuICAgICAqIF8udW56aXAoemlwcGVkKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InXSwgWzEsIDJdLCBbdHJ1ZSwgZmFsc2VdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwKGFycmF5KSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSAwO1xuICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGdyb3VwKSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChncm91cC5sZW5ndGgsIGxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChhcnJheSwgYmFzZVByb3BlcnR5KGluZGV4KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuemlwYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgdG8gc3BlY2lmeVxuICAgICAqIGhvdyByZWdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIHRvIGNvbWJpbmVcbiAgICAgKiAgcmVncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdKTtcbiAgICAgKiAvLyA9PiBbWzEsIDEwLCAxMDBdLCBbMiwgMjAsIDIwMF1dXG4gICAgICpcbiAgICAgKiBfLnVuemlwV2l0aCh6aXBwZWQsIF8uYWRkKTtcbiAgICAgKiAvLyA9PiBbMywgMzAsIDMwMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnppcFdpdGgoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB1bnppcChhcnJheSk7XG4gICAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5TWFwKHJlc3VsdCwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGl0ZXJhdGVlLCB1bmRlZmluZWQsIGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgZXhjbHVkaW5nIGFsbCBnaXZlbiB2YWx1ZXMgdXNpbmdcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQHNlZSBfLmRpZmZlcmVuY2UsIF8ueG9yXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud2l0aG91dChbMiwgMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IFszXVxuICAgICAqL1xuICAgIHZhciB3aXRob3V0ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMgdGhhdCBpcyB0aGVcbiAgICAgKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICAgICAqIG9mIHRoZSBnaXZlbiBhcnJheXMuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyXG4gICAgICogdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy53aXRob3V0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMSwgM11cbiAgICAgKi9cbiAgICB2YXIgeG9yID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnhvcmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIGJ5IHdoaWNoIHRoZXkncmUgY29tcGFyZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWRcbiAgICAgKiBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXlzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZVxuICAgICAqIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ueG9yQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzEuMiwgMy40XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy54b3JCeShbeyAneCc6IDEgfV0sIFt7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXNcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBjb21wYXJhdG9yIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICogdmFyIG90aGVycyA9IFt7ICd4JzogMSwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLnhvcldpdGgob2JqZWN0cywgb3RoZXJzLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgeG9yV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZVhvcihhcnJheUZpbHRlcihhcnJheXMsIGlzQXJyYXlMaWtlT2JqZWN0KSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cywgdGhlIGZpcnN0IG9mIHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgICAqIGZpcnN0IGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIHRoZSBzZWNvbmQgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogc2Vjb25kIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheXMsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqL1xuICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICAgICAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBPYmplY3RgIGV4Y2VwdCB0aGF0IGl0IHN1cHBvcnRzIHByb3BlcnR5IHBhdGhzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcE9iamVjdERlZXAoWydhLmJbMF0uYycsICdhLmJbMV0uZCddLCBbMSwgMl0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogW3sgJ2MnOiAxIH0sIHsgJ2QnOiAyIH1dIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHppcE9iamVjdERlZXAocHJvcHMsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGJhc2VaaXBPYmplY3QocHJvcHMgfHwgW10sIHZhbHVlcyB8fCBbXSwgYmFzZVNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IGdyb3VwZWQgdmFsdWVzIHNob3VsZCBiZSBjb21iaW5lZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aGVcbiAgICAgKiBlbGVtZW50cyBvZiBlYWNoIGdyb3VwOiAoLi4uZ3JvdXApLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICBncm91cGVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnppcFdpdGgoWzEsIDJdLCBbMTAsIDIwXSwgWzEwMCwgMjAwXSwgZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIGEgKyBiICsgYztcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBbMTExLCAyMjJdXG4gICAgICovXG4gICAgdmFyIHppcFdpdGggPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIGl0ZXJhdGVlID0gbGVuZ3RoID4gMSA/IGFycmF5c1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaXRlcmF0ZWUgPSB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB0aGF0IHdyYXBzIGB2YWx1ZWAgd2l0aCBleHBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC4gVGhlIHJlc3VsdCBvZiBzdWNoIHNlcXVlbmNlcyBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIHZhciB5b3VuZ2VzdCA9IF9cbiAgICAgKiAgIC5jaGFpbih1c2VycylcbiAgICAgKiAgIC5zb3J0QnkoJ2FnZScpXG4gICAgICogICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgICAgcmV0dXJuIG8udXNlciArICcgaXMgJyArIG8uYWdlO1xuICAgICAqICAgfSlcbiAgICAgKiAgIC5oZWFkKClcbiAgICAgKiAgIC52YWx1ZSgpO1xuICAgICAqIC8vID0+ICdwZWJibGVzIGlzIDEnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2godmFsdWUpO1xuICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGludm9rZXMgYGludGVyY2VwdG9yYCBhbmQgcmV0dXJucyBgdmFsdWVgLiBUaGUgaW50ZXJjZXB0b3JcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0b1xuICAgICAqIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZSBpbiBvcmRlciB0byBtb2RpZnkgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvdmlkZSB0byBgaW50ZXJjZXB0b3JgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGludGVyY2VwdG9yIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXyhbMSwgMiwgM10pXG4gICAgICogIC50YXAoZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgKiAgICAvLyBNdXRhdGUgaW5wdXQgYXJyYXkuXG4gICAgICogICAgYXJyYXkucG9wKCk7XG4gICAgICogIH0pXG4gICAgICogIC5yZXZlcnNlKClcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFwKHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udGFwYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInBhc3MgdGhydVwiIHZhbHVlcyByZXBsYWNpbmcgaW50ZXJtZWRpYXRlXG4gICAgICogcmVzdWx0cyBpbiBhIG1ldGhvZCBjaGFpbiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oJyAgYWJjICAnKVxuICAgICAqICAuY2hhaW4oKVxuICAgICAqICAudHJpbSgpXG4gICAgICogIC50aHJ1KGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgICogIH0pXG4gICAgICogIC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJ1KHZhbHVlLCBpbnRlcmNlcHRvcikge1xuICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB0aGUgd3JhcHBlciB2ZXJzaW9uIG9mIGBfLmF0YC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGF0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8ob2JqZWN0KS5hdChbJ2FbMF0uYi5jJywgJ2FbMV0nXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgc3RhcnQgPSBsZW5ndGggPyBwYXRoc1swXSA6IDAsXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIGludGVyY2VwdG9yID0gZnVuY3Rpb24ob2JqZWN0KSB7IHJldHVybiBiYXNlQXQob2JqZWN0LCBwYXRocyk7IH07XG5cbiAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8XG4gICAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB8fCAhaXNJbmRleChzdGFydCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKHN0YXJ0LCArc3RhcnQgKyAobGVuZ3RoID8gMSA6IDApKTtcbiAgICAgIHZhbHVlLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICdhcmdzJzogW2ludGVyY2VwdG9yXSxcbiAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlLCB0aGlzLl9fY2hhaW5fXykudGhydShmdW5jdGlvbihhcnJheSkge1xuICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICBhcnJheS5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZSB3aXRoIGV4cGxpY2l0IG1ldGhvZCBjaGFpbiBzZXF1ZW5jZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNoYWluXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIEEgc2VxdWVuY2Ugd2l0aG91dCBleHBsaWNpdCBjaGFpbmluZy5cbiAgICAgKiBfKHVzZXJzKS5oZWFkKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRoIGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpXG4gICAgICogICAuY2hhaW4oKVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnBpY2soJ3VzZXInKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIGNvbW1pdFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMl07XG4gICAgICogdmFyIHdyYXBwZWQgPSBfKGFycmF5KS5wdXNoKDMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogd3JhcHBlZCA9IHdyYXBwZWQuY29tbWl0KCk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogd3JhcHBlZC5sYXN0KCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDb21taXQoKSB7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbmV4dCB2YWx1ZSBvbiBhIHdyYXBwZWQgb2JqZWN0IGZvbGxvd2luZyB0aGVcbiAgICAgKiBbaXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vbWRuLmlvL2l0ZXJhdGlvbl9wcm90b2NvbHMjaXRlcmF0b3IpLlxuICAgICAqXG4gICAgICogQG5hbWUgbmV4dFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5leHQgaXRlcmF0b3IgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAxIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiBmYWxzZSwgJ3ZhbHVlJzogMiB9XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogdHJ1ZSwgJ3ZhbHVlJzogdW5kZWZpbmVkIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyTmV4dCgpIHtcbiAgICAgIGlmICh0aGlzLl9fdmFsdWVzX18gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9fdmFsdWVzX18gPSB0b0FycmF5KHRoaXMudmFsdWUoKSk7XG4gICAgICB9XG4gICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsXG4gICAgICAgICAgdmFsdWUgPSBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5fX3ZhbHVlc19fW3RoaXMuX19pbmRleF9fKytdO1xuXG4gICAgICByZXR1cm4geyAnZG9uZSc6IGRvbmUsICd2YWx1ZSc6IHZhbHVlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgd3JhcHBlciB0byBiZSBpdGVyYWJsZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIFN5bWJvbC5pdGVyYXRvclxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oWzEsIDJdKTtcbiAgICAgKlxuICAgICAqIHdyYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpID09PSB3cmFwcGVkO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIEFycmF5LmZyb20od3JhcHBlZCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclRvSXRlcmF0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGNoYWluIHNlcXVlbmNlIHBsYW50aW5nIGB2YWx1ZWAgYXMgdGhlIHdyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBwbGFudFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHBsYW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pLm1hcChzcXVhcmUpO1xuICAgICAqIHZhciBvdGhlciA9IHdyYXBwZWQucGxhbnQoWzMsIDRdKTtcbiAgICAgKlxuICAgICAqIG90aGVyLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzksIDE2XVxuICAgICAqXG4gICAgICogd3JhcHBlZC52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCA0XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJQbGFudCh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgYmFzZUxvZGFzaCkge1xuICAgICAgICB2YXIgY2xvbmUgPSB3cmFwcGVyQ2xvbmUocGFyZW50KTtcbiAgICAgICAgY2xvbmUuX19pbmRleF9fID0gMDtcbiAgICAgICAgY2xvbmUuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gY2xvbmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2xvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2xvbmU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fX3dyYXBwZWRfXztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8ucmV2ZXJzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgd3JhcHBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHJldmVyc2VcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqXG4gICAgICogXyhhcnJheSkucmV2ZXJzZSgpLnZhbHVlKClcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX187XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikge1xuICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgpIHtcbiAgICAgICAgICB3cmFwcGVkID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHdyYXBwZWQgPSB3cmFwcGVkLnJldmVyc2UoKTtcbiAgICAgICAgd3JhcHBlZC5fX2FjdGlvbnNfXy5wdXNoKHtcbiAgICAgICAgICAnZnVuYyc6IHRocnUsXG4gICAgICAgICAgJ2FyZ3MnOiBbcmV2ZXJzZV0sXG4gICAgICAgICAgJ3RoaXNBcmcnOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVkLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50aHJ1KHJldmVyc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIHRoZSBjaGFpbiBzZXF1ZW5jZSB0byByZXNvbHZlIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIHRvSlNPTiwgdmFsdWVPZlxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZSh0aGlzLl9fd3JhcHBlZF9fLCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY291bnRCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5jb3VudEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAgICovXG4gICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICsrcmVzdWx0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gICAgICogW2V2ZXJ5dGhpbmcgaXMgdHJ1ZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVmFjdW91c190cnV0aCkgb2ZcbiAgICAgKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLnJlamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICovXG4gICAgdmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD1jb2xsZWN0aW9uLmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5maW5kTGFzdChbMSwgMiwgMywgNF0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAxO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gICAgICogdGhydSBgaXRlcmF0ZWVgIGFuZCBmbGF0dGVuaW5nIHRoZSBtYXBwZWQgcmVzdWx0cy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtuLCBuXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVlcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBJTkZJTklUWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cyB1cCB0byBgZGVwdGhgIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZXB0aD0xXSBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkdXBsaWNhdGUobikge1xuICAgICAqICAgcmV0dXJuIFtbW24sIG5dXV07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwRGVwdGgoWzEsIDJdLCBkdXBsaWNhdGUsIDIpO1xuICAgICAqIC8vID0+IFtbMSwgMV0sIFsyLCAyXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVwdGgoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQgPyAxIDogdG9JbnRlZ2VyKGRlcHRoKTtcbiAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICAgICAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZWFjaFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yRWFjaGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAYWxpYXMgZWFjaFJpZ2h0XG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mb3JFYWNoUmlnaHQoWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDJgIHRoZW4gYDFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIG9yZGVyIG9mIGdyb3VwZWQgdmFsdWVzXG4gICAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gICAgICoga2V5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IFs0LjJdLCAnNic6IFs2LjEsIDYuM10gfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ncm91cEJ5KFsnb25lJywgJ3R3bycsICd0aHJlZSddLCAnbGVuZ3RoJyk7XG4gICAgICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gICAgICovXG4gICAgdmFyIGdyb3VwQnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gICAgICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICAgICAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKHsgJ2EnOiAxLCAnYic6IDIgfSwgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcygnYWJjZCcsICdiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgICAgIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICAgICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICAgICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICAgICAgOiAoISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLCByZXR1cm5pbmdcbiAgICAgKiBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZiBlYWNoIGludm9rZWQgbWV0aG9kLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiBhcmUgcHJvdmlkZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYHBhdGhgIGlzIGEgZnVuY3Rpb24sIGl0J3MgaW52b2tlZFxuICAgICAqIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb258c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAgICogIHRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgZWFjaCBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAgICogLy8gPT4gW1sxLCA1LCA3XSwgWzEsIDIsIDNdXVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgICAqIC8vID0+IFtbJzEnLCAnMicsICczJ10sIFsnNCcsICc1JywgJzYnXV1cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaXNGdW5jID0gdHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpc0Z1bmMgPyBhcHBseShwYXRoLCB2YWx1ZSwgYXJncykgOiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBsYXN0IGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGtleS4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1xuICAgICAqICAgeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sXG4gICAgICogICB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksIGZ1bmN0aW9uKG8pIHtcbiAgICAgKiAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG8uY29kZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAnZCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgJ2RpcicpO1xuICAgICAqIC8vID0+IHsgJ2xlZnQnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ3JpZ2h0JzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICovXG4gICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gICAgICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gICAgICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICAgICAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF1cbiAgICAgKlxuICAgICAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc29ydEJ5YCBleGNlcHQgdGhhdCBpdCBhbGxvd3Mgc3BlY2lmeWluZyB0aGUgc29ydFxuICAgICAqIG9yZGVycyBvZiB0aGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzXG4gICAgICogYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3JcbiAgICAgKiBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheVtdfEZ1bmN0aW9uW118T2JqZWN0W118c3RyaW5nW119IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gW29yZGVyc10gVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFNvcnQgYnkgYHVzZXJgIGluIGFzY2VuZGluZyBvcmRlciBhbmQgYnkgYGFnZWAgaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKiBfLm9yZGVyQnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSwgWydhc2MnLCAnZGVzYyddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXJyYXkoaXRlcmF0ZWVzKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBpdGVyYXRlZXMgPT0gbnVsbCA/IFtdIDogW2l0ZXJhdGVlc107XG4gICAgICB9XG4gICAgICBvcmRlcnMgPSBndWFyZCA/IHVuZGVmaW5lZCA6IG9yZGVycztcbiAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgIG9yZGVycyA9IG9yZGVycyA9PSBudWxsID8gW10gOiBbb3JkZXJzXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciwgdGhlIHNlY29uZCBvZiB3aGljaFxuICAgICAqIGNvbnRhaW5zIGVsZW1lbnRzIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5IGZvci4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ3BlYmJsZXMnXSwgWydiYXJuZXknLCAnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgJ3BlYmJsZXMnXSwgWydmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICAgICAqL1xuICAgIHZhciBwYXJ0aXRpb24gPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbigpIHsgcmV0dXJuIFtbXSwgW11dOyB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAsIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAgICAgKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gICAgICogdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6XG4gICAgICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAgICAgKiBhbmQgYHNvcnRCeWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKFsxLCAyXSwgZnVuY3Rpb24oc3VtLCBuKSB7XG4gICAgICogICByZXR1cm4gc3VtICsgbjtcbiAgICAgKiB9LCAwKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yZWR1Y2VgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtbMCwgMV0sIFsyLCAzXSwgWzQsIDVdXTtcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlUmlnaHQoYXJyYXksIGZ1bmN0aW9uKGZsYXR0ZW5lZCwgb3RoZXIpIHtcbiAgICAgKiAgIHJldHVybiBmbGF0dGVuZWQuY29uY2F0KG90aGVyKTtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDUsIDIsIDMsIDAsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSxcbiAgICAgICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaFJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZmlsdGVyYDsgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gXG4gICAgICogdGhhdCBgcHJlZGljYXRlYCBkb2VzICoqbm90KiogcmV0dXJuIHRydXRoeSBmb3IuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICogQHNlZSBfLmZpbHRlclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnJlamVjdCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgeyAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnJlamVjdCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWplY3QoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByYW5kb20gZWxlbWVudCBmcm9tIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlIDogYmFzZVNhbXBsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYG5gIHJhbmRvbSBlbGVtZW50cyBhdCB1bmlxdWUga2V5cyBmcm9tIGBjb2xsZWN0aW9uYCB1cCB0byB0aGVcbiAgICAgKiBzaXplIG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCAyKTtcbiAgICAgKiAvLyA9PiBbMywgMV1cbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDQpO1xuICAgICAqIC8vID0+IFsyLCAzLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2FtcGxlU2l6ZSA6IGJhc2VTYW1wbGVTaXplO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAgICAgKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gICAgICogdmFsdWVzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgZm9yIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zaXplKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5zaXplKCdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gN1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBzdHJpbmdTaXplKGNvbGxlY3Rpb24pIDogY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VLZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkpIHtcbiAgICAgICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICAgICAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gICAgICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICAgICAqL1xuICAgIHZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW107XG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xuICAgIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAgICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICAgICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICAgKiB9LCBfLm5vdygpKTtcbiAgICAgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHZhciBub3cgPSBjdHhOb3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcm9vdC5EYXRlLm5vdygpO1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uYmVmb3JlYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIGBmdW5jYCBvbmNlIGl0J3MgY2FsbGVkIGBuYCBvciBtb3JlIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBiZWZvcmUgYGZ1bmNgIGlzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNhdmVzID0gWydwcm9maWxlJywgJ3NldHRpbmdzJ107XG4gICAgICpcbiAgICAgKiB2YXIgZG9uZSA9IF8uYWZ0ZXIoc2F2ZXMubGVuZ3RoLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdkb25lIHNhdmluZyEnKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChzYXZlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAqICAgYXN5bmNTYXZlKHsgJ3R5cGUnOiB0eXBlLCAnY29tcGxldGUnOiBkb25lIH0pO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2RvbmUgc2F2aW5nIScgYWZ0ZXIgdGhlIHR3byBhc3luYyBzYXZlcyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZnRlcihuLCBmdW5jKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uIDwgMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdXAgdG8gYG5gIGFyZ3VtZW50cyxcbiAgICAgKiBpZ25vcmluZyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBjYXAuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8uYXJ5KHBhcnNlSW50LCAxKSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyeShmdW5jLCBuLCBndWFyZCkge1xuICAgICAgbiA9IGd1YXJkID8gdW5kZWZpbmVkIDogbjtcbiAgICAgIG4gPSAoZnVuYyAmJiBuID09IG51bGwpID8gZnVuYy5sZW5ndGggOiBuO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50c1xuICAgICAqIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGlsZSBpdCdzIGNhbGxlZCBsZXNzIHRoYW4gYG5gIHRpbWVzLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGF0IHdoaWNoIGBmdW5jYCBpcyBubyBsb25nZXIgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5iZWZvcmUoNSwgYWRkQ29udGFjdFRvTGlzdCkpO1xuICAgICAqIC8vID0+IEFsbG93cyBhZGRpbmcgdXAgdG8gNCBjb250YWN0cyB0byB0aGUgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiZWZvcmUobiwgZnVuYykge1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDw9IDEpIHtcbiAgICAgICAgICBmdW5jID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYFxuICAgICAqIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBuYXRpdmUgYEZ1bmN0aW9uI2JpbmRgLCB0aGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZChncmVldCwgb2JqZWN0LCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBvYmplY3Rba2V5XWAgd2l0aCBgcGFydGlhbHNgXG4gICAgICogcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvIHJlZmVyZW5jZVxuICAgICAqIG1ldGhvZHMgdGhhdCBtYXkgYmUgcmVkZWZpbmVkIG9yIGRvbid0IHlldCBleGlzdC4gU2VlXG4gICAgICogW1BldGVyIE1pY2hhdXgncyBhcnRpY2xlXShodHRwOi8vcGV0ZXIubWljaGF1eC5jYS9hcnRpY2xlcy9sYXp5LWZ1bmN0aW9uLWRlZmluaXRpb24tcGF0dGVybilcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlIGBfLmJpbmRLZXkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZva2UgdGhlIG1ldGhvZCBvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICd1c2VyJzogJ2ZyZWQnLFxuICAgICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCAnaGknKTtcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkISdcbiAgICAgKlxuICAgICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJ3lhICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIEJvdW5kIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhcmd1bWVudHMgb2YgYGZ1bmNgIGFuZCBlaXRoZXIgaW52b2tlc1xuICAgICAqIGBmdW5jYCByZXR1cm5pbmcgaXRzIHJlc3VsdCwgaWYgYXQgbGVhc3QgYGFyaXR5YCBudW1iZXIgb2YgYXJndW1lbnRzIGhhdmVcbiAgICAgKiBiZWVuIHByb3ZpZGVkLCBvciByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRoZSByZW1haW5pbmcgYGZ1bmNgXG4gICAgICogYXJndW1lbnRzLCBhbmQgc28gb24uIFRoZSBhcml0eSBvZiBgZnVuY2AgbWF5IGJlIHNwZWNpZmllZCBpZiBgZnVuYy5sZW5ndGhgXG4gICAgICogaXMgbm90IHN1ZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnkucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpYyBidWlsZHMsXG4gICAgICogbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnkoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSkoMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgxKShfLCAzKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeShmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmN1cnJ5YCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGFwcGxpZWQgdG8gYGZ1bmNgXG4gICAgICogaW4gdGhlIG1hbm5lciBvZiBgXy5wYXJ0aWFsUmlnaHRgIGluc3RlYWQgb2YgYF8ucGFydGlhbGAuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uY3VycnlSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeVJpZ2h0KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDMpKDIpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgyLCAzKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMykoMSwgXykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnlSaWdodChmdW5jLCBhcml0eSwgZ3VhcmQpIHtcbiAgICAgIGFyaXR5ID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBhcml0eTtcbiAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQ1VSUllfUklHSFRfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGFyaXR5KTtcbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgICAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICAgICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICAgKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAgICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gICAgICogaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAgICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAgICogfSkpO1xuICAgICAqXG4gICAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICAgKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAgICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgICAgbGFzdFRoaXMsXG4gICAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgdGltZXJJZCxcbiAgICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmZXJzIGludm9raW5nIHRoZSBgZnVuY2AgdW50aWwgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXMgY2xlYXJlZC4gQW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlZmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sICdkZWZlcnJlZCcpO1xuICAgICAqIC8vID0+IExvZ3MgJ2RlZmVycmVkJyBhZnRlciBvbmUgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlZmVyID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYGZ1bmNgIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheSBpbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVyIGlkLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlbGF5KGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHRleHQpO1xuICAgICAqIH0sIDEwMDAsICdsYXRlcicpO1xuICAgICAqIC8vID0+IExvZ3MgJ2xhdGVyJyBhZnRlciBvbmUgc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgdG9OdW1iZXIod2FpdCkgfHwgMCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyByZXZlcnNlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZsaXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmbGlwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZmxpcHBlZCA9IF8uZmxpcChmdW5jdGlvbigpIHtcbiAgICAgKiAgIHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGZsaXBwZWQoJ2EnLCAnYicsICdjJywgJ2QnKTtcbiAgICAgKiAvLyA9PiBbJ2QnLCAnYycsICdiJywgJ2EnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsaXAoZnVuYykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAgICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICAgICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAgICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gICAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgICAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gICAgICpcbiAgICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIHZhbHVlcyhvdGhlcik7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICpcbiAgICAgKiBvYmplY3QuYSA9IDI7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAgICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH1cblxuICAgIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICAgIG1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gICAgICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG5lZ2F0ZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAgICAgKiAvLyA9PiBbMSwgMywgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcyk7XG4gICAgICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gaW52b2tpbmcgYGZ1bmNgIG9uY2UuIFJlcGVhdCBjYWxsc1xuICAgICAqIHRvIHRoZSBmdW5jdGlvbiByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnZvY2F0aW9uLiBUaGUgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGluaXRpYWxpemUgPSBfLm9uY2UoY3JlYXRlQXBwbGljYXRpb24pO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogLy8gPT4gYGNyZWF0ZUFwcGxpY2F0aW9uYCBpcyBpbnZva2VkIG9uY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiZWZvcmUoMiwgZnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnRzIHRyYW5zZm9ybWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3RyYW5zZm9ybXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgYXJndW1lbnQgdHJhbnNmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZG91YmxlZChuKSB7XG4gICAgICogICByZXR1cm4gbiAqIDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckFyZ3MoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgKiB9LCBbc3F1YXJlLCBkb3VibGVkXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKDksIDMpO1xuICAgICAqIC8vID0+IFs4MSwgNl1cbiAgICAgKlxuICAgICAqIGZ1bmMoMTAsIDUpO1xuICAgICAqIC8vID0+IFsxMDAsIDEwXVxuICAgICAqL1xuICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHRyYW5zZm9ybXMgPSAodHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pKVxuICAgICAgICA/IGFycmF5TWFwKHRyYW5zZm9ybXNbMF0sIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSlcbiAgICAgICAgOiBhcnJheU1hcChiYXNlRmxhdHRlbih0cmFuc2Zvcm1zLCAxKSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIGZ1bmNzTGVuZ3RoID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihhcmdzLmxlbmd0aCwgZnVuY3NMZW5ndGgpO1xuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSB0cmFuc2Zvcm1zW2luZGV4XS5jYWxsKHRoaXMsIGFyZ3NbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlXG4gICAgICogYXJndW1lbnRzIGl0IHJlY2VpdmVzLiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmJpbmRgIGV4Y2VwdCBpdCBkb2VzICoqbm90KipcbiAgICAgKiBhbHRlciB0aGUgYHRoaXNgIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbChncmVldCwgJ2hlbGxvJyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbChncmVldCwgXywgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWwpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucGFydGlhbGAgZXhjZXB0IHRoYXQgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzXG4gICAgICogYXJlIGFwcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8ucGFydGlhbFJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2ZyZWQnKTtcbiAgICAgKiBncmVldEZyZWQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgc2F5SGVsbG9UbyA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnaGVsbG8nLCBfKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICovXG4gICAgdmFyIHBhcnRpYWxSaWdodCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbFJpZ2h0KSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGFyZ3VtZW50cyBhcnJhbmdlZCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgc3BlY2lmaWVkIGBpbmRleGVzYCB3aGVyZSB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIGZpcnN0IGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCB0aGUgYXJndW1lbnQgdmFsdWUgYXQgdGhlIHNlY29uZCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQsIGFuZCBzbyBvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlYXJyYW5nZSBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFyZ3VtZW50IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciByZWFyZ2VkID0gXy5yZWFyZyhmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH0sIFsyLCAwLCAxXSk7XG4gICAgICpcbiAgICAgKiByZWFyZ2VkKCdiJywgJ2MnLCAnYScpXG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9SRUFSR19GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBpbmRleGVzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhc1xuICAgICAqIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9tZG4uaW8vcmVzdF9wYXJhbWV0ZXJzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5yZXN0KGZ1bmN0aW9uKHdoYXQsIG5hbWVzKSB7XG4gICAgICogICByZXR1cm4gd2hhdCArICcgJyArIF8uaW5pdGlhbChuYW1lcykuam9pbignLCAnKSArXG4gICAgICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiB0b0ludGVnZXIoc3RhcnQpO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGUgZnVuY3Rpb24gYW5kIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBtdWNoIGxpa2VcbiAgICAgKiBbYEZ1bmN0aW9uI2FwcGx5YF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3NwcmVhZCBvcGVyYXRvcl0oaHR0cHM6Ly9tZG4uaW8vc3ByZWFkX29wZXJhdG9yKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHNwcmVhZCBhcmd1bWVudHMgb3Zlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgc3ByZWFkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F5ID0gXy5zcHJlYWQoZnVuY3Rpb24od2hvLCB3aGF0KSB7XG4gICAgICogICByZXR1cm4gd2hvICsgJyBzYXlzICcgKyB3aGF0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KFsnZnJlZCcsICdoZWxsbyddKTtcbiAgICAgKiAvLyA9PiAnZnJlZCBzYXlzIGhlbGxvJ1xuICAgICAqXG4gICAgICogdmFyIG51bWJlcnMgPSBQcm9taXNlLmFsbChbXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoNDApLFxuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDM2KVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogbnVtYmVycy50aGVuKF8uc3ByZWFkKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiB4ICsgeTtcbiAgICAgKiB9KSk7XG4gICAgICogLy8gPT4gYSBQcm9taXNlIG9mIDc2XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3ByZWFkKGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09IG51bGwgPyAwIDogbmF0aXZlTWF4KHRvSW50ZWdlcihzdGFydCksIDApO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gYXJnc1tzdGFydF0sXG4gICAgICAgICAgICBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAgICAgKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICAgICAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAgICAgKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAgICAgKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gICAgICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICAgICAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAgICAgKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAgICAgKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAgICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIGFyZ3VtZW50LCBpZ25vcmluZyBhbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy51bmFyeShwYXJzZUludCkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICByZXR1cm4gYXJ5KGZ1bmMsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGB2YWx1ZWAgdG8gYHdyYXBwZXJgIGFzIGl0cyBmaXJzdFxuICAgICAqIGFyZ3VtZW50LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGFyZSBhcHBlbmRlZFxuICAgICAqIHRvIHRob3NlIHByb3ZpZGVkIHRvIHRoZSBgd3JhcHBlcmAuIFRoZSB3cmFwcGVyIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3dyYXBwZXI9aWRlbnRpdHldIFRoZSB3cmFwcGVyIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcCA9IF8ud3JhcChfLmVzY2FwZSwgZnVuY3Rpb24oZnVuYywgdGV4dCkge1xuICAgICAqICAgcmV0dXJuICc8cD4nICsgZnVuYyh0ZXh0KSArICc8L3A+JztcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHAoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJzxwPmZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlczwvcD4nXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcCh2YWx1ZSwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCBhcyBhbiBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYWJjJ11cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtudWxsXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkodW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIDIsIDNdO1xuICAgICAqIGNvbnNvbGUubG9nKF8uY2FzdEFycmF5KGFycmF5KSA9PT0gYXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0QXJyYXkoKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICAgICAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAgICAgKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAgICAgKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICAgICAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAgICAgKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBjbG9uZWQgdmFsdWUuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLFxuICAgICAqIGNsb25pbmcgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdXAgdG8gZm91ciBhcmd1bWVudHM7ICh2YWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZURlZXBXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZVdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gICAgICpcbiAgICAgKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVXaXRoYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGVsID0gXy5jbG9uZURlZXBXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBvYmplY3RgIGNvbmZvcm1zIHRvIGBzb3VyY2VgIGJ5IGludm9raW5nIHRoZSBwcmVkaWNhdGVcbiAgICAgKiBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGNvbmZvcm1zLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAyOyB9IH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGFcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmd0KDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlR3QpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndGUoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3RlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAgICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5QnVmZmVyYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5QnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlCdWZmZXIobmV3IEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gICAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICAgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAgICAgKiBpcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBib29sZWFuIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYm9vbGVhbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihmYWxzZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4obnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYm9vbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYERhdGVgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBkYXRlIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUoJ01vbiBBcHJpbCAyMyAyMDEyJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRWxlbWVudCgnPGJvZHk+Jyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICAgICAqXG4gICAgICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gICAgICogcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICAgICAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAgICAgKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh0cnVlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAgICAgKiBkYXRlIG9iamVjdHMsIGVycm9yIG9iamVjdHMsIG1hcHMsIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAgICAgKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAgICAgKiBub2RlcyBhcmUgY29tcGFyZWQgYnkgc3RyaWN0IGVxdWFsaXR5LCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBvYmplY3QgPT09IG90aGVyO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNFcXVhbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHVwIHRvXG4gICAgICogc2l4IGFyZ3VtZW50czogKG9ialZhbHVlLCBvdGhWYWx1ZSBbLCBpbmRleHxrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhvdGhWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydoZWxsbycsICdnb29kYnllJ107XG4gICAgICogdmFyIG90aGVyID0gWydoaScsICdnb29kYnllJ107XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIHVuZGVmaW5lZCwgY3VzdG9taXplcikgOiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICAgICAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gZXJyb3Igb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihuZXcgRXJyb3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFcnJvcihFcnJvcik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUubWVzc2FnZSA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSAnc3RyaW5nJyAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIHByaW1pdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0Zpbml0ZWBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0Zpbml0ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIG5hdGl2ZUlzRmluaXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKF8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgICAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAgICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdCh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICAgKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGBvYmplY3RgIGFuZCBgc291cmNlYCB0b1xuICAgICAqIGRldGVybWluZSBpZiBgb2JqZWN0YCBjb250YWlucyBlcXVpdmFsZW50IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLm1hdGNoZXNgIHdoZW4gYHNvdXJjZWAgaXNcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hdGNoKG9iamVjdCwgeyAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzTWF0Y2hgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBmaXZlXG4gICAgICogYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBpbmRleHxrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gL15oKD86aXxlbGxvKSQvLnRlc3QodmFsdWUpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoaXNHcmVldGluZyhvYmpWYWx1ZSkgJiYgaXNHcmVldGluZyhzcmNWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHRydWU7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2dyZWV0aW5nJzogJ2hlbGxvJyB9O1xuICAgICAqIHZhciBzb3VyY2UgPSB7ICdncmVldGluZyc6ICdoaScgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc05hTmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc05hTikgYW5kIGlzIG5vdCB0aGUgc2FtZSBhc1xuICAgICAqIGdsb2JhbCBbYGlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vaXNOYU4pIHdoaWNoIHJldHVybnMgYHRydWVgIGZvclxuICAgICAqIGB1bmRlZmluZWRgIGFuZCBvdGhlciBub24tbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hTihOYU4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgICAvLyBBbiBgTmFOYCBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmLlxuICAgICAgLy8gUGVyZm9ybSB0aGUgYHRvU3RyaW5nVGFnYCBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lXG4gICAgICAvLyBBY3RpdmVYIG9iamVjdHMgaW4gSUUuXG4gICAgICByZXR1cm4gaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlICE9ICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByaXN0aW5lIG5hdGl2ZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBjYW4ndCByZWxpYWJseSBkZXRlY3QgbmF0aXZlIGZ1bmN0aW9ucyBpbiB0aGUgcHJlc2VuY2VcbiAgICAgKiBvZiB0aGUgY29yZS1qcyBwYWNrYWdlIGJlY2F1c2UgY29yZS1qcyBjaXJjdW12ZW50cyB0aGlzIGtpbmQgb2YgZGV0ZWN0aW9uLlxuICAgICAqIERlc3BpdGUgbXVsdGlwbGUgcmVxdWVzdHMsIHRoZSBjb3JlLWpzIG1haW50YWluZXIgaGFzIG1hZGUgaXQgY2xlYXI6IGFueVxuICAgICAqIGF0dGVtcHQgdG8gZml4IHRoZSBkZXRlY3Rpb24gd2lsbCBiZSBvYnN0cnVjdGVkLiBBcyBhIHJlc3VsdCwgd2UncmUgbGVmdFxuICAgICAqIHdpdGggbGl0dGxlIGNob2ljZSBidXQgdG8gdGhyb3cgYW4gZXJyb3IuIFVuZm9ydHVuYXRlbHksIHRoaXMgYWxzbyBhZmZlY3RzXG4gICAgICogcGFja2FnZXMsIGxpa2UgW2JhYmVsLXBvbHlmaWxsXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9iYWJlbC1wb2x5ZmlsbCksXG4gICAgICogd2hpY2ggcmVseSBvbiBjb3JlLWpzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKEFycmF5LnByb3RvdHlwZS5wdXNoKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmF0aXZlKF8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmIChpc01hc2thYmxlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09SRV9FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYG51bGxgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdWxsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG51bGxpc2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05pbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbChOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTnVtYmVyYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRvIGV4Y2x1ZGUgYEluZmluaXR5YCwgYC1JbmZpbml0eWAsIGFuZCBgTmFOYCwgd2hpY2ggYXJlXG4gICAgICogY2xhc3NpZmllZCBhcyBudW1iZXJzLCB1c2UgdGhlIGBfLmlzRmluaXRlYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBudW1iZXJUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAgICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC44LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICAgICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFJlZ0V4cGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlci4gQW4gaW50ZWdlciBpcyBzYWZlIGlmIGl0J3MgYW4gSUVFRS03NTRcbiAgICAgKiBkb3VibGUgcHJlY2lzaW9uIG51bWJlciB3aGljaCBpc24ndCB0aGUgcmVzdWx0IG9mIGEgcm91bmRlZCB1bnNhZmUgaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzU2FmZUludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNTYWZlSW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gLU1BWF9TQUZFX0lOVEVHRVIgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygnYWJjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N0cmluZygxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha01hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBXZWFrTWFwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgTWFwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSB3ZWFrTWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgV2Vha1NldGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHdlYWsgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzV2Vha1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gd2Vha1NldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHQoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5sdCgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubHRlKDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHRlKDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPD0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoMSk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBjb3B5QXJyYXkodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JUb0FycmF5KHZhbHVlW3N5bUl0ZXJhdG9yXSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICAgIGZ1bmMgPSB0YWcgPT0gbWFwVGFnID8gbWFwVG9BcnJheSA6ICh0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcyk7XG5cbiAgICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEyLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyIHN1aXRhYmxlIGZvciB1c2UgYXMgdGhlIGxlbmd0aCBvZiBhblxuICAgICAqIGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b0xlbmd0aChJbmZpbml0eSk7XG4gICAgICogLy8gPT4gNDI5NDk2NzI5NVxuICAgICAqXG4gICAgICogXy50b0xlbmd0aCgnMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTGVuZ3RoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgMCwgTUFYX0FSUkFZX0xFTkdUSCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gSW5maW5pdHlcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgIH1cbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gd2l0aCBsb29rdXAgKGluIGNhc2Ugb2YgZS5nLiBwcm90b3R5cGUgcG9sbHV0aW9uKSwgYW5kIHN0cmlwIG5ld2xpbmVzIGlmIGFueS5cbiAgICAgIC8vIEEgbmV3bGluZSB3b3VsZG4ndCBiZSBhIHZhbGlkIHNvdXJjZVVSTCBhbnl3YXksIGFuZCBpdCdkIGVuYWJsZSBjb2RlIGluamVjdGlvbi5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvW1xcclxcbl0vZywgJyAnKVxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICAvLyBMaWtlIHdpdGggc291cmNlVVJMLCB3ZSB0YWtlIGNhcmUgdG8gbm90IGNoZWNrIHRoZSBvcHRpb24ncyBwcm90b3R5cGUsXG4gICAgICAvLyBhcyB0aGlzIGNvbmZpZ3VyYXRpb24gaXMgYSBjb2RlIGluamVjdGlvbiB2ZWN0b3IuXG4gICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgIHNvdXJjZSA9ICd3aXRoIChvYmopIHtcXG4nICsgc291cmNlICsgJ1xcbn1cXG4nO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gICAgICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICAgICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICAgICAodmFyaWFibGVcbiAgICAgICAgICA/ICcnXG4gICAgICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgXCJ2YXIgX190LCBfX3AgPSAnJ1wiICtcbiAgICAgICAgKGlzRXNjYXBpbmdcbiAgICAgICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICAgICAgOiAnJ1xuICAgICAgICApICtcbiAgICAgICAgKGlzRXZhbHVhdGluZ1xuICAgICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICAgICAgOiAnO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIHNvdXJjZSArXG4gICAgICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgICAgIHZhciByZXN1bHQgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgICAgIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gICAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgICAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byBsb3dlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9Mb3dlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvTG93ZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0xvd2VyKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICctLWZvby1iYXItLSdcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb2JhcidcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnX19mb29fYmFyX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb3dlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBhIHdob2xlLCB0byB1cHBlciBjYXNlIGp1c3QgbGlrZVxuICAgICAqIFtTdHJpbmcjdG9VcHBlckNhc2VdKGh0dHBzOi8vbWRuLmlvL3RvVXBwZXJDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1VwcGVyKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICctLUZPTy1CQVItLSdcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPT0JBUidcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnX19GT09fQkFSX18nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9VcHBlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbSgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICpcbiAgICAgKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pO1xuICAgICAqIC8vID0+IFsnZm9vJywgJ2JhciddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbUVuZCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyRXZlcnkoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgKiphbnkqKiBvZiB0aGUgYHByZWRpY2F0ZXNgIHJldHVyblxuICAgICAqIHRydXRoeSB3aGVuIGludm9rZWQgd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCJ2YXIgc3VwZXJQcm9wQmFzZSA9IHJlcXVpcmUoXCIuL3N1cGVyUHJvcEJhc2VcIik7XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gUmVmbGVjdC5nZXQ7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuXG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwiLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFRyYWNlciA9IHtcbiAgICBzZWFyY2hEaXJlY3Rpb25zOiBbWzAsIDFdLCBbMSwgMV0sIFsxLCAwXSwgWzEsIC0xXSwgWzAsIC0xXSwgWy0xLCAtMV0sIFstMSwgMF0sIFstMSwgMV1dLFxuICAgIGNyZWF0ZShpbWFnZVdyYXBwZXIsIGxhYmVsV3JhcHBlcikge1xuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZVdyYXBwZXIuZGF0YTtcbiAgICAgICAgY29uc3QgbGFiZWxEYXRhID0gbGFiZWxXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IHsgc2VhcmNoRGlyZWN0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgICAgICBsZXQgcG9zO1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSB7XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgbGV0IHg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC5jeSArIHNlYXJjaERpcmVjdGlvbnNbY3VycmVudC5kaXJdWzBdO1xuICAgICAgICAgICAgICAgIHggPSBjdXJyZW50LmN4ICsgc2VhcmNoRGlyZWN0aW9uc1tjdXJyZW50LmRpcl1bMV07XG4gICAgICAgICAgICAgICAgcG9zID0geSAqIHdpZHRoICsgeDtcbiAgICAgICAgICAgICAgICBpZiAoKGltYWdlRGF0YVtwb3NdID09PSBjb2xvcikgJiYgKChsYWJlbERhdGFbcG9zXSA9PT0gMCkgfHwgKGxhYmVsRGF0YVtwb3NdID09PSBsYWJlbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuY3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmN4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYWJlbERhdGFbcG9zXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbERhdGFbcG9zXSA9IGVkZ2VsYWJlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyAxKSAlIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB2ZXJ0ZXgyRCh4LCB5LCBkaXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyLFxuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXY6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgbGV0IEZ2ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBDdjtcbiAgICAgICAgICAgIGxldCBQO1xuICAgICAgICAgICAgbGV0IGxkaXI7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIGN4OiBzeCxcbiAgICAgICAgICAgICAgICBjeTogc3ksXG4gICAgICAgICAgICAgICAgZGlyOiAwLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKSkge1xuICAgICAgICAgICAgICAgIEZ2ID0gdmVydGV4MkQoc3gsIHN5LCBjdXJyZW50LmRpcik7XG4gICAgICAgICAgICAgICAgQ3YgPSBGdjtcbiAgICAgICAgICAgICAgICBsZGlyID0gY3VycmVudC5kaXI7XG4gICAgICAgICAgICAgICAgUCA9IHZlcnRleDJEKGN1cnJlbnQuY3gsIGN1cnJlbnQuY3ksIDApO1xuICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgIEN2Lm5leHQgPSBQO1xuICAgICAgICAgICAgICAgIFAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXIgPSAoY3VycmVudC5kaXIgKyA2KSAlIDg7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKGN1cnJlbnQsIGNvbG9yLCBsYWJlbCwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxkaXIgIT09IGN1cnJlbnQuZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDdi5kaXIgPSBjdXJyZW50LmRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAgPSB2ZXJ0ZXgyRChjdXJyZW50LmN4LCBjdXJyZW50LmN5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFAucHJldiA9IEN2O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YubmV4dCA9IFA7XG4gICAgICAgICAgICAgICAgICAgICAgICBQLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YgPSBQO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YuZGlyID0gbGRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIEN2LnggPSBjdXJyZW50LmN4O1xuICAgICAgICAgICAgICAgICAgICAgICAgQ3YueSA9IGN1cnJlbnQuY3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGRpciA9IGN1cnJlbnQuZGlyO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQuY3ggIT09IHN4IHx8IGN1cnJlbnQuY3kgIT09IHN5KTtcbiAgICAgICAgICAgICAgICBGdi5wcmV2ID0gQ3YucHJldjtcbiAgICAgICAgICAgICAgICBDdi5wcmV2Lm5leHQgPSBGdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBGdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZShjdXJyZW50LCBjb2xvciwgbGFiZWwsIGVkZ2VsYWJlbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udG91clRyYWNpbmcoc3ksIHN4LCBsYWJlbCwgY29sb3IsIGVkZ2VsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250b3VyVHJhY2luZyhzeSwgc3gsIGxhYmVsLCBjb2xvciwgZWRnZWxhYmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IChUcmFjZXIpO1xuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnZ2wtdmVjMic7XG5pbXBvcnQgKiBhcyBtYXQyIGZyb20gJ2dsLW1hdDInO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQge1xuICAgIGNhbGN1bGF0ZVBhdGNoU2l6ZSxcbiAgICBvdHN1VGhyZXNob2xkLFxuICAgIGhzdjJyZ2IsXG4gICAgY2x1c3RlcixcbiAgICB0b3BHZW5lcmljLFxuICAgIGltYWdlUmVmLFxuICAgIGhhbGZTYW1wbGUsXG4gICAgY29tcHV0ZUltYWdlQXJlYSxcbn0gZnJvbSAnLi4vY29tbW9uL2N2X3V0aWxzJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcbmltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQgUmFzdGVyaXplciBmcm9tICcuL3Jhc3Rlcml6ZXInO1xuaW1wb3J0IFRyYWNlciBmcm9tICcuL3RyYWNlcic7XG5pbXBvcnQgc2tlbGV0b25pemVyIGZyb20gJy4vc2tlbGV0b25pemVyJztcblxuXG5sZXQgX2NvbmZpZztcbmxldCBfY3VycmVudEltYWdlV3JhcHBlcjtcbmxldCBfc2tlbEltYWdlV3JhcHBlcjtcbmxldCBfc3ViSW1hZ2VXcmFwcGVyO1xubGV0IF9sYWJlbEltYWdlV3JhcHBlcjtcbmxldCBfcGF0Y2hHcmlkO1xubGV0IF9wYXRjaExhYmVsR3JpZDtcbmxldCBfaW1hZ2VUb1BhdGNoR3JpZDtcbmxldCBfYmluYXJ5SW1hZ2VXcmFwcGVyO1xubGV0IF9wYXRjaFNpemU7XG5jb25zdCBfY2FudmFzQ29udGFpbmVyID0ge1xuICAgIGN0eDoge1xuICAgICAgICBiaW5hcnk6IG51bGwsXG4gICAgfSxcbiAgICBkb206IHtcbiAgICAgICAgYmluYXJ5OiBudWxsLFxuICAgIH0sXG59O1xuY29uc3QgX251bVBhdGNoZXMgPSB7IHg6IDAsIHk6IDAgfTtcbmxldCBfaW5wdXRJbWFnZVdyYXBwZXI7XG5sZXQgX3NrZWxldG9uaXplcjtcblxuZnVuY3Rpb24gaW5pdEJ1ZmZlcnMoKSB7XG4gICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICBfY3VycmVudEltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgICAgIHg6IF9pbnB1dEltYWdlV3JhcHBlci5zaXplLnggLyAyIHwgMCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICB5OiBfaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS55IC8gMiB8IDAsXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9jdXJyZW50SW1hZ2VXcmFwcGVyID0gX2lucHV0SW1hZ2VXcmFwcGVyO1xuICAgIH1cblxuICAgIF9wYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoX2NvbmZpZy5wYXRjaFNpemUsIF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBfbnVtUGF0Y2hlcy54ID0gX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3BhdGNoU2l6ZS54IHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgIF9udW1QYXRjaGVzLnkgPSBfY3VycmVudEltYWdlV3JhcHBlci5zaXplLnkgLyBfcGF0Y2hTaXplLnkgfCAwO1xuXG4gICAgX2JpbmFyeUltYWdlV3JhcHBlciA9IG5ldyBJbWFnZVdyYXBwZXIoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZSwgdW5kZWZpbmVkLCBVaW50OEFycmF5LCBmYWxzZSk7XG5cbiAgICBfbGFiZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsIHVuZGVmaW5lZCwgQXJyYXksIHRydWUpO1xuXG4gICAgY29uc3Qgc2tlbGV0b25JbWFnZURhdGEgPSBuZXcgQXJyYXlCdWZmZXIoNjQgKiAxMDI0KTtcbiAgICBfc3ViSW1hZ2VXcmFwcGVyID0gbmV3IEltYWdlV3JhcHBlcihfcGF0Y2hTaXplLFxuICAgICAgICBuZXcgVWludDhBcnJheShza2VsZXRvbkltYWdlRGF0YSwgMCwgX3BhdGNoU2l6ZS54ICogX3BhdGNoU2l6ZS55KSk7XG4gICAgX3NrZWxJbWFnZVdyYXBwZXIgPSBuZXcgSW1hZ2VXcmFwcGVyKF9wYXRjaFNpemUsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KHNrZWxldG9uSW1hZ2VEYXRhLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkgKiAzLCBfcGF0Y2hTaXplLnggKiBfcGF0Y2hTaXplLnkpLFxuICAgICAgICB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9za2VsZXRvbml6ZXIgPSBza2VsZXRvbml6ZXIoXG4gICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSA/IHNlbGYgOiBnbG9iYWwsXG4gICAgICAgIHsgc2l6ZTogX3BhdGNoU2l6ZS54IH0sXG4gICAgICAgIHNrZWxldG9uSW1hZ2VEYXRhLFxuICAgICk7XG5cbiAgICBfaW1hZ2VUb1BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoe1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB4OiAoX2N1cnJlbnRJbWFnZVdyYXBwZXIuc2l6ZS54IC8gX3N1YkltYWdlV3JhcHBlci5zaXplLngpIHwgMCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgICAgeTogKF9jdXJyZW50SW1hZ2VXcmFwcGVyLnNpemUueSAvIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS55KSB8IDAsXG4gICAgfSwgdW5kZWZpbmVkLCBBcnJheSwgdHJ1ZSk7XG4gICAgX3BhdGNoR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIF9wYXRjaExhYmVsR3JpZCA9IG5ldyBJbWFnZVdyYXBwZXIoX2ltYWdlVG9QYXRjaEdyaWQuc2l6ZSwgdW5kZWZpbmVkLCBJbnQzMkFycmF5LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICBpZiAoX2NvbmZpZy51c2VXb3JrZXIgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXNDb250YWluZXIuZG9tLmJpbmFyeS5jbGFzc05hbWUgPSAnYmluYXJ5QnVmZmVyJztcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcyA9PT0gdHJ1ZSkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjZGVidWcnKS5hcHBlbmRDaGlsZChfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkpO1xuICAgIH1cbiAgICBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnkgPSBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkud2lkdGggPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnkuaGVpZ2h0ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJvdW5kaW5nIGJveCB3aGljaCBlbmNsb3NlcyBhbGwgdGhlIGdpdmVuIHBhdGNoZXNcbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG1pbmltYWwgYm91bmRpbmcgYm94XG4gKi9cbmZ1bmN0aW9uIGJveEZyb21QYXRjaGVzKHBhdGNoZXMpIHtcbiAgICBsZXQgb3ZlckF2ZztcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgbGV0IHRyYW5zTWF0O1xuICAgIGxldCBtaW54ID0gX2JpbmFyeUltYWdlV3JhcHBlci5zaXplLng7XG4gICAgbGV0IG1pbnkgPSBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgbWF4eCA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueDtcbiAgICBsZXQgbWF4eSA9IC1fYmluYXJ5SW1hZ2VXcmFwcGVyLnNpemUueTtcbiAgICBsZXQgYm94O1xuICAgIGxldCBzY2FsZTtcblxuICAgIC8vIGRyYXcgYWxsIHBhdGNoZXMgd2hpY2ggYXJlIHRvIGJlIHRha2VuIGludG8gY29uc2lkZXJhdGlvblxuICAgIG92ZXJBdmcgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgICAgb3ZlckF2ZyArPSBwYXRjaC5yYWQ7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UGF0Y2hlcykge1xuICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UmVjdChwYXRjaC5wb3MsIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAncmVkJyB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG92ZXJBdmcgLz0gcGF0Y2hlcy5sZW5ndGg7XG4gICAgb3ZlckF2ZyA9IChvdmVyQXZnICogMTgwIC8gTWF0aC5QSSArIDkwKSAlIDE4MCAtIDkwO1xuICAgIGlmIChvdmVyQXZnIDwgMCkge1xuICAgICAgICBvdmVyQXZnICs9IDE4MDtcbiAgICB9XG5cbiAgICBvdmVyQXZnID0gKDE4MCAtIG92ZXJBdmcpICogTWF0aC5QSSAvIDE4MDtcbiAgICB0cmFuc01hdCA9IG1hdDIuY29weShtYXQyLmNyZWF0ZSgpLCBbTWF0aC5jb3Mob3ZlckF2ZyksIE1hdGguc2luKG92ZXJBdmcpLCAtTWF0aC5zaW4ob3ZlckF2ZyksIE1hdGguY29zKG92ZXJBdmcpXSk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgcGF0Y2hlcyBhbmQgcm90YXRlIGJ5IGFuZ2xlXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIocGF0Y2guYm94W2pdLCBwYXRjaC5ib3hbal0sIHRyYW5zTWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWQpIHtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgocGF0Y2guYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmQgYm91bmRpbmcgYm94XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGF0Y2ggPSBwYXRjaGVzW2ldO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdIDwgbWlueCkge1xuICAgICAgICAgICAgICAgIG1pbnggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzBdID4gbWF4eCkge1xuICAgICAgICAgICAgICAgIG1heHggPSBwYXRjaC5ib3hbal1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdIDwgbWlueSkge1xuICAgICAgICAgICAgICAgIG1pbnkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0Y2guYm94W2pdWzFdID4gbWF4eSkge1xuICAgICAgICAgICAgICAgIG1heHkgPSBwYXRjaC5ib3hbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBib3ggPSBbW21pbngsIG1pbnldLCBbbWF4eCwgbWlueV0sIFttYXh4LCBtYXh5XSwgW21pbngsIG1heHldXTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5ib3hGcm9tUGF0Y2hlcy5zaG93VHJhbnNmb3JtZWRCb3gpIHtcbiAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChib3gsIHsgeDogMCwgeTogMSB9LCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksIHsgY29sb3I6ICcjZmYwMDAwJywgbGluZVdpZHRoOiAyIH0pO1xuICAgIH1cblxuICAgIHNjYWxlID0gX2NvbmZpZy5oYWxmU2FtcGxlID8gMiA6IDE7XG4gICAgLy8gcmV2ZXJzZSByb3RhdGlvbjtcbiAgICB0cmFuc01hdCA9IG1hdDIuaW52ZXJ0KHRyYW5zTWF0LCB0cmFuc01hdCk7XG4gICAgZm9yIChqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICB2ZWMyLnRyYW5zZm9ybU1hdDIoYm94W2pdLCBib3hbal0sIHRyYW5zTWF0KTtcbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuYm94RnJvbVBhdGNoZXMuc2hvd0JCKSB7XG4gICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgoYm94LCB7IHg6IDAsIHk6IDEgfSwgX2NhbnZhc0NvbnRhaW5lci5jdHguYmluYXJ5LCB7IGNvbG9yOiAnI2ZmMDAwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgNDsgaisrKSB7XG4gICAgICAgIHZlYzIuc2NhbGUoYm94W2pdLCBib3hbal0sIHNjYWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm94O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBiaW5hcnkgaW1hZ2Ugb2YgdGhlIGN1cnJlbnQgaW1hZ2VcbiAqL1xuZnVuY3Rpb24gYmluYXJpemVJbWFnZSgpIHtcbiAgICBvdHN1VGhyZXNob2xkKF9jdXJyZW50SW1hZ2VXcmFwcGVyLCBfYmluYXJ5SW1hZ2VXcmFwcGVyKTtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0NhbnZhcykge1xuICAgICAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnNob3coX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCAyNTUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBpbWFnZVxuICogZXh0cmFjdCBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXRjaGVzKCkge1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIGxldCBtb21lbnRzO1xuICAgIGxldCBwYXRjaGVzRm91bmQgPSBbXTtcbiAgICBsZXQgcmFzdGVyaXplcjtcbiAgICBsZXQgcmFzdGVyUmVzdWx0O1xuICAgIGxldCBwYXRjaDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgX251bVBhdGNoZXMueDsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBfbnVtUGF0Y2hlcy55OyBqKyspIHtcbiAgICAgICAgICAgIHggPSBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCAqIGk7XG4gICAgICAgICAgICB5ID0gX3N1YkltYWdlV3JhcHBlci5zaXplLnkgKiBqO1xuXG4gICAgICAgICAgICAvLyBzZXBlcmF0ZSBwYXJ0c1xuICAgICAgICAgICAgc2tlbGV0b25pemUoeCwgeSk7XG5cbiAgICAgICAgICAgIC8vIFJhc3Rlcml6ZSwgZmluZCBpbmRpdmlkdWFsIGJhcnNcbiAgICAgICAgICAgIF9za2VsSW1hZ2VXcmFwcGVyLnplcm9Cb3JkZXIoKTtcbiAgICAgICAgICAgIEFycmF5SGVscGVyLmluaXQoX2xhYmVsSW1hZ2VXcmFwcGVyLmRhdGEsIDApO1xuICAgICAgICAgICAgcmFzdGVyaXplciA9IFJhc3Rlcml6ZXIuY3JlYXRlKF9za2VsSW1hZ2VXcmFwcGVyLCBfbGFiZWxJbWFnZVdyYXBwZXIpO1xuICAgICAgICAgICAgcmFzdGVyUmVzdWx0ID0gcmFzdGVyaXplci5yYXN0ZXJpemUoMCk7XG5cbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgX2xhYmVsSW1hZ2VXcmFwcGVyLm92ZXJsYXkoX2NhbnZhc0NvbnRhaW5lci5kb20uYmluYXJ5LCBNYXRoLmZsb29yKDM2MCAvIHJhc3RlclJlc3VsdC5jb3VudCksXG4gICAgICAgICAgICAgICAgICAgIHsgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIG1vbWVudHMgZnJvbSB0aGUgc2tlbGV0b25pemVkIHBhdGNoXG4gICAgICAgICAgICBtb21lbnRzID0gX2xhYmVsSW1hZ2VXcmFwcGVyLm1vbWVudHMocmFzdGVyUmVzdWx0LmNvdW50KTtcblxuICAgICAgICAgICAgLy8gZXh0cmFjdCBlbGlnaWJsZSBwYXRjaGVzXG4gICAgICAgICAgICBwYXRjaGVzRm91bmQgPSBwYXRjaGVzRm91bmQuY29uY2F0KGRlc2NyaWJlUGF0Y2gobW9tZW50cywgW2ksIGpdLCB4LCB5KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIF9jb25maWcuZGVidWcuc2hvd0ZvdW5kUGF0Y2hlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGF0Y2hlc0ZvdW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtpXTtcbiAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICB7IGNvbG9yOiAnIzk5ZmYwMCcsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRjaGVzRm91bmQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhvc2UgY29ubmVjdGVkIGFyZWFzIHdoaWNoIGNvbnRhaW4gYXQgbGVhc3QgNiBwYXRjaGVzXG4gKiBhbmQgcmV0dXJucyB0aGVtIG9yZGVyZWQgREVTQyBieSB0aGUgbnVtYmVyIG9mIGNvbnRhaW5lZCBwYXRjaGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4TGFiZWxcbiAqL1xuZnVuY3Rpb24gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCkge1xuICAgIGxldCBpO1xuICAgIGxldCBzdW07XG4gICAgbGV0IGxhYmVsSGlzdCA9IFtdO1xuICAgIGxldCB0b3BMYWJlbHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXhMYWJlbDsgaSsrKSB7XG4gICAgICAgIGxhYmVsSGlzdC5wdXNoKDApO1xuICAgIH1cbiAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtzdW1dID4gMCkge1xuICAgICAgICAgICAgbGFiZWxIaXN0W19wYXRjaExhYmVsR3JpZC5kYXRhW3N1bV0gLSAxXSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGFiZWxIaXN0ID0gbGFiZWxIaXN0Lm1hcCgodmFsLCBpZHgpID0+ICh7XG4gICAgICAgIHZhbCxcbiAgICAgICAgbGFiZWw6IGlkeCArIDEsXG4gICAgfSkpO1xuXG4gICAgbGFiZWxIaXN0LnNvcnQoKGEsIGIpID0+IGIudmFsIC0gYS52YWwpO1xuXG4gICAgLy8gZXh0cmFjdCB0b3AgYXJlYXMgd2l0aCBhdCBsZWFzdCA2IHBhdGNoZXMgcHJlc2VudFxuICAgIHRvcExhYmVscyA9IGxhYmVsSGlzdC5maWx0ZXIoKGVsKSA9PiBlbC52YWwgPj0gNSk7XG5cbiAgICByZXR1cm4gdG9wTGFiZWxzO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGZpbmRCb3hlcyh0b3BMYWJlbHMsIG1heExhYmVsKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IHN1bTtcbiAgICBjb25zdCBwYXRjaGVzID0gW107XG4gICAgbGV0IHBhdGNoO1xuICAgIGxldCBib3g7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCBoc3YgPSBbMCwgMSwgMV07XG4gICAgY29uc3QgcmdiID0gWzAsIDAsIDBdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRvcExhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdW0gPSBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7XG4gICAgICAgIHBhdGNoZXMubGVuZ3RoID0gMDtcbiAgICAgICAgd2hpbGUgKHN1bS0tKSB7XG4gICAgICAgICAgICBpZiAoX3BhdGNoTGFiZWxHcmlkLmRhdGFbc3VtXSA9PT0gdG9wTGFiZWxzW2ldLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2ggPSBfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW3N1bV07XG4gICAgICAgICAgICAgICAgcGF0Y2hlcy5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib3ggPSBib3hGcm9tUGF0Y2hlcyhwYXRjaGVzKTtcbiAgICAgICAgaWYgKGJveCkge1xuICAgICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuXG4gICAgICAgICAgICAvLyBkcmF3IHBhdGNoLWxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93UmVtYWluaW5nUGF0Y2hMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGF0Y2hlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRjaCA9IHBhdGNoZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGhzdlswXSA9ICh0b3BMYWJlbHNbaV0ubGFiZWwgLyAobWF4TGFiZWwgKyAxKSkgKiAzNjA7XG4gICAgICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdSZWN0KHBhdGNoLnBvcywgX3N1YkltYWdlV3JhcHBlci5zaXplLCBfY2FudmFzQ29udGFpbmVyLmN0eC5iaW5hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNvbG9yOiBgcmdiKCR7cmdiLmpvaW4oJywnKX0pYCwgbGluZVdpZHRoOiAyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXM7XG59XG5cbi8qKlxuICogRmluZCBzaW1pbGFyIG1vbWVudHMgKHZpYSBjbHVzdGVyKVxuICogQHBhcmFtIHtPYmplY3R9IG1vbWVudHNcbiAqL1xuZnVuY3Rpb24gc2ltaWxhck1vbWVudHMobW9tZW50cykge1xuICAgIGNvbnN0IGNsdXN0ZXJzID0gY2x1c3Rlcihtb21lbnRzLCAwLjkwKTtcbiAgICBjb25zdCB0b3BDbHVzdGVyID0gdG9wR2VuZXJpYyhjbHVzdGVycywgMSwgKGUpID0+IGUuZ2V0UG9pbnRzKCkubGVuZ3RoKTtcbiAgICBsZXQgcG9pbnRzID0gW107IGNvbnN0XG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIGlmICh0b3BDbHVzdGVyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBwb2ludHMgPSB0b3BDbHVzdGVyWzBdLml0ZW0uZ2V0UG9pbnRzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwb2ludHNbaV0ucG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHNrZWxldG9uaXplKHgsIHkpIHtcbiAgICBfYmluYXJ5SW1hZ2VXcmFwcGVyLnN1YkltYWdlQXNDb3B5KF9zdWJJbWFnZVdyYXBwZXIsIGltYWdlUmVmKHgsIHkpKTtcbiAgICBfc2tlbGV0b25pemVyLnNrZWxldG9uaXplKCk7XG5cbiAgICAvLyBTaG93IHNrZWxldG9uIGlmIHJlcXVlc3RlZFxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgX2NvbmZpZy5kZWJ1Zy5zaG93U2tlbGV0b24pIHtcbiAgICAgICAgX3NrZWxJbWFnZVdyYXBwZXIub3ZlcmxheShfY2FudmFzQ29udGFpbmVyLmRvbS5iaW5hcnksIDM2MCwgaW1hZ2VSZWYoeCwgeSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhbmQgZGVzY3JpYmVzIHRob3NlIHBhdGNoZXMgd2hpY2ggc2VlbSB0byBjb250YWluIGEgYmFyY29kZSBwYXR0ZXJuXG4gKiBAcGFyYW0ge0FycmF5fSBtb21lbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcGF0Y2hQb3MsXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEByZXR1cm5zIHtBcnJheX0gbGlzdCBvZiBwYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUGF0Y2gobW9tZW50cywgcGF0Y2hQb3MsIHgsIHkpIHtcbiAgICBsZXQgaztcbiAgICBsZXQgYXZnO1xuICAgIGNvbnN0IGVsaWdpYmxlTW9tZW50cyA9IFtdO1xuICAgIGxldCBtYXRjaGluZ01vbWVudHM7XG4gICAgbGV0IHBhdGNoO1xuICAgIGNvbnN0IHBhdGNoZXNGb3VuZCA9IFtdO1xuICAgIGNvbnN0IG1pbkNvbXBvbmVudFdlaWdodCA9IE1hdGguY2VpbChfcGF0Y2hTaXplLnggLyAzKTtcblxuICAgIGlmIChtb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIC8vIG9ubHkgY29sbGVjdCBtb21lbnRzIHdoaWNoJ3MgYXJlYSBjb3ZlcnMgYXQgbGVhc3QgbWluQ29tcG9uZW50V2VpZ2h0IHBpeGVscy5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IG1vbWVudHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2tdLm0wMCA+IG1pbkNvbXBvbmVudFdlaWdodCkge1xuICAgICAgICAgICAgICAgIGVsaWdpYmxlTW9tZW50cy5wdXNoKG1vbWVudHNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXQgbGVhc3QgMiBtb21lbnRzIGFyZSBmb3VuZCB3aGljaCBoYXZlIGF0IGxlYXN0IG1pbkNvbXBvbmVudFdlaWdodHMgY292ZXJlZFxuICAgICAgICBpZiAoZWxpZ2libGVNb21lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBtYXRjaGluZ01vbWVudHMgPSBzaW1pbGFyTW9tZW50cyhlbGlnaWJsZU1vbWVudHMpO1xuICAgICAgICAgICAgYXZnID0gMDtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc2ltaWxhcml0eSBvZiB0aGUgbW9tZW50c1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoaW5nTW9tZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGF2ZyArPSBtYXRjaGluZ01vbWVudHNba10ucmFkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IHR3byBvZiB0aGUgbW9tZW50cyBhcmUgYWxsb3dlZCBub3QgdG8gZml0IGludG8gdGhlIGVxdWF0aW9uXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHBhdGNoIHRvIHRoZSBzZXRcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ01vbWVudHMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICAmJiBtYXRjaGluZ01vbWVudHMubGVuZ3RoID49IChlbGlnaWJsZU1vbWVudHMubGVuZ3RoIC8gNCkgKiAzXG4gICAgICAgICAgICAgICAgICAgICYmIG1hdGNoaW5nTW9tZW50cy5sZW5ndGggPiBtb21lbnRzLmxlbmd0aCAvIDQpIHtcbiAgICAgICAgICAgICAgICBhdmcgLz0gbWF0Y2hpbmdNb21lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhdGNoUG9zWzFdICogX251bVBhdGNoZXMueCArIHBhdGNoUG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBib3g6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3ggKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueCwgeV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVjMi5jbG9uZShbeCArIF9zdWJJbWFnZVdyYXBwZXIuc2l6ZS54LCB5ICsgX3N1YkltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIuY2xvbmUoW3gsIHkgKyBfc3ViSW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBtb21lbnRzOiBtYXRjaGluZ01vbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHJhZDogYXZnLFxuICAgICAgICAgICAgICAgICAgICB2ZWM6IHZlYzIuY2xvbmUoW01hdGguY29zKGF2ZyksIE1hdGguc2luKGF2ZyldKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhdGNoZXNGb3VuZC5wdXNoKHBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlc0ZvdW5kO1xufVxuXG4vKipcbiAqIGZpbmRzIHBhdGNoZXMgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2hhcmUgdGhlIHNhbWUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXRjaGVzRm91bmRcbiAqL1xuZnVuY3Rpb24gcmFzdGVyaXplQW5ndWxhclNpbWlsYXJpdHkocGF0Y2hlc0ZvdW5kKSB7XG4gICAgbGV0IGxhYmVsID0gMDtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSAwLjk1O1xuICAgIGxldCBjdXJySWR4ID0gMDtcbiAgICBsZXQgajtcbiAgICBsZXQgcGF0Y2g7XG4gICAgY29uc3QgaHN2ID0gWzAsIDEsIDFdO1xuICAgIGNvbnN0IHJnYiA9IFswLCAwLCAwXTtcblxuICAgIGZ1bmN0aW9uIG5vdFlldFByb2Nlc3NlZCgpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKF9wYXRjaExhYmVsR3JpZC5kYXRhW2ldID09PSAwICYmIF9wYXRjaEdyaWQuZGF0YVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcGF0Y2hMYWJlbEdyaWQubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWNlKGN1cnJlbnRJZHgpIHtcbiAgICAgICAgbGV0IHg7XG4gICAgICAgIGxldCB5O1xuICAgICAgICBsZXQgY3VycmVudFBhdGNoO1xuICAgICAgICBsZXQgaWR4O1xuICAgICAgICBsZXQgZGlyO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0ge1xuICAgICAgICAgICAgeDogY3VycmVudElkeCAlIF9wYXRjaExhYmVsR3JpZC5zaXplLngsXG4gICAgICAgICAgICB5OiAoY3VycmVudElkeCAvIF9wYXRjaExhYmVsR3JpZC5zaXplLngpIHwgMCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNpbWlsYXJpdHk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJZHggPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbY3VycmVudElkeF07XG4gICAgICAgICAgICAvLyBhc3NpZ24gbGFiZWxcbiAgICAgICAgICAgIF9wYXRjaExhYmVsR3JpZC5kYXRhW2N1cnJlbnRJZHhdID0gbGFiZWw7XG4gICAgICAgICAgICBmb3IgKGRpciA9IDA7IGRpciA8IFRyYWNlci5zZWFyY2hEaXJlY3Rpb25zLmxlbmd0aDsgZGlyKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gY3VycmVudC55ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVswXTtcbiAgICAgICAgICAgICAgICB4ID0gY3VycmVudC54ICsgVHJhY2VyLnNlYXJjaERpcmVjdGlvbnNbZGlyXVsxXTtcbiAgICAgICAgICAgICAgICBpZHggPSB5ICogX3BhdGNoTGFiZWxHcmlkLnNpemUueCArIHg7XG5cbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBpZiBwYXRjaCBlbXB0eVxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hHcmlkLmRhdGFbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbWlsYXJpdHkgPSBNYXRoLmFicyh2ZWMyLmRvdChfaW1hZ2VUb1BhdGNoR3JpZC5kYXRhW2lkeF0udmVjLCBjdXJyZW50UGF0Y2gudmVjKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW1pbGFyaXR5ID4gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZShpZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBmb3IgZmluZGluZyB0aGUgcmlnaHQgcGF0Y2hlc1xuICAgIEFycmF5SGVscGVyLmluaXQoX3BhdGNoR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9wYXRjaExhYmVsR3JpZC5kYXRhLCAwKTtcbiAgICBBcnJheUhlbHBlci5pbml0KF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGEsIG51bGwpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHBhdGNoZXNGb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXRjaCA9IHBhdGNoZXNGb3VuZFtqXTtcbiAgICAgICAgX2ltYWdlVG9QYXRjaEdyaWQuZGF0YVtwYXRjaC5pbmRleF0gPSBwYXRjaDtcbiAgICAgICAgX3BhdGNoR3JpZC5kYXRhW3BhdGNoLmluZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgLy8gcmFzdGVyaXplIHRoZSBwYXRjaGVzIGZvdW5kIHRvIGRldGVybWluZSBhcmVhXG4gICAgX3BhdGNoR3JpZC56ZXJvQm9yZGVyKCk7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICB3aGlsZSAoKGN1cnJJZHggPSBub3RZZXRQcm9jZXNzZWQoKSkgPCBfcGF0Y2hMYWJlbEdyaWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgbGFiZWwrKztcbiAgICAgICAgdHJhY2UoY3VycklkeCk7XG4gICAgfVxuXG4gICAgLy8gZHJhdyBwYXRjaC1sYWJlbHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiBfY29uZmlnLmRlYnVnLnNob3dQYXRjaExhYmVscykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgX3BhdGNoTGFiZWxHcmlkLmRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChfcGF0Y2hMYWJlbEdyaWQuZGF0YVtqXSA+IDAgJiYgX3BhdGNoTGFiZWxHcmlkLmRhdGFbal0gPD0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgICBwYXRjaCA9IF9pbWFnZVRvUGF0Y2hHcmlkLmRhdGFbal07XG4gICAgICAgICAgICAgICAgaHN2WzBdID0gKF9wYXRjaExhYmVsR3JpZC5kYXRhW2pdIC8gKGxhYmVsICsgMSkpICogMzYwO1xuICAgICAgICAgICAgICAgIGhzdjJyZ2IoaHN2LCByZ2IpO1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1JlY3QocGF0Y2gucG9zLCBfc3ViSW1hZ2VXcmFwcGVyLnNpemUsIF9jYW52YXNDb250YWluZXIuY3R4LmJpbmFyeSxcbiAgICAgICAgICAgICAgICAgICAgeyBjb2xvcjogYHJnYigke3JnYi5qb2luKCcsJyl9KWAsIGxpbmVXaWR0aDogMiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGluaXQoaW5wdXRJbWFnZVdyYXBwZXIsIGNvbmZpZykge1xuICAgICAgICBfY29uZmlnID0gY29uZmlnO1xuICAgICAgICBfaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcblxuICAgICAgICBpbml0QnVmZmVycygpO1xuICAgICAgICBpbml0Q2FudmFzKCk7XG4gICAgfSxcblxuICAgIGxvY2F0ZSgpIHtcbiAgICAgICAgaWYgKF9jb25maWcuaGFsZlNhbXBsZSkge1xuICAgICAgICAgICAgaGFsZlNhbXBsZShfaW5wdXRJbWFnZVdyYXBwZXIsIF9jdXJyZW50SW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpbmFyaXplSW1hZ2UoKTtcbiAgICAgICAgY29uc3QgcGF0Y2hlc0ZvdW5kID0gZmluZFBhdGNoZXMoKTtcbiAgICAgICAgLy8gcmV0dXJuIHVubGVzcyA1JSBvciBtb3JlIHBhdGNoZXMgYXJlIGZvdW5kXG4gICAgICAgIGlmIChwYXRjaGVzRm91bmQubGVuZ3RoIDwgX251bVBhdGNoZXMueCAqIF9udW1QYXRjaGVzLnkgKiAwLjA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJhc3RlcnJpemUgYXJlYSBieSBjb21wYXJpbmcgYW5ndWxhciBzaW1pbGFyaXR5O1xuICAgICAgICBjb25zdCBtYXhMYWJlbCA9IHJhc3Rlcml6ZUFuZ3VsYXJTaW1pbGFyaXR5KHBhdGNoZXNGb3VuZCk7XG4gICAgICAgIGlmIChtYXhMYWJlbCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBhcmVhIHdpdGggdGhlIG1vc3QgcGF0Y2hlcyAoYmlnZ2VzdCBjb25uZWN0ZWQgYXJlYSlcbiAgICAgICAgY29uc3QgdG9wTGFiZWxzID0gZmluZEJpZ2dlc3RDb25uZWN0ZWRBcmVhcyhtYXhMYWJlbCk7XG4gICAgICAgIGlmICh0b3BMYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJveGVzID0gZmluZEJveGVzKHRvcExhYmVscywgbWF4TGFiZWwpO1xuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfSxcblxuICAgIGNoZWNrSW1hZ2VDb25zdHJhaW50cyhpbnB1dFN0cmVhbSwgY29uZmlnKSB7XG4gICAgICAgIGxldCBwYXRjaFNpemU7XG4gICAgICAgIGxldCB3aWR0aCA9IGlucHV0U3RyZWFtLmdldFdpZHRoKCk7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgdGhpc0hhbGZTYW1wbGUgPSBjb25maWcuaGFsZlNhbXBsZSA/IDAuNSA6IDE7XG4gICAgICAgIGxldCBhcmVhO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IGJhc2VkIG9uIGFyZWFcbiAgICAgICAgaWYgKGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpIHtcbiAgICAgICAgICAgIGFyZWEgPSBjb21wdXRlSW1hZ2VBcmVhKHdpZHRoLCBoZWlnaHQsIGlucHV0U3RyZWFtLmdldENvbmZpZygpLmFyZWEpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0VG9wUmlnaHQoeyB4OiBhcmVhLnN4LCB5OiBhcmVhLnN5IH0pO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc2V0Q2FudmFzU2l6ZSh7IHg6IHdpZHRoLCB5OiBoZWlnaHQgfSk7XG4gICAgICAgICAgICB3aWR0aCA9IGFyZWEuc3c7XG4gICAgICAgICAgICBoZWlnaHQgPSBhcmVhLnNoO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3Iod2lkdGggKiB0aGlzSGFsZlNhbXBsZSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGhlaWdodCAqIHRoaXNIYWxmU2FtcGxlKSxcbiAgICAgICAgfTtcblxuICAgICAgICBwYXRjaFNpemUgPSBjYWxjdWxhdGVQYXRjaFNpemUoY29uZmlnLnBhdGNoU2l6ZSwgc2l6ZSk7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXRjaC1TaXplOiAke0pTT04uc3RyaW5naWZ5KHBhdGNoU2l6ZSl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFN0cmVhbS5zZXRXaWR0aChNYXRoLmZsb29yKE1hdGguZmxvb3Ioc2l6ZS54IC8gcGF0Y2hTaXplLngpICogKDEgLyB0aGlzSGFsZlNhbXBsZSkgKiBwYXRjaFNpemUueCkpO1xuICAgICAgICBpbnB1dFN0cmVhbS5zZXRIZWlnaHQoTWF0aC5mbG9vcihNYXRoLmZsb29yKHNpemUueSAvIHBhdGNoU2l6ZS55KSAqICgxIC8gdGhpc0hhbGZTYW1wbGUpICogcGF0Y2hTaXplLnkpKTtcblxuICAgICAgICBpZiAoKGlucHV0U3RyZWFtLmdldFdpZHRoKCkgJSBwYXRjaFNpemUueCkgPT09IDAgJiYgKGlucHV0U3RyZWFtLmdldEhlaWdodCgpICUgcGF0Y2hTaXplLnkpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2UgZGltZW5zaW9ucyBkbyBub3QgY29tcGx5IHdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3M6IFdpZHRoICgke1xuICAgICAgICAgICAgd2lkdGh9IClhbmQgaGVpZ2h0ICgke2hlaWdodFxuICAgICAgICB9KSBtdXN0IGEgbXVsdGlwbGUgb2YgJHtwYXRjaFNpemUueH1gKTtcbiAgICB9LFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGV0ZXJtaW5hbnQ6IHJlcXVpcmUoJy4vZGV0ZXJtaW5hbnQnKVxuICAsIHRyYW5zcG9zZTogcmVxdWlyZSgnLi90cmFuc3Bvc2UnKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCBpZGVudGl0eTogcmVxdWlyZSgnLi9pZGVudGl0eScpXG4gICwgYWRqb2ludDogcmVxdWlyZSgnLi9hZGpvaW50JylcbiAgLCByb3RhdGU6IHJlcXVpcmUoJy4vcm90YXRlJylcbiAgLCBpbnZlcnQ6IHJlcXVpcmUoJy4vaW52ZXJ0JylcbiAgLCBjcmVhdGU6IHJlcXVpcmUoJy4vY3JlYXRlJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgY29weTogcmVxdWlyZSgnLi9jb3B5JylcbiAgLCBmcm9iOiByZXF1aXJlKCcuL2Zyb2InKVxuICAsIGxkdTogcmVxdWlyZSgnLi9sZHUnKVxufVxuIiwidmFyIGlvdGEgPSByZXF1aXJlKFwiaW90YS1hcnJheVwiKVxudmFyIGlzQnVmZmVyID0gcmVxdWlyZShcImlzLWJ1ZmZlclwiKVxuXG52YXIgaGFzVHlwZWRBcnJheXMgID0gKCh0eXBlb2YgRmxvYXQ2NEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIilcblxuZnVuY3Rpb24gY29tcGFyZTFzdChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXVxufVxuXG5mdW5jdGlvbiBvcmRlcigpIHtcbiAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlXG4gIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKVxuICB2YXIgaVxuICBmb3IoaT0wOyBpPHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdGVybXNbaV0gPSBbTWF0aC5hYnMoc3RyaWRlW2ldKSwgaV1cbiAgfVxuICB0ZXJtcy5zb3J0KGNvbXBhcmUxc3QpXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKVxuICBmb3IoaT0wOyBpPHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHRlcm1zW2ldWzFdXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICB2YXIgY2xhc3NOYW1lID0gW1wiVmlld1wiLCBkaW1lbnNpb24sIFwiZFwiLCBkdHlwZV0uam9pbihcIlwiKVxuICBpZihkaW1lbnNpb24gPCAwKSB7XG4gICAgY2xhc3NOYW1lID0gXCJWaWV3X05pbFwiICsgZHR5cGVcbiAgfVxuICB2YXIgdXNlR2V0dGVycyA9IChkdHlwZSA9PT0gXCJnZW5lcmljXCIpXG5cbiAgaWYoZGltZW5zaW9uID09PSAtMSkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciB0cml2aWFsIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEpe3RoaXMuZGF0YT1hO307XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiAtMX07XFxcbnByb3RvLnNpemU9MDtcXFxucHJvdG8uZGltZW5zaW9uPS0xO1xcXG5wcm90by5zaGFwZT1wcm90by5zdHJpZGU9cHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPVxcXG5mdW5jdGlvbigpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSk7fTtcXFxucHJvdG8uZ2V0PXByb3RvLnNldD1mdW5jdGlvbigpe307XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEpO31cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKClcbiAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciAwZCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLGQpIHtcXFxudGhpcy5kYXRhID0gYTtcXFxudGhpcy5vZmZzZXQgPSBkXFxcbn07XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9mZnNldH07XFxcbnByb3RvLmRpbWVuc2lvbj0wO1xcXG5wcm90by5zaXplPTE7XFxcbnByb3RvLnNoYXBlPVxcXG5wcm90by5zdHJpZGU9XFxcbnByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1cXFxucHJvdG8uaGk9XFxcbnByb3RvLnRyYW5zcG9zZT1cXFxucHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfY29weSgpIHtcXFxucmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KVxcXG59O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKCl7XFxcbnJldHVybiBUcml2aWFsQXJyYXkodGhpcy5kYXRhKTtcXFxufTtcXFxucHJvdG8udmFsdWVPZj1wcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldCgpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5nZXQodGhpcy5vZmZzZXQpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF1cIikrXG5cIn07XFxcbnByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KHYpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5zZXQodGhpcy5vZmZzZXQsdilcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XT12XCIpK1wiXFxcbn07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEsYixjLGQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEsZCl9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVswXSlcbiAgfVxuXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG5cbiAgLy9DcmVhdGUgY29uc3RydWN0b3IgZm9yIHZpZXdcbiAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbilcbiAgdmFyIGFyZ3MgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImlcIitpIH0pXG4gIHZhciBpbmRleF9zdHIgPSBcInRoaXMub2Zmc2V0K1wiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkgKyBcIl0qaVwiICsgaVxuICAgICAgfSkuam9pbihcIitcIilcbiAgdmFyIHNoYXBlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICBjb2RlLnB1c2goXG4gICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxcIiArIHNoYXBlQXJnICsgXCIsXCIgKyBzdHJpZGVBcmcgKyBcIixkKXt0aGlzLmRhdGE9YVwiLFxuICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMuc3RyaWRlPVtcIiArIHN0cmlkZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLm9mZnNldD1kfDB9XCIsXG4gICAgXCJ2YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZVwiLFxuICAgIFwicHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJ1wiLFxuICAgIFwicHJvdG8uZGltZW5zaW9uPVwiK2RpbWVuc2lvbilcblxuICAvL3ZpZXcuc2l6ZTpcbiAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdzaXplJyx7Z2V0OmZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zaXplKCl7XFxcbnJldHVybiBcIitpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcInRoaXMuc2hhcGVbXCIraStcIl1cIiB9KS5qb2luKFwiKlwiKSxcblwifX0pXCIpXG5cbiAgLy92aWV3Lm9yZGVyOlxuICBpZihkaW1lbnNpb24gPT09IDEpIHtcbiAgICBjb2RlLnB1c2goXCJwcm90by5vcmRlcj1bMF1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ29yZGVyJyx7Z2V0OlwiKVxuICAgIGlmKGRpbWVuc2lvbiA8IDQpIHtcbiAgICAgIGNvZGUucHVzaChcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9vcmRlcigpe1wiKVxuICAgICAgaWYoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiAoTWF0aC5hYnModGhpcy5zdHJpZGVbMF0pPk1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSk/WzEsMF06WzAsMV19fSlcIilcbiAgICAgIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDMpIHtcbiAgICAgICAgY29kZS5wdXNoKFxuXCJ2YXIgczA9TWF0aC5hYnModGhpcy5zdHJpZGVbMF0pLHMxPU1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSxzMj1NYXRoLmFicyh0aGlzLnN0cmlkZVsyXSk7XFxcbmlmKHMwPnMxKXtcXFxuaWYoczE+czIpe1xcXG5yZXR1cm4gWzIsMSwwXTtcXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzEsMiwwXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMSwwLDJdO1xcXG59XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsyLDAsMV07XFxcbn1lbHNlIGlmKHMyPnMxKXtcXFxucmV0dXJuIFswLDEsMl07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzAsMiwxXTtcXFxufX19KVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLnB1c2goXCJPUkRFUn0pXCIpXG4gICAgfVxuICB9XG5cbiAgLy92aWV3LnNldChpMCwgLi4uLCB2KTpcbiAgY29kZS5wdXNoKFxuXCJwcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldChcIithcmdzLmpvaW4oXCIsXCIpK1wiLHYpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5zZXQoXCIraW5kZXhfc3RyK1wiLHYpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXT12fVwiKVxuICB9XG5cbiAgLy92aWV3LmdldChpMCwgLi4uKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLmdldChcIitpbmRleF9zdHIrXCIpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXX1cIilcbiAgfVxuXG4gIC8vdmlldy5pbmRleDpcbiAgY29kZS5wdXNoKFxuICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2luZGV4KFwiLCBhcmdzLmpvaW4oKSwgXCIpe3JldHVybiBcIitpbmRleF9zdHIrXCJ9XCIpXG5cbiAgLy92aWV3LmhpKCk6XG4gIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9oaShcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFtcIih0eXBlb2YgaVwiLGksXCIhPT0nbnVtYmVyJ3x8aVwiLGksXCI8MCk/dGhpcy5zaGFwZVtcIiwgaSwgXCJdOmlcIiwgaSxcInwwXCJdLmpvaW4oXCJcIilcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIitpICsgXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LmxvKCk6XG4gIHZhciBhX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIiB9KVxuICB2YXIgY192YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJjXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiIH0pXG4gIGNvZGUucHVzaChcInByb3RvLmxvPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9sbyhcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIrYV92YXJzLmpvaW4oXCIsXCIpK1wiLFwiK2NfdmFycy5qb2luKFwiLFwiKSlcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuYis9Y1wiK2krXCIqZDtcXFxuYVwiK2krXCItPWR9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixiKX1cIilcblxuICAvL3ZpZXcuc3RlcCgpOlxuICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zdGVwKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInKXtcXFxuZD1pXCIraStcInwwO1xcXG5pZihkPDApe1xcXG5jKz1iXCIraStcIiooYVwiK2krXCItMSk7XFxcbmFcIitpK1wiPWNlaWwoLWFcIitpK1wiL2QpXFxcbn1lbHNle1xcXG5hXCIraStcIj1jZWlsKGFcIitpK1wiL2QpXFxcbn1cXFxuYlwiK2krXCIqPWRcXFxufVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGMpfVwiKVxuXG4gIC8vdmlldy50cmFuc3Bvc2UoKTpcbiAgdmFyIHRTaGFwZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB0U2hhcGVbaV0gPSBcImFbaVwiK2krXCJdXCJcbiAgICB0U3RyaWRlW2ldID0gXCJiW2lcIitpK1wiXVwiXG4gIH1cbiAgY29kZS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl90cmFuc3Bvc2UoXCIrYXJncytcIil7XCIrXG4gICAgYXJncy5tYXAoZnVuY3Rpb24obixpZHgpIHsgcmV0dXJuIG4gKyBcIj0oXCIgKyBuICsgXCI9PT11bmRlZmluZWQ/XCIgKyBpZHggKyBcIjpcIiArIG4gKyBcInwwKVwifSkuam9pbihcIjtcIiksXG4gICAgXCJ2YXIgYT10aGlzLnNoYXBlLGI9dGhpcy5zdHJpZGU7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK3RTaGFwZS5qb2luKFwiLFwiKStcIixcIit0U3RyaWRlLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcucGljaygpOlxuICBjb2RlLnB1c2goXCJwcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKFwiK2FyZ3MrXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7Yz0oYyt0aGlzLnN0cmlkZVtcIitpK1wiXSppXCIraStcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiK2krXCJdKTtiLnB1c2godGhpcy5zdHJpZGVbXCIraStcIl0pfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInZhciBjdG9yPUNUT1JfTElTVFthLmxlbmd0aCsxXTtyZXR1cm4gY3Rvcih0aGlzLmRhdGEsYSxiLGMpfVwiKVxuXG4gIC8vQWRkIHJldHVybiBzdGF0ZW1lbnRcbiAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoZGF0YSxzaGFwZSxzdHJpZGUsb2Zmc2V0KXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihkYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpXG5cbiAgLy9Db21waWxlIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdLCBvcmRlcilcbn1cblxuZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gIGlmKGlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYnVmZmVyXCJcbiAgfVxuICBpZihoYXNUeXBlZEFycmF5cykge1xuICAgIHN3aXRjaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhfY2xhbXBlZFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBCaWdJbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWdpbnQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBCaWdVaW50NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiYmlndWludDY0XCJcbiAgICB9XG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCJcbiAgfVxuICByZXR1cm4gXCJnZW5lcmljXCJcbn1cblxudmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gIFwiZmxvYXQzMlwiOltdLFxuICBcImZsb2F0NjRcIjpbXSxcbiAgXCJpbnQ4XCI6W10sXG4gIFwiaW50MTZcIjpbXSxcbiAgXCJpbnQzMlwiOltdLFxuICBcInVpbnQ4XCI6W10sXG4gIFwidWludDE2XCI6W10sXG4gIFwidWludDMyXCI6W10sXG4gIFwiYXJyYXlcIjpbXSxcbiAgXCJ1aW50OF9jbGFtcGVkXCI6W10sXG4gIFwiYmlnaW50NjRcIjogW10sXG4gIFwiYmlndWludDY0XCI6IFtdLFxuICBcImJ1ZmZlclwiOltdLFxuICBcImdlbmVyaWNcIjpbXVxufVxuXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIENBQ0hFRF9DT05TVFJVQ1RPUlMpIHtcbiAgICBDQUNIRURfQ09OU1RSVUNUT1JTW2lkXS5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihpZCwgLTEpKVxuICB9XG59KTtcblxuZnVuY3Rpb24gd3JhcHBlZE5EQXJyYXlDdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldCkge1xuICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3RvciA9IENBQ0hFRF9DT05TVFJVQ1RPUlMuYXJyYXlbMF1cbiAgICByZXR1cm4gY3RvcihbXSlcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YSA9IFtkYXRhXVxuICB9XG4gIGlmKHNoYXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaGFwZSA9IFsgZGF0YS5sZW5ndGggXVxuICB9XG4gIHZhciBkID0gc2hhcGUubGVuZ3RoXG4gIGlmKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWRlID0gbmV3IEFycmF5KGQpXG4gICAgZm9yKHZhciBpPWQtMSwgc3o9MTsgaT49MDsgLS1pKSB7XG4gICAgICBzdHJpZGVbaV0gPSBzelxuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH1cbiAgaWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihzdHJpZGVbaV0gPCAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0tMSkqc3RyaWRlW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSlcbiAgdmFyIGN0b3JfbGlzdCA9IENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdXG4gIHdoaWxlKGN0b3JfbGlzdC5sZW5ndGggPD0gZCsxKSB7XG4gICAgY3Rvcl9saXN0LnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBjdG9yX2xpc3QubGVuZ3RoLTEpKVxuICB9XG4gIHZhciBjdG9yID0gY3Rvcl9saXN0W2QrMV1cbiAgcmV0dXJuIGN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvclxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdFxuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGVcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXVxuICAgIHJldHVybiB4KnggKyB5Knlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV1cbiAgICByZXR1cm4geCp4ICsgeSp5XG59IiwibW9kdWxlLmV4cG9ydHMgPSAwLjAwMDAwMVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVZhbHVlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnpcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkaXZpZGU7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbmZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiY29uc3QgQ1ZVdGlscyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9jdl91dGlscycpO1xuY29uc3QgTmRhcnJheSA9IHJlcXVpcmUoJ25kYXJyYXknKTtcbmNvbnN0IEludGVycDJEID0gcmVxdWlyZSgnbmRhcnJheS1saW5lYXItaW50ZXJwb2xhdGUnKS5kMjtcblxuY29uc3QgRnJhbWVHcmFiYmVyID0ge307XG5cbkZyYW1lR3JhYmJlci5jcmVhdGUgPSBmdW5jdGlvbiAoaW5wdXRTdHJlYW0pIHtcbiAgICBjb25zdCBfdGhhdCA9IHt9O1xuICAgIGNvbnN0IF92aWRlb1NpemUgPSBDVlV0aWxzLmltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xuICAgIGNvbnN0IF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICAgIGNvbnN0IF9zaXplID0gQ1ZVdGlscy5pbWFnZVJlZihpbnB1dFN0cmVhbS5nZXRXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSk7XG4gICAgY29uc3QgX3RvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICBsZXQgX2RhdGEgPSBuZXcgVWludDhBcnJheShfc2l6ZS54ICogX3NpemUueSk7XG4gICAgY29uc3QgX2dyYXlEYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3ZpZGVvU2l6ZS54ICogX3ZpZGVvU2l6ZS55KTtcbiAgICBjb25zdCBfY2FudmFzRGF0YSA9IG5ldyBVaW50OEFycmF5KF9jYW52YXNTaXplLnggKiBfY2FudmFzU2l6ZS55KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG4gICAgY29uc3QgX2dyYXlJbWFnZUFycmF5ID0gTmRhcnJheShfZ3JheURhdGEsIFtfdmlkZW9TaXplLnksIF92aWRlb1NpemUueF0pLnRyYW5zcG9zZSgxLCAwKTtcbiAgICBjb25zdCBfY2FudmFzSW1hZ2VBcnJheSA9IE5kYXJyYXkoX2NhbnZhc0RhdGEsIFtfY2FudmFzU2l6ZS55LCBfY2FudmFzU2l6ZS54XSkudHJhbnNwb3NlKDEsIDApO1xuICAgIGNvbnN0IF90YXJnZXRJbWFnZUFycmF5ID0gX2NhbnZhc0ltYWdlQXJyYXlcbiAgICAgICAgLmhpKF90b3BSaWdodC54ICsgX3NpemUueCwgX3RvcFJpZ2h0LnkgKyBfc2l6ZS55KVxuICAgICAgICAubG8oX3RvcFJpZ2h0LngsIF90b3BSaWdodC55KTtcbiAgICBjb25zdCBfc3RlcFNpemVYID0gX3ZpZGVvU2l6ZS54IC8gX2NhbnZhc1NpemUueDtcbiAgICBjb25zdCBfc3RlcFNpemVZID0gX3ZpZGVvU2l6ZS55IC8gX2NhbnZhc1NpemUueTtcblxuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHZpZGVvU2l6ZTogX2dyYXlJbWFnZUFycmF5LnNoYXBlLFxuICAgICAgICAgICAgY2FudmFzU2l6ZTogX2NhbnZhc0ltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICBzdGVwU2l6ZTogW19zdGVwU2l6ZVgsIF9zdGVwU2l6ZVldLFxuICAgICAgICAgICAgc2l6ZTogX3RhcmdldEltYWdlQXJyYXkuc2hhcGUsXG4gICAgICAgICAgICB0b3BSaWdodDogX3RvcFJpZ2h0LFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlcyB0aGUgZ2l2ZW4gYXJyYXkgYXMgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuYXR0YWNoRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXNlZCBmcmFtZS1idWZmZXJcbiAgICAgKi9cbiAgICBfdGhhdC5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2RhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBmcmFtZSBmcm9tIHRoZSBpbnB1dC1zdHJlYW0gYW5kIHB1dHMgaW50byB0aGUgZnJhbWUtYnVmZmVyLlxuICAgICAqIFRoZSBpbWFnZS1kYXRhIGlzIGNvbnZlcnRlZCB0byBncmF5LXNjYWxlIGFuZCB0aGVuIGhhbGYtc2FtcGxlZCBpZiBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIF90aGF0LmdyYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcblxuICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVBbmRDcm9wKGZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgX3RoYXQuc2NhbGVBbmRDcm9wID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgLy8gMS4gY29tcHV0ZSBmdWxsLXNpemVkIGdyYXkgaW1hZ2VcbiAgICAgICAgQ1ZVdGlscy5jb21wdXRlR3JheShmcmFtZS5kYXRhLCBfZ3JheURhdGEpO1xuXG4gICAgICAgIC8vIDIuIGludGVycG9sYXRlXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX2NhbnZhc1NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9jYW52YXNTaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgICAgICAgICAgX2NhbnZhc0ltYWdlQXJyYXkuc2V0KHgsIHksIChJbnRlcnAyRChfZ3JheUltYWdlQXJyYXksIHggKiBfc3RlcFNpemVYLCB5ICogX3N0ZXBTaXplWSkpIHwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0YXJnZXRJbWFnZUFycmF5IG11c3QgYmUgZXF1YWwgdG8gdGFyZ2V0U2l6ZVxuICAgICAgICBpZiAoX3RhcmdldEltYWdlQXJyYXkuc2hhcGVbMF0gIT09IF9zaXplLnhcbiAgICAgICAgICAgIHx8IF90YXJnZXRJbWFnZUFycmF5LnNoYXBlWzFdICE9PSBfc2l6ZS55KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYXBlcyBkbyBub3QgbWF0Y2ghJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBjcm9wXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgX3NpemUueTsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IF9zaXplLng7IHgrKykge1xuICAgICAgICAgICAgICAgIF9kYXRhW3kgKiBfc2l6ZS54ICsgeF0gPSBfdGFyZ2V0SW1hZ2VBcnJheS5nZXQoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZyYW1lR3JhYmJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBFUFNJTE9OOiByZXF1aXJlKCcuL2Vwc2lsb24nKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBhbmdsZTogcmVxdWlyZSgnLi9hbmdsZScpXG4gICwgZnJvbVZhbHVlczogcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIHNldDogcmVxdWlyZSgnLi9zZXQnKVxuICAsIGVxdWFsczogcmVxdWlyZSgnLi9lcXVhbHMnKVxuICAsIGV4YWN0RXF1YWxzOiByZXF1aXJlKCcuL2V4YWN0RXF1YWxzJylcbiAgLCBhZGQ6IHJlcXVpcmUoJy4vYWRkJylcbiAgLCBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4gICwgc3ViOiByZXF1aXJlKCcuL3N1YicpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIG11bDogcmVxdWlyZSgnLi9tdWwnKVxuICAsIGRpdmlkZTogcmVxdWlyZSgnLi9kaXZpZGUnKVxuICAsIGRpdjogcmVxdWlyZSgnLi9kaXYnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG5vcm1hbGl6ZTogcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxuICAsIGRvdDogcmVxdWlyZSgnLi9kb3QnKVxuICAsIGNyb3NzOiByZXF1aXJlKCcuL2Nyb3NzJylcbiAgLCBsZXJwOiByZXF1aXJlKCcuL2xlcnAnKVxuICAsIHJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgdHJhbnNmb3JtTWF0MzogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQzJylcbiAgLCB0cmFuc2Zvcm1RdWF0OiByZXF1aXJlKCcuL3RyYW5zZm9ybVF1YXQnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZvckVhY2g6IHJlcXVpcmUoJy4vZm9yRWFjaCcpXG59XG4iLCJpbXBvcnQgVHJhY2VyIGZyb20gJy4vdHJhY2VyJztcblxuLyoqXG4gKiBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9UaXBzLzQwNzE3Mi9Db25uZWN0ZWQtQ29tcG9uZW50LUxhYmVsaW5nLWFuZC1WZWN0b3JpemF0aW9uXG4gKi9cbmNvbnN0IFJhc3Rlcml6ZXIgPSB7XG4gICAgY3JlYXRlQ29udG91cjJEKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlyOiBudWxsLFxuICAgICAgICAgICAgaW5kZXg6IG51bGwsXG4gICAgICAgICAgICBmaXJzdFZlcnRleDogbnVsbCxcbiAgICAgICAgICAgIGluc2lkZUNvbnRvdXJzOiBudWxsLFxuICAgICAgICAgICAgbmV4dHBlZXI6IG51bGwsXG4gICAgICAgICAgICBwcmV2cGVlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIENPTlRPVVJfRElSOiB7XG4gICAgICAgIENXX0RJUjogMCxcbiAgICAgICAgQ0NXX0RJUjogMSxcbiAgICAgICAgVU5LTk9XTl9ESVI6IDIsXG4gICAgfSxcbiAgICBESVI6IHtcbiAgICAgICAgT1VUU0lERV9FREdFOiAtMzI3NjcsXG4gICAgICAgIElOU0lERV9FREdFOiAtMzI3NjYsXG4gICAgfSxcbiAgICBjcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpIHtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsRGF0YSA9IGxhYmVsV3JhcHBlci5kYXRhO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGltYWdlV3JhcHBlci5zaXplLng7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlV3JhcHBlci5zaXplLnk7XG4gICAgICAgIGNvbnN0IHRyYWNlciA9IFRyYWNlci5jcmVhdGUoaW1hZ2VXcmFwcGVyLCBsYWJlbFdyYXBwZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXN0ZXJpemUoZGVwdGhsYWJlbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb2xvcjtcbiAgICAgICAgICAgICAgICBsZXQgYmM7XG4gICAgICAgICAgICAgICAgbGV0IGxjO1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbGluZGV4O1xuICAgICAgICAgICAgICAgIGxldCBjeDtcbiAgICAgICAgICAgICAgICBsZXQgY3k7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JNYXAgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgdmVydGV4O1xuICAgICAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgICAgIGxldCBjYztcbiAgICAgICAgICAgICAgICBsZXQgc2M7XG4gICAgICAgICAgICAgICAgbGV0IHBvcztcbiAgICAgICAgICAgICAgICBsZXQgY29ubmVjdGVkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQwMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yTWFwW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb2xvck1hcFswXSA9IGltYWdlRGF0YVswXTtcbiAgICAgICAgICAgICAgICBjYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9yIChjeSA9IDE7IGN5IDwgaGVpZ2h0IC0gMTsgY3krKykge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFswXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjeCA9IDE7IGN4IDwgd2lkdGggLSAxOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBjeSAqIHdpZHRoICsgY3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWxEYXRhW3Bvc10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xvciAhPT0gYmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxjID0gY29ubmVjdGVkQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JNYXBbbGNdID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgbGMsIGNvbG9yLCBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IGxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBSYXN0ZXJpemVyLmNyZWF0ZUNvbnRvdXIyRCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbmRleCA9IGxhYmVsaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5maXJzdFZlcnRleCA9IHZlcnRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLm5leHRwZWVyID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5pbnNpZGVDb250b3VycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLnByZXZwZWVyID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4ID0gdHJhY2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbnRvdXJUcmFjaW5nKGN5LCBjeCwgUmFzdGVyaXplci5ESVIuSU5TSURFX0VER0UsIGNvbG9yLCBsYWJlbGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gUmFzdGVyaXplci5jcmVhdGVDb250b3VyMkQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmZpcnN0VmVydGV4ID0gdmVydGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5zaWRlQ29udG91cnMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aGxhYmVsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DQ1dfRElSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuZGlyID0gUmFzdGVyaXplci5DT05UT1VSX0RJUi5DV19ESVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuaW5kZXggPSBkZXB0aGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gY2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChzYyAhPT0gbnVsbCkgJiYgc2MuaW5kZXggIT09IGxhYmVsaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MgPSBzYy5uZXh0cGVlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAubmV4dHBlZXIgPSBzYy5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjLmluc2lkZUNvbnRvdXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYy5pbnNpZGVDb250b3Vycy5wcmV2cGVlciA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2MuaW5zaWRlQ29udG91cnMgPSBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsRGF0YVtwb3NdID0gbGFiZWxpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5PVVRTSURFX0VER0VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgbGFiZWxEYXRhW3Bvc10gPT09IFJhc3Rlcml6ZXIuRElSLklOU0lERV9FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsRGF0YVtwb3NdID09PSBSYXN0ZXJpemVyLkRJUi5JTlNJREVfRURHRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYyA9IGltYWdlRGF0YVtwb3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJjID0gY29sb3JNYXBbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbGluZGV4ID0gbGFiZWxEYXRhW3Bvc107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmMgPSBjb2xvck1hcFtsYWJlbGluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzYyA9IGNjO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzYyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYy5pbmRleCA9IGRlcHRobGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIHNjID0gc2MubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNjLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY29ubmVjdGVkQ291bnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJ1Zzoge1xuICAgICAgICAgICAgICAgIGRyYXdDb250b3VyKGNhbnZhcywgZmlyc3RDb250b3VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHEgPSBmaXJzdENvbnRvdXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpcTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHE7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwO1xuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXEgPSBwcS5pbnNpZGVDb250b3VycztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcSA9IGlxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gaXEubmV4dHBlZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBwcTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcSA9IHBxLm5leHRwZWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcSA9IHBxLmluc2lkZUNvbnRvdXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlxID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocS5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJhc3Rlcml6ZXIuQ09OVE9VUl9ESVIuQ1dfRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLkNDV19ESVI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXN0ZXJpemVyLkNPTlRPVVJfRElSLlVOS05PV05fRElSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHEuZmlyc3RWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocC54LCBwLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocCAhPT0gcS5maXJzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUmFzdGVyaXplcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblxuLyogQHByZXNlcnZlIEFTTSBCRUdJTiAqL1xuZnVuY3Rpb24gU2tlbGV0b25pemVyKHN0ZGxpYiwgZm9yZWlnbiwgYnVmZmVyKSB7XG4gICAgJ3VzZSBhc20nO1xuXG4gICAgY29uc3QgaW1hZ2VzID0gbmV3IHN0ZGxpYi5VaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3Qgc2l6ZSA9IGZvcmVpZ24uc2l6ZSB8IDA7XG4gICAgY29uc3QgeyBpbXVsIH0gPSBzdGRsaWIuTWF0aDtcblxuICAgIGZ1bmN0aW9uIGVyb2RlKGluSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGluSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgdiA9IDA7XG4gICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQxID0gMDtcbiAgICAgICAgbGV0IHlTdGFydDIgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB4U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG5cbiAgICAgICAgZm9yICh2ID0gMTsgKHYgfCAwKSA8ICgoc2l6ZSAtIDEpIHwgMCk7IHYgPSAodiArIDEpIHwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgIGZvciAodSA9IDE7ICh1IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB1ID0gKHUgKyAxKSB8IDApIHtcbiAgICAgICAgICAgICAgICB5U3RhcnQxID0gKG9mZnNldCAtIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB5U3RhcnQyID0gKG9mZnNldCArIHNpemUpIHwgMDtcbiAgICAgICAgICAgICAgICB4U3RhcnQxID0gKHUgLSAxKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MiA9ICh1ICsgMSkgfCAwO1xuICAgICAgICAgICAgICAgIHN1bSA9ICgoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQxICsgeFN0YXJ0MikgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MSkgfCAwXSB8IDApXG4gICAgICAgICAgICAgICAgICAgICsgKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDIgKyB4U3RhcnQyKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgICAgICAgICBpZiAoKHN1bSB8IDApID09ICg1IHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhSW1hZ2VQdHIsIGJJbWFnZVB0ciwgb3V0SW1hZ2VQdHIpIHtcbiAgICAgICAgYUltYWdlUHRyIHw9IDA7XG4gICAgICAgIGJJbWFnZVB0ciB8PSAwO1xuICAgICAgICBvdXRJbWFnZVB0ciB8PSAwO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSA9ICgoaW1hZ2VzWyhhSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSAtIChpbWFnZXNbKGJJbWFnZVB0ciArIGxlbmd0aCkgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaXR3aXNlT3IoYUltYWdlUHRyLCBiSW1hZ2VQdHIsIG91dEltYWdlUHRyKSB7XG4gICAgICAgIGFJbWFnZVB0ciB8PSAwO1xuICAgICAgICBiSW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgb3V0SW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSAoKGltYWdlc1soYUltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkgfCAoaW1hZ2VzWyhiSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY291bnROb25aZXJvKGltYWdlUHRyKSB7XG4gICAgICAgIGltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICAgIGxlbmd0aCA9IGltdWwoc2l6ZSwgc2l6ZSkgfCAwO1xuXG4gICAgICAgIHdoaWxlICgobGVuZ3RoIHwgMCkgPiAwKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIC0gMSkgfCAwO1xuICAgICAgICAgICAgc3VtID0gKChzdW0gfCAwKSArIChpbWFnZXNbKGltYWdlUHRyICsgbGVuZ3RoKSB8IDBdIHwgMCkpIHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoc3VtIHwgMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdChpbWFnZVB0ciwgdmFsdWUpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcbiAgICAgICAgdmFsdWUgfD0gMDtcblxuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBsZW5ndGggPSBpbXVsKHNpemUsIHNpemUpIHwgMDtcblxuICAgICAgICB3aGlsZSAoKGxlbmd0aCB8IDApID4gMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCAtIDEpIHwgMDtcbiAgICAgICAgICAgIGltYWdlc1soaW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbGF0ZShpbkltYWdlUHRyLCBvdXRJbWFnZVB0cikge1xuICAgICAgICBpbkltYWdlUHRyIHw9IDA7XG4gICAgICAgIG91dEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IHYgPSAwO1xuICAgICAgICBsZXQgdSA9IDA7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgeVN0YXJ0MSA9IDA7XG4gICAgICAgIGxldCB5U3RhcnQyID0gMDtcbiAgICAgICAgbGV0IHhTdGFydDEgPSAwO1xuICAgICAgICBsZXQgeFN0YXJ0MiA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgICAgIGZvciAodiA9IDE7ICh2IHwgMCkgPCAoKHNpemUgLSAxKSB8IDApOyB2ID0gKHYgKyAxKSB8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICBmb3IgKHUgPSAxOyAodSB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgdSA9ICh1ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MSA9IChvZmZzZXQgLSBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeVN0YXJ0MiA9IChvZmZzZXQgKyBzaXplKSB8IDA7XG4gICAgICAgICAgICAgICAgeFN0YXJ0MSA9ICh1IC0gMSkgfCAwO1xuICAgICAgICAgICAgICAgIHhTdGFydDIgPSAodSArIDEpIHwgMDtcbiAgICAgICAgICAgICAgICBzdW0gPSAoKGltYWdlc1soaW5JbWFnZVB0ciArIHlTdGFydDEgKyB4U3RhcnQxKSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MSArIHhTdGFydDIpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdIHwgMClcbiAgICAgICAgICAgICAgICAgICAgKyAoaW1hZ2VzWyhpbkltYWdlUHRyICsgeVN0YXJ0MiArIHhTdGFydDEpIHwgMF0gfCAwKVxuICAgICAgICAgICAgICAgICAgICArIChpbWFnZXNbKGluSW1hZ2VQdHIgKyB5U3RhcnQyICsgeFN0YXJ0MikgfCAwXSB8IDApKSB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKChzdW0gfCAwKSA+ICgwIHwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzWyhvdXRJbWFnZVB0ciArIG9mZnNldCArIHUpIHwgMF0gPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlc1sob3V0SW1hZ2VQdHIgKyBvZmZzZXQgKyB1KSB8IDBdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZW1jcHkoc3JjSW1hZ2VQdHIsIGRzdEltYWdlUHRyKSB7XG4gICAgICAgIHNyY0ltYWdlUHRyIHw9IDA7XG4gICAgICAgIGRzdEltYWdlUHRyIHw9IDA7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgICAgbGVuZ3RoID0gaW11bChzaXplLCBzaXplKSB8IDA7XG5cbiAgICAgICAgd2hpbGUgKChsZW5ndGggfCAwKSA+IDApIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGRzdEltYWdlUHRyICsgbGVuZ3RoKSB8IDBdID0gKGltYWdlc1soc3JjSW1hZ2VQdHIgKyBsZW5ndGgpIHwgMF0gfCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9Cb3JkZXIoaW1hZ2VQdHIpIHtcbiAgICAgICAgaW1hZ2VQdHIgfD0gMDtcblxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB5ID0gMDtcblxuICAgICAgICBmb3IgKHggPSAwOyAoeCB8IDApIDwgKChzaXplIC0gMSkgfCAwKTsgeCA9ICh4ICsgMSkgfCAwKSB7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeCkgfCAwXSA9IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKCh5ICsgc2l6ZSkgLSAxKSB8IDA7XG4gICAgICAgICAgICBpbWFnZXNbKGltYWdlUHRyICsgeSkgfCAwXSA9IDA7XG4gICAgICAgICAgICB5ID0gKHkgKyAxKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh4ID0gMDsgKHggfCAwKSA8IChzaXplIHwgMCk7IHggPSAoeCArIDEpIHwgMCkge1xuICAgICAgICAgICAgaW1hZ2VzWyhpbWFnZVB0ciArIHkpIHwgMF0gPSAwO1xuICAgICAgICAgICAgeSA9ICh5ICsgMSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2tlbGV0b25pemUoKSB7XG4gICAgICAgIGNvbnN0IHN1YkltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IGVyb2RlZEltYWdlUHRyID0gMDtcbiAgICAgICAgbGV0IHRlbXBJbWFnZVB0ciA9IDA7XG4gICAgICAgIGxldCBza2VsSW1hZ2VQdHIgPSAwO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSAwO1xuXG4gICAgICAgIGVyb2RlZEltYWdlUHRyID0gaW11bChzaXplLCBzaXplKSB8IDA7XG4gICAgICAgIHRlbXBJbWFnZVB0ciA9IChlcm9kZWRJbWFnZVB0ciArIGVyb2RlZEltYWdlUHRyKSB8IDA7XG4gICAgICAgIHNrZWxJbWFnZVB0ciA9ICh0ZW1wSW1hZ2VQdHIgKyBlcm9kZWRJbWFnZVB0cikgfCAwO1xuXG4gICAgICAgIC8vIGluaXQgc2tlbC1pbWFnZVxuICAgICAgICBpbml0KHNrZWxJbWFnZVB0ciwgMCk7XG4gICAgICAgIHplcm9Cb3JkZXIoc3ViSW1hZ2VQdHIpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGVyb2RlKHN1YkltYWdlUHRyLCBlcm9kZWRJbWFnZVB0cik7XG4gICAgICAgICAgICBkaWxhdGUoZXJvZGVkSW1hZ2VQdHIsIHRlbXBJbWFnZVB0cik7XG4gICAgICAgICAgICBzdWJ0cmFjdChzdWJJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCB0ZW1wSW1hZ2VQdHIpO1xuICAgICAgICAgICAgYml0d2lzZU9yKHNrZWxJbWFnZVB0ciwgdGVtcEltYWdlUHRyLCBza2VsSW1hZ2VQdHIpO1xuICAgICAgICAgICAgbWVtY3B5KGVyb2RlZEltYWdlUHRyLCBzdWJJbWFnZVB0cik7XG4gICAgICAgICAgICBzdW0gPSBjb3VudE5vblplcm8oc3ViSW1hZ2VQdHIpIHwgMDtcbiAgICAgICAgICAgIGRvbmUgPSAoKHN1bSB8IDApID09IDAgfCAwKTtcbiAgICAgICAgfSB3aGlsZSAoIWRvbmUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBza2VsZXRvbml6ZSxcbiAgICB9O1xufVxuLyogQHByZXNlcnZlIEFTTSBFTkQgKi9cbmV4cG9ydCBkZWZhdWx0IFNrZWxldG9uaXplcjtcbi8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHBhdGggICAgICAgICAgPSByZXF1aXJlKCdwYXRoJylcbnZhciBuZGFycmF5ICAgICAgID0gcmVxdWlyZSgnbmRhcnJheScpXG52YXIgR2lmUmVhZGVyICAgICA9IHJlcXVpcmUoJ29tZ2dpZicpLkdpZlJlYWRlclxudmFyIHBhY2sgICAgICAgICAgPSByZXF1aXJlKCduZGFycmF5LXBhY2snKVxudmFyIHRocm91Z2ggICAgICAgPSByZXF1aXJlKCd0aHJvdWdoJylcbnZhciBwYXJzZURhdGFVUkkgID0gcmVxdWlyZSgnZGF0YS11cmktdG8tYnVmZmVyJylcblxuZnVuY3Rpb24gZGVmYXVsdEltYWdlKHVybCwgY2IpIHtcbiAgdmFyIGltZyA9IG5ldyBJbWFnZSgpXG4gIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCJcbiAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgIGNhbnZhcy53aWR0aCA9IGltZy53aWR0aFxuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcbiAgICB2YXIgcGl4ZWxzID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KVxuICAgIGNiKG51bGwsIG5kYXJyYXkobmV3IFVpbnQ4QXJyYXkocGl4ZWxzLmRhdGEpLCBbaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCA0XSwgWzQsIDQqaW1nLndpZHRoLCAxXSwgMCkpXG4gIH1cbiAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBjYihlcnIpXG4gIH1cbiAgaW1nLnNyYyA9IHVybFxufVxuXG4vL0FuaW1hdGVkIGdpZiBsb2FkaW5nXG5mdW5jdGlvbiBoYW5kbGVHaWYoZGF0YSwgY2IpIHtcbiAgdmFyIHJlYWRlclxuICB0cnkge1xuICAgIHJlYWRlciA9IG5ldyBHaWZSZWFkZXIoZGF0YSlcbiAgfSBjYXRjaChlcnIpIHtcbiAgICBjYihlcnIpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYocmVhZGVyLm51bUZyYW1lcygpID4gMCkge1xuICAgIHZhciBuc2hhcGUgPSBbcmVhZGVyLm51bUZyYW1lcygpLCByZWFkZXIuaGVpZ2h0LCByZWFkZXIud2lkdGgsIDRdXG4gICAgdmFyIG5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobnNoYXBlWzBdICogbnNoYXBlWzFdICogbnNoYXBlWzJdICogbnNoYXBlWzNdKVxuICAgIHZhciByZXN1bHQgPSBuZGFycmF5KG5kYXRhLCBuc2hhcGUpXG4gICAgdHJ5IHtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHJlYWRlci5udW1GcmFtZXMoKTsgKytpKSB7XG4gICAgICAgIHJlYWRlci5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKGksIG5kYXRhLnN1YmFycmF5KFxuICAgICAgICAgIHJlc3VsdC5pbmRleChpLCAwLCAwLCAwKSxcbiAgICAgICAgICByZXN1bHQuaW5kZXgoaSsxLCAwLCAwLCAwKSkpXG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYihudWxsLCByZXN1bHQudHJhbnNwb3NlKDAsMiwxKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgbnNoYXBlID0gW3JlYWRlci5oZWlnaHQsIHJlYWRlci53aWR0aCwgNF1cbiAgICB2YXIgbmRhdGEgPSBuZXcgVWludDhBcnJheShuc2hhcGVbMF0gKiBuc2hhcGVbMV0gKiBuc2hhcGVbMl0pXG4gICAgdmFyIHJlc3VsdCA9IG5kYXJyYXkobmRhdGEsIG5zaGFwZSlcbiAgICB0cnkge1xuICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoMCwgbmRhdGEpXG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYihudWxsLCByZXN1bHQudHJhbnNwb3NlKDEsMCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gaHR0cEdpZih1cmwsIGNiKSB7XG4gIHZhciB4aHIgICAgICAgICAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICB4aHIub3BlbignR0VUJywgdXJsLCB0cnVlKVxuICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICBpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSl7XG4gICAgeGhyLm92ZXJyaWRlTWltZVR5cGUoJ2FwcGxpY2F0aW9uL2JpbmFyeScpXG4gIH1cbiAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBjYihlcnIpXG4gIH1cbiAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpXG4gICAgaGFuZGxlR2lmKGRhdGEsIGNiKVxuICAgIHJldHVyblxuICB9XG4gIHhoci5zZW5kKClcbn1cblxuZnVuY3Rpb24gY29weUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoYnVmZmVyWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGhcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGJ1ZmZlci5nZXQoaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0YUdpZih1cmwsIGNiKSB7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBidWZmZXIgPSBwYXJzZURhdGFVUkkodXJsKVxuICAgICAgaWYoYnVmZmVyKSB7XG4gICAgICAgIGhhbmRsZUdpZihjb3B5QnVmZmVyKGJ1ZmZlciksIGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobmV3IEVycm9yKCdFcnJvciBwYXJzaW5nIGRhdGEgVVJJJykpXG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNiKGVycilcbiAgICB9XG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UGl4ZWxzKHVybCwgdHlwZSwgY2IpIHtcbiAgaWYoIWNiKSB7XG4gICAgY2IgPSB0eXBlXG4gICAgdHlwZSA9ICcnXG4gIH1cbiAgdmFyIGV4dCA9IHBhdGguZXh0bmFtZSh1cmwpXG4gIHN3aXRjaCh0eXBlIHx8IGV4dC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnLkdJRic6XG4gICAgICBodHRwR2lmKHVybCwgY2IpXG4gICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYoQnVmZmVyLmlzQnVmZmVyKHVybCkpIHtcbiAgICAgICAgdXJsID0gJ2RhdGE6JyArIHR5cGUgKyAnO2Jhc2U2NCwnICsgdXJsLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgfVxuICAgICAgaWYodXJsLmluZGV4T2YoJ2RhdGE6aW1hZ2UvZ2lmOycpID09PSAwKSB7XG4gICAgICAgIGRhdGFHaWYodXJsLCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRJbWFnZSh1cmwsIGNiKVxuICAgICAgfVxuICB9XG59IiwiLypcbiAqIHR5cGVkZWZzLmpzXG4gKiBOb3JtYWxpemVzIGJyb3dzZXItc3BlY2lmaWMgcHJlZml4ZXMgYW5kIHByb3ZpZGUgc29tZSBiYXNpYyBwb2x5ZmlsbHNcbiAqL1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICB8fCB3aW5kb3cub1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IHdpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgICAgIHx8IGZ1bmN0aW9uICgvKiBmdW5jdGlvbiBGcmFtZVJlcXVlc3RDYWxsYmFjayAqLyBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCAvIDYwKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZiBNYXRoLmltdWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgTWF0aC5pbXVsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWggPSAoYSA+Pj4gMTYpICYgMHhmZmZmO1xuICAgICAgICBjb25zdCBhbCA9IGEgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGJoID0gKGIgPj4+IDE2KSAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYmwgPSBiICYgMHhmZmZmO1xuICAgICAgICAvLyB0aGUgc2hpZnQgYnkgMCBmaXhlcyB0aGUgc2lnbiBvbiB0aGUgaGlnaCBwYXJ0XG4gICAgICAgIC8vIHRoZSBmaW5hbCB8MCBjb252ZXJ0cyB0aGUgdW5zaWduZWQgdmFsdWUgaW50byBhIHNpZ25lZCB2YWx1ZVxuICAgICAgICByZXR1cm4gKChhbCAqIGJsKSArICgoKGFoICogYmwgKyBhbCAqIGJoKSA8PCAxNikgPj4+IDApIHwgMCk7XG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbn1cblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHsgLy8gLmxlbmd0aCBvZiBmdW5jdGlvbiBpcyAyXG5cbid1c2Ugc3RyaWN0JztcblxuICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7IC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0byA9IE9iamVjdCh0YXJnZXQpO1xuXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgaWYgKG5leHRTb3VyY2UgIT09IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXh0S2V5IGluIG5leHRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobmV4dFNvdXJjZSwgbmV4dEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfTtcbn1cbiIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG5mdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKVxuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY29weVxuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXRcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBiMCA9IGJbMF1cbiAgdmFyIGIxID0gYlsxXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXhhY3RFcXVhbHNcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkXG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnNlXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbWluXG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heFxuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVcblxuLyoqXG4gKiBSb3RhdGVzIGEgdmVjMiBieSBhbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSB0aGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGFuZ2xlKSB7XG4gIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgcyA9IE1hdGguc2luKGFuZ2xlKVxuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXVxuXG4gIG91dFswXSA9IHggKiBjIC0geSAqIHNcbiAgb3V0WzFdID0geCAqIHMgKyB5ICogY1xuXG4gIHJldHVybiBvdXRcbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNlaWxcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVBbmRBZGRcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlXG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemVcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeVxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKVxuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuXG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZG90XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdXG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcm9zc1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIHogPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXG4gICAgb3V0WzBdID0gb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwXG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiBzY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGVcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeVxuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQyZFxuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQyZH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQzXG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0M1xuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXVxuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzRdICogeSArIG1bN11cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm1NYXQ0XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0NFxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdXG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bMTJdXG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdmVjID0gcmVxdWlyZSgnLi9jcmVhdGUnKSgpXG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbFxuICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgc3RyaWRlID0gMlxuICAgIH1cblxuICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gMFxuICAgIH1cbiAgICBcbiAgICBpZihjb3VudCkge1xuICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IGEubGVuZ3RoXG4gICAgfVxuXG4gICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICB2ZWNbMF0gPSBhW2ldXG4gICAgICAgIHZlY1sxXSA9IGFbaSsxXVxuICAgICAgICBmbih2ZWMsIHZlYywgYXJnKVxuICAgICAgICBhW2ldID0gdmVjWzBdXG4gICAgICAgIGFbaSsxXSA9IHZlY1sxXVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGltaXQ7XG5cbi8qKlxuICogTGltaXQgdGhlIG1hZ25pdHVkZSBvZiB0aGlzIHZlY3RvciB0byB0aGUgdmFsdWUgdXNlZCBmb3IgdGhlIGBtYXhgXG4gKiBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtICB7dmVjMn0gdGhlIHZlY3RvciB0byBsaW1pdFxuICogQHBhcmFtICB7TnVtYmVyfSBtYXggdGhlIG1heGltdW0gbWFnbml0dWRlIGZvciB0aGUgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxpbWl0KG91dCwgYSwgbWF4KSB7XG4gIHZhciBtU3EgPSBhWzBdICogYVswXSArIGFbMV0gKiBhWzFdO1xuXG4gIGlmIChtU3EgPiBtYXggKiBtYXgpIHtcbiAgICB2YXIgbiA9IE1hdGguc3FydChtU3EpO1xuICAgIG91dFswXSA9IGFbMF0gLyBuICogbWF4O1xuICAgIG91dFsxXSA9IGFbMV0gLyBuICogbWF4O1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gYW5nbGVcblxudmFyIGZyb21WYWx1ZXMgPSByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbnZhciBkb3QgPSByZXF1aXJlKCcuL2RvdCcpXG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICB2YXIgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgdmFyIHRlbXBCID0gZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKVxuIFxuICAgIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpXG4gICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQilcbiBcbiAgICB2YXIgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQilcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXG4gICAgfSAgICAgXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGIwID0gYlswXVxuICB2YXIgYjEgPSBiWzFdXG4gIHZhciBiMiA9IGJbMl1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXZpZGUnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBtaW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZsb29yXG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBmbG9vcihvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKVxuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3VuZFxuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiXG4gICAgb3V0WzFdID0gYVsxXSAqIGJcbiAgICBvdXRbMl0gPSBhWzJdICogYlxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlQW5kQWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpXG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpXG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBuZWdhdGU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICBvdXRbMl0gPSAtYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVyc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIG91dFsyXSA9IDEuMCAvIGFbMl1cbiAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3M7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl1cblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYnpcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGxlcnA7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl1cbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KVxuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpXG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheilcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByYW5kb207XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMFxuXG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSVxuICAgIHZhciB6ID0gKE1hdGgucmFuZG9tKCkgKiAyLjApIC0gMS4wXG4gICAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAteip6KSAqIHNjYWxlXG5cbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHpTY2FsZVxuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlXG4gICAgb3V0WzJdID0geiAqIHNjYWxlXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV1cbiAgICB3ID0gdyB8fCAxLjBcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gd1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdXG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdXG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddXG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUXVhdDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHpcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xelxuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ5ID0gYlsxXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIFRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG5cbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBieSArIHB5ICogY2MgLSBweiAqIHNjXG4gICAgb3V0WzJdID0gYnogKyBweSAqIHNjICsgcHogKiBjY1xuXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG4gICAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuICBcbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHogKiBzYyArIHB4ICogY2NcbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYnogKyBweiAqIGNjIC0gcHggKiBzY1xuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ5ID0gYlsxXVxuXG4gICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHggKiBjYyAtIHB5ICogc2NcbiAgICBvdXRbMV0gPSBieSArIHB4ICogc2MgKyBweSAqIGNjXG4gICAgb3V0WzJdID0gYVsyXVxuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cbnZhciB2ZWMgPSByZXF1aXJlKCcuL2NyZWF0ZScpKClcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbFxuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzXG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV0gXG4gICAgICAgICAgICB2ZWNbMV0gPSBhW2krMV0gXG4gICAgICAgICAgICB2ZWNbMl0gPSBhW2krMl1cbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpXG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdIFxuICAgICAgICAgICAgYVtpKzFdID0gdmVjWzFdIFxuICAgICAgICAgICAgYVtpKzJdID0gdmVjWzJdXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhXG59IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlU3ByZWFkOyIsInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnRcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAYWxpYXMgbWF0Mi5kZXRlcm1pbmFudFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIudHJhbnNwb3NlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXVxuICAgIG91dFsxXSA9IGFbMl1cbiAgICBvdXRbMl0gPSBhMVxuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzJdXG4gICAgb3V0WzJdID0gYVsxXVxuICAgIG91dFszXSA9IGFbM11cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHlcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyJ3NcbiAqXG4gKiBAYWxpYXMgbWF0Mi5tdWx0aXBseVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdXG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxXG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxXG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzXG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHlcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAYWxpYXMgbWF0Mi5pZGVudGl0eVxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGpvaW50XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuYWRqb2ludFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gIHZhciBhMCA9ICBhWzBdXG4gIG91dFswXSA9ICBhWzNdXG4gIG91dFsxXSA9IC1hWzFdXG4gIG91dFsyXSA9IC1hWzJdXG4gIG91dFszXSA9ICBhMFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlXG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDIgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQGFsaWFzIG1hdDIucm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXVxuICB2YXIgcyA9IE1hdGguc2luKHJhZClcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpXG4gIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHNcbiAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogc1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjXG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGNcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpbnZlcnRcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmludmVydFxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF1cbiAgdmFyIGExID0gYVsxXVxuICB2YXIgYTIgPSBhWzJdXG4gIHZhciBhMyA9IGFbM11cbiAgdmFyIGRldCA9IGEwICogYTMgLSBhMiAqIGExXG5cbiAgaWYgKCFkZXQpIHJldHVybiBudWxsXG4gIGRldCA9IDEuMCAvIGRldFxuXG4gIG91dFswXSA9ICBhMyAqIGRldFxuICBvdXRbMV0gPSAtYTEgKiBkZXRcbiAgb3V0WzJdID0gLWEyICogZGV0XG4gIG91dFszXSA9ICBhMCAqIGRldFxuXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyXG4gKlxuICogQGFsaWFzIG1hdDIuY3JlYXRlXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpXG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZVxuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBhbGlhcyBtYXQyLnNjYWxlXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM11cbiAgdmFyIHYwID0gdlswXSwgdjEgPSB2WzFdXG4gIG91dFswXSA9IGEwICogdjBcbiAgb3V0WzFdID0gYTEgKiB2MFxuICBvdXRbMl0gPSBhMiAqIHYxXG4gIG91dFszXSA9IGEzICogdjFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjb3B5XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBhbGlhcyBtYXQyLmNvcHlcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXVxuICBvdXRbMV0gPSBhWzFdXG4gIG91dFsyXSA9IGFbMl1cbiAgb3V0WzNdID0gYVszXVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb2JcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBhbGlhcyBtYXQyLmZyb2JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xuZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoXG4gICAgTWF0aC5wb3coYVswXSwgMikgK1xuICAgIE1hdGgucG93KGFbMV0sIDIpICtcbiAgICBNYXRoLnBvdyhhWzJdLCAyKSArXG4gICAgTWF0aC5wb3coYVszXSwgMilcbiAgKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBsZHVcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKlxuICogQGFsaWFzIG1hdDIubGR1XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cbmZ1bmN0aW9uIGxkdShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdL2FbMF1cbiAgVVswXSA9IGFbMF1cbiAgVVsxXSA9IGFbMV1cbiAgVVszXSA9IGFbM10gLSBMWzJdICogVVsxXVxuICByZXR1cm4gW0wsIEQsIFVdXG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gaW90YShuKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gaVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpb3RhIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG4iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIG5kYXJyYXkgPSByZXF1aXJlKFwibmRhcnJheVwiKVxudmFyIGRvX2NvbnZlcnQgPSByZXF1aXJlKFwiLi9kb0NvbnZlcnQuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb252ZXJ0KGFyciwgcmVzdWx0KSB7XG4gIHZhciBzaGFwZSA9IFtdLCBjID0gYXJyLCBzeiA9IDFcbiAgd2hpbGUoQXJyYXkuaXNBcnJheShjKSkge1xuICAgIHNoYXBlLnB1c2goYy5sZW5ndGgpXG4gICAgc3ogKj0gYy5sZW5ndGhcbiAgICBjID0gY1swXVxuICB9XG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZGFycmF5KClcbiAgfVxuICBpZighcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gbmRhcnJheShuZXcgRmxvYXQ2NEFycmF5KHN6KSwgc2hhcGUpXG4gIH1cbiAgZG9fY29udmVydChyZXN1bHQsIGFycilcbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgnY3dpc2UtY29tcGlsZXInKSh7XCJhcmdzXCI6W1wiYXJyYXlcIixcInNjYWxhclwiLFwiaW5kZXhcIl0sXCJwcmVcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImJvZHlcIjp7XCJib2R5XCI6XCJ7XFxudmFyIF9pbmxpbmVfMV92PV9pbmxpbmVfMV9hcmcxXyxfaW5saW5lXzFfaVxcbmZvcihfaW5saW5lXzFfaT0wO19pbmxpbmVfMV9pPF9pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMTsrK19pbmxpbmVfMV9pKSB7XFxuX2lubGluZV8xX3Y9X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9pXV1cXG59XFxuX2lubGluZV8xX2FyZzBfPV9pbmxpbmVfMV92W19pbmxpbmVfMV9hcmcyX1tfaW5saW5lXzFfYXJnMl8ubGVuZ3RoLTFdXVxcbn1cIixcImFyZ3NcIjpbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjp0cnVlLFwicnZhbHVlXCI6ZmFsc2UsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcxX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoxfSx7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMl9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6NH1dLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltcIl9pbmxpbmVfMV9pXCIsXCJfaW5saW5lXzFfdlwiXX0sXCJwb3N0XCI6e1wiYm9keVwiOlwie31cIixcImFyZ3NcIjpbXSxcInRoaXNWYXJzXCI6W10sXCJsb2NhbFZhcnNcIjpbXX0sXCJmdW5jTmFtZVwiOlwiY29udmVydFwiLFwiYmxvY2tTaXplXCI6NjR9KVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNyZWF0ZVRodW5rID0gcmVxdWlyZShcIi4vbGliL3RodW5rLmpzXCIpXG5cbmZ1bmN0aW9uIFByb2NlZHVyZSgpIHtcbiAgdGhpcy5hcmdUeXBlcyA9IFtdXG4gIHRoaXMuc2hpbUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QXJncyA9IFtdXG4gIHRoaXMuYXJyYXlCbG9ja0luZGljZXMgPSBbXVxuICB0aGlzLnNjYWxhckFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ3MgPSBbXVxuICB0aGlzLm9mZnNldEFyZ0luZGV4ID0gW11cbiAgdGhpcy5pbmRleEFyZ3MgPSBbXVxuICB0aGlzLnNoYXBlQXJncyA9IFtdXG4gIHRoaXMuZnVuY05hbWUgPSBcIlwiXG4gIHRoaXMucHJlID0gbnVsbFxuICB0aGlzLmJvZHkgPSBudWxsXG4gIHRoaXMucG9zdCA9IG51bGxcbiAgdGhpcy5kZWJ1ZyA9IGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDd2lzZSh1c2VyX2FyZ3MpIHtcbiAgLy9DcmVhdGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jID0gbmV3IFByb2NlZHVyZSgpXG4gIFxuICAvL1BhcnNlIGJsb2Nrc1xuICBwcm9jLnByZSAgICA9IHVzZXJfYXJncy5wcmVcbiAgcHJvYy5ib2R5ICAgPSB1c2VyX2FyZ3MuYm9keVxuICBwcm9jLnBvc3QgICA9IHVzZXJfYXJncy5wb3N0XG5cbiAgLy9QYXJzZSBhcmd1bWVudHNcbiAgdmFyIHByb2NfYXJncyA9IHVzZXJfYXJncy5hcmdzLnNsaWNlKDApXG4gIHByb2MuYXJnVHlwZXMgPSBwcm9jX2FyZ3NcbiAgZm9yKHZhciBpPTA7IGk8cHJvY19hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGFyZ190eXBlID0gcHJvY19hcmdzW2ldXG4gICAgaWYoYXJnX3R5cGUgPT09IFwiYXJyYXlcIiB8fCAodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLmJsb2NrSW5kaWNlcykpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcImFycmF5XCJcbiAgICAgIHByb2MuYXJyYXlBcmdzLnB1c2goaSlcbiAgICAgIHByb2MuYXJyYXlCbG9ja0luZGljZXMucHVzaChhcmdfdHlwZS5ibG9ja0luZGljZXMgPyBhcmdfdHlwZS5ibG9ja0luZGljZXMgOiAwKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwiYXJyYXlcIiArIGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBhcmdzXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNjYWxhclwiKSB7XG4gICAgICBwcm9jLnNjYWxhckFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5zaGltQXJncy5wdXNoKFwic2NhbGFyXCIgKyBpKVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJpbmRleFwiKSB7XG4gICAgICBwcm9jLmluZGV4QXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2hhcGVcIikge1xuICAgICAgcHJvYy5zaGFwZUFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5ib2R5LmFyZ3MubGVuZ3RoICYmIHByb2MuYm9keS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogYm9keSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZih0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUub2Zmc2V0KSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJvZmZzZXRcIlxuICAgICAgcHJvYy5vZmZzZXRBcmdzLnB1c2goeyBhcnJheTogYXJnX3R5cGUuYXJyYXksIG9mZnNldDphcmdfdHlwZS5vZmZzZXQgfSlcbiAgICAgIHByb2Mub2Zmc2V0QXJnSW5kZXgucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVW5rbm93biBhcmd1bWVudCB0eXBlIFwiICsgcHJvY19hcmdzW2ldKVxuICAgIH1cbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXQgbGVhc3Qgb25lIGFycmF5IGFyZ3VtZW50IHdhcyBzcGVjaWZpZWRcbiAgaWYocHJvYy5hcnJheUFyZ3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogTm8gYXJyYXkgYXJndW1lbnRzIHNwZWNpZmllZFwiKVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhcmd1bWVudHMgYXJlIGNvcnJlY3RcbiAgaWYocHJvYy5wcmUuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwcmUoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MuYm9keS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIGJvZHkoKSBibG9ja1wiKVxuICB9XG4gIGlmKHByb2MucG9zdC5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHBvc3QoKSBibG9ja1wiKVxuICB9XG5cbiAgLy9DaGVjayBkZWJ1ZyBmbGFnXG4gIHByb2MuZGVidWcgPSAhIXVzZXJfYXJncy5wcmludENvZGUgfHwgISF1c2VyX2FyZ3MuZGVidWdcbiAgXG4gIC8vUmV0cmlldmUgbmFtZVxuICBwcm9jLmZ1bmNOYW1lID0gdXNlcl9hcmdzLmZ1bmNOYW1lIHx8IFwiY3dpc2VcIlxuICBcbiAgLy9SZWFkIGluIGJsb2NrIHNpemVcbiAgcHJvYy5ibG9ja1NpemUgPSB1c2VyX2FyZ3MuYmxvY2tTaXplIHx8IDY0XG5cbiAgcmV0dXJuIGNyZWF0ZVRodW5rKHByb2MpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZUN3aXNlXG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyBUaGUgZnVuY3Rpb24gYmVsb3cgaXMgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGEgY3dpc2UgZnVuY3Rpb24gb2JqZWN0LCBhbmQgZG9lcyB0aGUgZm9sbG93aW5nOlxuLy8gQSBmdW5jdGlvbiBvYmplY3QgaXMgY29uc3RydWN0ZWQgd2hpY2ggYWNjZXB0cyBhcyBhcmd1bWVudCBhIGNvbXBpbGF0aW9uIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24uXG4vLyBJdCBpcyB0aGlzIG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgZXZlbnR1YWxseSByZXR1cm5lZCBieSBjcmVhdGVUaHVuaywgYW5kIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9uZSB0aGF0IGFjdHVhbGx5XG4vLyBjaGVja3Mgd2hldGhlciBhIGNlcnRhaW4gcGF0dGVybiBvZiBhcmd1bWVudHMgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBhbmQgY29tcGlsZXMgbmV3IGxvb3BzIGFzIG5lZWRlZC5cbi8vIFRoZSBjb21waWxhdGlvbiBwYXNzZWQgdG8gdGhlIGZpcnN0IGZ1bmN0aW9uIG9iamVjdCBpcyB1c2VkIGZvciBjb21waWxpbmcgbmV3IGZ1bmN0aW9ucy5cbi8vIE9uY2UgdGhpcyBmdW5jdGlvbiBvYmplY3QgaXMgY3JlYXRlZCwgaXQgaXMgY2FsbGVkIHdpdGggY29tcGlsZSBhcyBhcmd1bWVudCwgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIGNvbXBpbGVcbi8vIGlzIGJvdW5kIHRvIFwicHJvY1wiIChlc3NlbnRpYWxseSBjb250YWluaW5nIGEgcHJlcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHVzZXIgYXJndW1lbnRzIHRvIGN3aXNlKS5cbi8vIFNvIGNyZWF0ZVRodW5rIHJvdWdobHkgd29ya3MgbGlrZSB0aGlzOlxuLy8gZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuLy8gICB2YXIgdGh1bmsgPSBmdW5jdGlvbihjb21waWxlQm91bmQpIHtcbi8vICAgICB2YXIgQ0FDSEVEID0ge31cbi8vICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXlzIGFuZCBzY2FsYXJzKSB7XG4vLyAgICAgICBpZiAoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cyBpbiBDQUNIRUQpIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c11cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdID0gY29tcGlsZUJvdW5kKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMpXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gZnVuYyhhcnJheXMgYW5kIHNjYWxhcnMpXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQxKHByb2MpKVxuLy8gfVxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUuanNcIilcblxuZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiLCBcInZhciBDQUNIRUQ9e31cIl1cbiAgdmFyIHZhcnMgPSBbXVxuICB2YXIgdGh1bmtOYW1lID0gcHJvYy5mdW5jTmFtZSArIFwiX2N3aXNlX3RodW5rXCJcbiAgXG4gIC8vQnVpbGQgdGh1bmtcbiAgY29kZS5wdXNoKFtcInJldHVybiBmdW5jdGlvbiBcIiwgdGh1bmtOYW1lLCBcIihcIiwgcHJvYy5zaGltQXJncy5qb2luKFwiLFwiKSwgXCIpe1wiXS5qb2luKFwiXCIpKVxuICB2YXIgdHlwZXNpZyA9IFtdXG4gIHZhciBzdHJpbmdfdHlwZXNpZyA9IFtdXG4gIHZhciBwcm9jX2FyZ3MgPSBbW1wiYXJyYXlcIixwcm9jLmFycmF5QXJnc1swXSxcIi5zaGFwZS5zbGljZShcIiwgLy8gU2xpY2Ugc2hhcGUgc28gdGhhdCB3ZSBvbmx5IHJldGFpbiB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlICh3aGljaCBnZXRzIHBhc3NlZCB0byB0aGUgY3dpc2Ugb3BlcmF0b3IgYXMgU1MpLlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF08MD8oXCIsXCIrcHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXStcIilcIik6XCIpXCJdLmpvaW4oXCJcIildXG4gIHZhciBzaGFwZUxlbmd0aENvbmRpdGlvbnMgPSBbXSwgc2hhcGVDb25kaXRpb25zID0gW11cbiAgLy8gUHJvY2VzcyBhcnJheSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgICBpZiAoaT4wKSB7IC8vIEdhdGhlciBjb25kaXRpb25zIHRvIGNoZWNrIGZvciBzaGFwZSBlcXVhbGl0eSAoaWdub3JpbmcgYmxvY2sgaW5kaWNlcylcbiAgICAgIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZS5sZW5ndGgrXCIgKyAoTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSktTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkpKVxuICAgICAgc2hhcGVDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiXT09PWFycmF5XCIgKyBqICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgKyBcIl1cIilcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5XG4gIGlmIChwcm9jLmFycmF5QXJncy5sZW5ndGggPiAxKSB7XG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUxlbmd0aENvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uYWxpdHkhJylcIilcbiAgICBjb2RlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoLVwiICsgTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIjsgc2hhcGVJbmRleC0tPjA7KSB7XCIpXG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUNvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUhJylcIilcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgLy8gUHJvY2VzcyBzY2FsYXIgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIHByb2NfYXJncy5wdXNoKFwic2NhbGFyXCIgKyBwcm9jLnNjYWxhckFyZ3NbaV0pXG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNhY2hlZCBmdW5jdGlvbiAoYW5kIGlmIG5vdCBwcmVzZW50LCBnZW5lcmF0ZSBpdClcbiAgdmFycy5wdXNoKFtcInR5cGU9W1wiLCBzdHJpbmdfdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKVxuICB2YXJzLnB1c2goXCJwcm9jPUNBQ0hFRFt0eXBlXVwiKVxuICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICBcbiAgY29kZS5wdXNoKFtcImlmKCFwcm9jKXtcIixcbiAgICAgICAgICAgICBcIkNBQ0hFRFt0eXBlXT1wcm9jPWNvbXBpbGUoW1wiLCB0eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0pfVwiLFxuICAgICAgICAgICAgIFwicmV0dXJuIHByb2MoXCIsIHByb2NfYXJncy5qb2luKFwiLFwiKSwgXCIpfVwiXS5qb2luKFwiXCIpKVxuXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdW5pcSA9IHJlcXVpcmUoXCJ1bmlxXCIpXG5cbi8vIFRoaXMgZnVuY3Rpb24gZ2VuZXJhdGVzIHZlcnkgc2ltcGxlIGxvb3BzIGFuYWxvZ291cyB0byBob3cgeW91IHR5cGljYWxseSB0cmF2ZXJzZSBhcnJheXMgKHRoZSBvdXRlcm1vc3QgbG9vcCBjb3JyZXNwb25kcyB0byB0aGUgc2xvd2VzdCBjaGFuZ2luZyBpbmRleCwgdGhlIGlubmVybW9zdCBsb29wIHRvIHRoZSBmYXN0ZXN0IGNoYW5naW5nIGluZGV4KVxuLy8gVE9ETzogSWYgdHdvIGFycmF5cyBoYXZlIHRoZSBzYW1lIHN0cmlkZXMgKGFuZCBvZmZzZXRzKSB0aGVyZSBpcyBwb3RlbnRpYWwgZm9yIGRlY3JlYXNpbmcgdGhlIG51bWJlciBvZiBcInBvaW50ZXJzXCIgYW5kIHJlbGF0ZWQgdmFyaWFibGVzLiBUaGUgZHJhd2JhY2sgaXMgdGhhdCB0aGUgdHlwZSBzaWduYXR1cmUgd291bGQgYmVjb21lIG1vcmUgc3BlY2lmaWMgYW5kIHRoYXQgdGhlcmUgd291bGQgdGh1cyBiZSBsZXNzIHBvdGVudGlhbCBmb3IgY2FjaGluZywgYnV0IGl0IG1pZ2h0IHN0aWxsIGJlIHdvcnRoIGl0LCBlc3BlY2lhbGx5IHdoZW4gZGVhbGluZyB3aXRoIGxhcmdlIG51bWJlcnMgb2YgYXJndW1lbnRzLlxuZnVuY3Rpb24gaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGg+MFxuICAgICwgY29kZSA9IFtdXG4gICAgLCB2YXJzID0gW11cbiAgICAsIGlkeD0wLCBwaWR4PTAsIGksIGpcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkgeyAvLyBJdGVyYXRpb24gdmFyaWFibGVzXG4gICAgdmFycy5wdXNoKFtcImlcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL0NvbXB1dGUgc2NhbiBkZWx0YXNcbiAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgcGlkeCA9IGlkeFxuICAgICAgaWR4ID0gb3JkZXJbaV1cbiAgICAgIGlmKGkgPT09IDApIHsgLy8gVGhlIGlubmVybW9zdC9mYXN0ZXN0IGRpbWVuc2lvbidzIGRlbHRhIGlzIHNpbXBseSBpdHMgc3RyaWRlXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPXRcIixqLFwicFwiLGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH0gZWxzZSB7IC8vIEZvciBvdGhlciBkaW1lbnNpb25zIHRoZSBkZWx0YSBpcyBiYXNpY2FsbHkgdGhlIHN0cmlkZSBtaW51cyBzb21ldGhpbmcgd2hpY2ggZXNzZW50aWFsbHkgXCJyZXdpbmRzXCIgdGhlIHByZXZpb3VzIChtb3JlIGlubmVyKSBkaW1lbnNpb25cbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9KHRcIixqLFwicFwiLGlkeCxcIi1zXCIscGlkeCxcIip0XCIsaixcInBcIixwaWR4LFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfSAgXG4gIC8vU2NhbiBsb29wXG4gIGZvcihpPWRpbWVuc2lvbi0xOyBpPj0wOyAtLWkpIHsgLy8gU3RhcnQgYXQgbGFyZ2VzdCBzdHJpZGUgYW5kIHdvcmsgeW91ciB3YXkgaW53YXJkc1xuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgY29kZS5wdXNoKFtcImZvcihpXCIsaSxcIj0wO2lcIixpLFwiPHNcIixpZHgsXCI7KytpXCIsaSxcIil7XCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9QdXNoIGJvZHkgb2YgaW5uZXIgbG9vcFxuICBjb2RlLnB1c2goYm9keSlcbiAgLy9BZHZhbmNlIHNjYW4gcG9pbnRlcnNcbiAgZm9yKGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHBpZHggPSBpZHhcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgICAgY29kZS5wdXNoKFtcInBcIixqLFwiKz1kXCIsaixcInNcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGlmKGkgPiAwKSB7XG4gICAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixwaWR4LFwiXS09c1wiLHBpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goW1wiKytpbmRleFtcIixpZHgsXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vIEdlbmVyYXRlIFwib3V0ZXJcIiBsb29wcyB0aGF0IGxvb3Agb3ZlciBibG9ja3Mgb2YgZGF0YSwgYXBwbHlpbmcgXCJpbm5lclwiIGxvb3BzIHRvIHRoZSBibG9ja3MgYnkgbWFuaXB1bGF0aW5nIHRoZSBsb2NhbCB2YXJpYWJsZXMgaW4gc3VjaCBhIHdheSB0aGF0IHRoZSBpbm5lciBsb29wIG9ubHkgXCJzZWVzXCIgdGhlIGN1cnJlbnQgYmxvY2suXG4vLyBUT0RPOiBJZiB0aGlzIGlzIHVzZWQsIHRoZW4gdGhlIHByZXZpb3VzIGRlY2xhcmF0aW9uIChkb25lIGJ5IGdlbmVyYXRlQ3dpc2VPcCkgb2YgcyogaXMgZXNzZW50aWFsbHkgdW5uZWNlc3NhcnkuXG4vLyAgICAgICBJIGJlbGlldmUgdGhlIHMqIGFyZSBub3QgdXNlZCBlbHNld2hlcmUgKGluIHBhcnRpY3VsYXIsIEkgZG9uJ3QgdGhpbmsgdGhleSdyZSB1c2VkIGluIHRoZSBwcmUvcG9zdCBwYXJ0cyBhbmQgXCJzaGFwZVwiIGlzIGRlZmluZWQgaW5kZXBlbmRlbnRseSksIHNvIGl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2UgZGVmaW5pbmcgdGhlIHMqIGRlcGVuZGVudCBvbiB3aGF0IGxvb3AgbWV0aG9kIGlzIGJlaW5nIHVzZWQuXG5mdW5jdGlvbiBvdXRlckZpbGwobWF0Y2hlZCwgb3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGJsb2NrU2l6ZSA9IHByb2MuYmxvY2tTaXplXG4gICAgLCBoYXNfaW5kZXggPSBwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwXG4gICAgLCBjb2RlID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJ2YXIgb2Zmc2V0XCIsaSxcIj1wXCIsaV0uam9pbihcIlwiKSlcbiAgfVxuICAvL0dlbmVyYXRlIGxvb3BzIGZvciB1bm1hdGNoZWQgZGltZW5zaW9uc1xuICAvLyBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgZGltZW5zaW9ucyBhcmUgdHJhdmVyc2VkIGlzIGZhaXJseSBhcmJpdHJhcnkgKGZyb20gc21hbGwgc3RyaWRlIHRvIGxhcmdlIHN0cmlkZSwgZm9yIHRoZSBmaXJzdCBhcmd1bWVudClcbiAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSBpZiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlc2UgbG9vcHMgYXJlIHBsYWNlZCB3b3VsZCBhbHNvIGJlIHNvbWVob3cgXCJvcHRpbWFsXCIgKGF0IHRoZSB2ZXJ5IGxlYXN0IHdlIHNob3VsZCBjaGVjayB0aGF0IGl0IHJlYWxseSBkb2Vzbid0IGh1cnQgdXMgaWYgdGhleSdyZSBub3QpLlxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChbXCJmb3IodmFyIGpcIitpK1wiPVNTW1wiLCBvcmRlcltpXSwgXCJdfDA7alwiLCBpLCBcIj4wOyl7XCJdLmpvaW4oXCJcIikpIC8vIEl0ZXJhdGUgYmFjayB0byBmcm9udFxuICAgIGNvZGUucHVzaChbXCJpZihqXCIsaSxcIjxcIixibG9ja1NpemUsXCIpe1wiXS5qb2luKFwiXCIpKSAvLyBFaXRoZXIgZGVjcmVhc2UgaiBieSBibG9ja1NpemUgKHMgPSBibG9ja1NpemUpLCBvciBzZXQgaXQgdG8gemVybyAoYWZ0ZXIgc2V0dGluZyBzID0gaikuXG4gICAgY29kZS5wdXNoKFtcInNcIixvcmRlcltpXSxcIj1qXCIsaV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJ9ZWxzZXtzXCIsb3JkZXJbaV0sXCI9XCIsYmxvY2tTaXplXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIi09XCIsYmxvY2tTaXplLFwifVwiXS5qb2luKFwiXCIpKVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLG9yZGVyW2ldLFwiXT1qXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8bmFyZ3M7ICsraSkge1xuICAgIHZhciBpbmRleFN0ciA9IFtcIm9mZnNldFwiK2ldXG4gICAgZm9yKHZhciBqPW1hdGNoZWQ7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICAgIGluZGV4U3RyLnB1c2goW1wialwiLGosXCIqdFwiLGksXCJwXCIsb3JkZXJbal1dLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGNvZGUucHVzaChbXCJwXCIsaSxcIj0oXCIsaW5kZXhTdHIuam9pbihcIitcIiksXCIpXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgY29kZS5wdXNoKGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkpXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy9Db3VudCB0aGUgbnVtYmVyIG9mIGNvbXBhdGlibGUgaW5uZXIgb3JkZXJzXG4vLyBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlc3QgY29tbW9uIHByZWZpeCBvZiB0aGUgYXJyYXlzIGluIG9yZGVycy5cbi8vIEVhY2ggYXJyYXkgaW4gb3JkZXJzIGxpc3RzIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb3JyZXNwb25kIG5kYXJyYXkgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBzdHJpZGUuXG4vLyBUaGlzIGlzIHRodXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRpbWVuc2lvbnMgdGhhdCBjYW4gYmUgZWZmaWNpZW50bHkgdHJhdmVyc2VkIGJ5IHNpbXBsZSBuZXN0ZWQgbG9vcHMgZm9yIGFsbCBhcnJheXMuXG5mdW5jdGlvbiBjb3VudE1hdGNoZXMob3JkZXJzKSB7XG4gIHZhciBtYXRjaGVkID0gMCwgZGltZW5zaW9uID0gb3JkZXJzWzBdLmxlbmd0aFxuICB3aGlsZShtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgZm9yKHZhciBqPTE7IGo8b3JkZXJzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvcmRlcnNbal1bbWF0Y2hlZF0gIT09IG9yZGVyc1swXVttYXRjaGVkXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZFxuICAgICAgfVxuICAgIH1cbiAgICArK21hdGNoZWRcbiAgfVxuICByZXR1cm4gbWF0Y2hlZFxufVxuXG4vL1Byb2Nlc3NlcyBhIGJsb2NrIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZGF0YSB0eXBlc1xuLy8gUmVwbGFjZXMgdmFyaWFibGUgbmFtZXMgYnkgZGlmZmVyZW50IG9uZXMsIGVpdGhlciBcImxvY2FsXCIgb25lcyAodGhhdCBhcmUgdGhlbiBmZXJyaWVkIGluIGFuZCBvdXQgb2YgdGhlIGdpdmVuIGFycmF5KSBvciBvbmVzIG1hdGNoaW5nIHRoZSBhcmd1bWVudHMgdGhhdCB0aGUgZnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgdWx0aW1hdGUgbG9vcCB3aWxsIGFjY2VwdC5cbmZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaywgcHJvYywgZHR5cGVzKSB7XG4gIHZhciBjb2RlID0gYmxvY2suYm9keVxuICB2YXIgcHJlID0gW11cbiAgdmFyIHBvc3QgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxibG9jay5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNhcmcgPSBibG9jay5hcmdzW2ldXG4gICAgaWYoY2FyZy5jb3VudCA8PSAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKGNhcmcubmFtZSwgXCJnXCIpXG4gICAgdmFyIHB0clN0ciA9IFwiXCJcbiAgICB2YXIgYXJyTnVtID0gcHJvYy5hcnJheUFyZ3MuaW5kZXhPZihpKVxuICAgIHN3aXRjaChwcm9jLmFyZ1R5cGVzW2ldKSB7XG4gICAgICBjYXNlIFwib2Zmc2V0XCI6XG4gICAgICAgIHZhciBvZmZBcmdJbmRleCA9IHByb2Mub2Zmc2V0QXJnSW5kZXguaW5kZXhPZihpKVxuICAgICAgICB2YXIgb2ZmQXJnID0gcHJvYy5vZmZzZXRBcmdzW29mZkFyZ0luZGV4XVxuICAgICAgICBhcnJOdW0gPSBvZmZBcmcuYXJyYXlcbiAgICAgICAgcHRyU3RyID0gXCIrcVwiICsgb2ZmQXJnSW5kZXggLy8gQWRkcyBvZmZzZXQgdG8gdGhlIFwicG9pbnRlclwiIGluIHRoZSBhcnJheVxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIHB0clN0ciA9IFwicFwiICsgYXJyTnVtICsgcHRyU3RyXG4gICAgICAgIHZhciBsb2NhbFN0ciA9IFwibFwiICsgaVxuICAgICAgICB2YXIgYXJyU3RyID0gXCJhXCIgKyBhcnJOdW1cbiAgICAgICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSA9PT0gMCkgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGp1c3QgYSBzaW5nbGUgdmFsdWUgZnJvbSB0aGlzIGFycmF5XG4gICAgICAgICAgaWYoY2FyZy5jb3VudCA9PT0gMSkgeyAvLyBBcmd1bWVudC9hcnJheSB1c2VkIG9ubHkgb25jZSg/KVxuICAgICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdPVwiLCBsb2NhbFN0cl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMgYSBcImJsb2NrXCJcbiAgICAgICAgICB2YXIgcmVTdHJBcnIgPSBbY2FyZy5uYW1lXSwgcHRyU3RyQXJyID0gW3B0clN0cl1cbiAgICAgICAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0pOyBqKyspIHtcbiAgICAgICAgICAgIHJlU3RyQXJyLnB1c2goXCJcXFxccypcXFxcWyhbXlxcXFxdXSspXFxcXF1cIilcbiAgICAgICAgICAgIHB0clN0ckFyci5wdXNoKFwiJFwiICsgKGorMSkgKyBcIip0XCIgKyBhcnJOdW0gKyBcImJcIiArIGopIC8vIE1hdGNoZWQgaW5kZXggdGltZXMgc3RyaWRlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlID0gbmV3IFJlZ0V4cChyZVN0ckFyci5qb2luKFwiXCIpLCBcImdcIilcbiAgICAgICAgICBwdHJTdHIgPSBwdHJTdHJBcnIuam9pbihcIitcIilcbiAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIC8qaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKSAvLyBJcyB0aGlzIG5lY2Vzc2FyeSBpZiB0aGUgYXJndW1lbnQgaXMgT05MWSB1c2VkIGFzIGFuIGx2YWx1ZT8gKGtlZXAgaW4gbWluZCB0aGF0IHdlIGNhbiBoYXZlIGEgKz0gc29tZXRoaW5nLCBzbyB3ZSB3b3VsZCBhY3R1YWxseSBuZWVkIHRvIGNoZWNrIGNhcmcucnZhbHVlKVxuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBHZW5lcmljIGFycmF5cyBub3Qgc3VwcG9ydGVkIGluIGNvbWJpbmF0aW9uIHdpdGggYmxvY2tzIVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGRvZXMgbm90IHByb2R1Y2UgYW55IGxvY2FsIHZhcmlhYmxlcywgZXZlbiBpZiB2YXJpYWJsZXMgYXJlIHVzZWQgbXVsdGlwbGUgdGltZXMuIEl0IHdvdWxkIGJlIHBvc3NpYmxlIHRvIGRvIHNvLCBidXQgaXQgd291bGQgY29tcGxpY2F0ZSB0aGluZ3MgcXVpdGUgYSBiaXQuXG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiWVwiICsgcHJvYy5zY2FsYXJBcmdzLmluZGV4T2YoaSkpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcImluZGV4XCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwiaW5kZXhcIilcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwic2hhcGVcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJzaGFwZVwiKVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwcmUuam9pbihcIlxcblwiKSwgY29kZSwgcG9zdC5qb2luKFwiXFxuXCIpXS5qb2luKFwiXFxuXCIpLnRyaW0oKVxufVxuXG5mdW5jdGlvbiB0eXBlU3VtbWFyeShkdHlwZXMpIHtcbiAgdmFyIHN1bW1hcnkgPSBuZXcgQXJyYXkoZHR5cGVzLmxlbmd0aClcbiAgdmFyIGFsbEVxdWFsID0gdHJ1ZVxuICBmb3IodmFyIGk9MDsgaTxkdHlwZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgdCA9IGR0eXBlc1tpXVxuICAgIHZhciBkaWdpdHMgPSB0Lm1hdGNoKC9cXGQrLylcbiAgICBpZighZGlnaXRzKSB7XG4gICAgICBkaWdpdHMgPSBcIlwiXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0cyA9IGRpZ2l0c1swXVxuICAgIH1cbiAgICBpZih0LmNoYXJBdCgwKSA9PT0gMCkge1xuICAgICAgc3VtbWFyeVtpXSA9IFwidVwiICsgdC5jaGFyQXQoMSkgKyBkaWdpdHNcbiAgICB9IGVsc2Uge1xuICAgICAgc3VtbWFyeVtpXSA9IHQuY2hhckF0KDApICsgZGlnaXRzXG4gICAgfVxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBhbGxFcXVhbCA9IGFsbEVxdWFsICYmIHN1bW1hcnlbaV0gPT09IHN1bW1hcnlbaS0xXVxuICAgIH1cbiAgfVxuICBpZihhbGxFcXVhbCkge1xuICAgIHJldHVybiBzdW1tYXJ5WzBdXG4gIH1cbiAgcmV0dXJuIHN1bW1hcnkuam9pbihcIlwiKVxufVxuXG4vL0dlbmVyYXRlcyBhIGN3aXNlIG9wZXJhdG9yXG5mdW5jdGlvbiBnZW5lcmF0ZUNXaXNlT3AocHJvYywgdHlwZXNpZykge1xuXG4gIC8vQ29tcHV0ZSBkaW1lbnNpb25cbiAgLy8gQXJyYXlzIGdldCBwdXQgZmlyc3QgaW4gdHlwZXNpZywgYW5kIHRoZXJlIGFyZSB0d28gZW50cmllcyBwZXIgYXJyYXkgKGR0eXBlIGFuZCBvcmRlciksIHNvIHRoaXMgZ2V0cyB0aGUgbnVtYmVyIG9mIGRpbWVuc2lvbnMgaW4gdGhlIGZpcnN0IGFycmF5IGFyZy5cbiAgdmFyIGRpbWVuc2lvbiA9ICh0eXBlc2lnWzFdLmxlbmd0aCAtIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pKXwwXG4gIHZhciBvcmRlcnMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICB2YXIgZHR5cGVzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBkdHlwZXNbaV0gPSB0eXBlc2lnWzIqaV1cbiAgICBvcmRlcnNbaV0gPSB0eXBlc2lnWzIqaSsxXVxuICB9XG4gIFxuICAvL0RldGVybWluZSB3aGVyZSBibG9jayBhbmQgbG9vcCBpbmRpY2VzIHN0YXJ0IGFuZCBlbmRcbiAgdmFyIGJsb2NrQmVnaW4gPSBbXSwgYmxvY2tFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBleHBvc2VkIGFzIGJsb2Nrc1xuICB2YXIgbG9vcEJlZ2luID0gW10sIGxvb3BFbmQgPSBbXSAvLyBUaGVzZSBpbmRpY2VzIGFyZSBpdGVyYXRlZCBvdmVyXG4gIHZhciBsb29wT3JkZXJzID0gW10gLy8gb3JkZXJzIHJlc3RyaWN0ZWQgdG8gdGhlIGxvb3AgaW5kaWNlc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldPDApIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKDApXG4gICAgICBsb29wRW5kLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrRW5kLnB1c2goZGltZW5zaW9uK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb3BCZWdpbi5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pIC8vIE5vbi1uZWdhdGl2ZVxuICAgICAgbG9vcEVuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0rZGltZW5zaW9uKVxuICAgICAgYmxvY2tCZWdpbi5wdXNoKDApXG4gICAgICBibG9ja0VuZC5wdXNoKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pXG4gICAgfVxuICAgIHZhciBuZXdPcmRlciA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b3JkZXJzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAobG9vcEJlZ2luW2ldPD1vcmRlcnNbaV1bal0gJiYgb3JkZXJzW2ldW2pdPGxvb3BFbmRbaV0pIHtcbiAgICAgICAgbmV3T3JkZXIucHVzaChvcmRlcnNbaV1bal0tbG9vcEJlZ2luW2ldKSAvLyBJZiB0aGlzIGlzIGEgbG9vcCBpbmRleCwgcHV0IGl0IGluIG5ld09yZGVyLCBzdWJ0cmFjdGluZyBsb29wQmVnaW4sIHRvIG1ha2Ugc3VyZSB0aGF0IGFsbCBsb29wT3JkZXJzIGFyZSB1c2luZyBhIGNvbW1vbiBzZXQgb2YgaW5kaWNlcy5cbiAgICAgIH1cbiAgICB9XG4gICAgbG9vcE9yZGVycy5wdXNoKG5ld09yZGVyKVxuICB9XG5cbiAgLy9GaXJzdCBjcmVhdGUgYXJndW1lbnRzIGZvciBwcm9jZWR1cmVcbiAgdmFyIGFyZ2xpc3QgPSBbXCJTU1wiXSAvLyBTUyBpcyB0aGUgb3ZlcmFsbCBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGVcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cbiAgdmFyIHZhcnMgPSBbXVxuICBcbiAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHtcbiAgICB2YXJzLnB1c2goW1wic1wiLCBqLCBcIj1TU1tcIiwgaiwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRoZSBsaW1pdHMgZm9yIGVhY2ggZGltZW5zaW9uLlxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiYVwiK2kpIC8vIEFjdHVhbCBkYXRhIGFycmF5XG4gICAgYXJnbGlzdC5wdXNoKFwidFwiK2kpIC8vIFN0cmlkZXNcbiAgICBhcmdsaXN0LnB1c2goXCJwXCIraSkgLy8gT2Zmc2V0IGluIHRoZSBhcnJheSBhdCB3aGljaCB0aGUgZGF0YSBzdGFydHMgKGFsc28gdXNlZCBmb3IgaXRlcmF0aW5nIG92ZXIgdGhlIGRhdGEpXG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8ZGltZW5zaW9uOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgbG9vcGluZ1xuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwicFwiLGosXCI9dFwiLGksXCJbXCIsbG9vcEJlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pOyArK2opIHsgLy8gVW5wYWNrIHRoZSBzdHJpZGVzIGludG8gdmFycyBmb3IgYmxvY2sgaXRlcmF0aW9uXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJiXCIsaixcIj10XCIsaSxcIltcIixibG9ja0JlZ2luW2ldK2osXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcIllcIiArIGkpXG4gIH1cbiAgaWYocHJvYy5zaGFwZUFyZ3MubGVuZ3RoID4gMCkge1xuICAgIHZhcnMucHVzaChcInNoYXBlPVNTLnNsaWNlKDApXCIpIC8vIE1ha2VzIHRoZSBzaGFwZSBvdmVyIHdoaWNoIHdlIGl0ZXJhdGUgYXZhaWxhYmxlIHRvIHRoZSB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIChzbyB5b3UgY2FuIHVzZSB3aWR0aC9oZWlnaHQgZm9yIGV4YW1wbGUpXG4gIH1cbiAgaWYocHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMCkge1xuICAgIC8vIFByZXBhcmUgYW4gYXJyYXkgdG8ga2VlcCB0cmFjayBvZiB0aGUgKGxvZ2ljYWwpIGluZGljZXMsIGluaXRpYWxpemVkIHRvIGRpbWVuc2lvbiB6ZXJvZXMuXG4gICAgdmFyIHplcm9zID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgICAgemVyb3NbaV0gPSBcIjBcIlxuICAgIH1cbiAgICB2YXJzLnB1c2goW1wiaW5kZXg9W1wiLCB6ZXJvcy5qb2luKFwiLFwiKSwgXCJdXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5vZmZzZXRBcmdzLmxlbmd0aDsgKytpKSB7IC8vIE9mZnNldCBhcmd1bWVudHMgdXNlZCBmb3Igc3RlbmNpbCBvcGVyYXRpb25zXG4gICAgdmFyIG9mZl9hcmcgPSBwcm9jLm9mZnNldEFyZ3NbaV1cbiAgICB2YXIgaW5pdF9zdHJpbmcgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9mZl9hcmcub2Zmc2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAxKSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW1widFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSkgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluaXRfc3RyaW5nLnB1c2goW29mZl9hcmcub2Zmc2V0W2pdLCBcIip0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihpbml0X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhcnMucHVzaChcInFcIiArIGkgKyBcIj0wXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMucHVzaChbXCJxXCIsIGksIFwiPVwiLCBpbml0X3N0cmluZy5qb2luKFwiK1wiKV0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cblxuICAvL1ByZXBhcmUgdGhpcyB2YXJpYWJsZXNcbiAgdmFyIHRoaXNWYXJzID0gdW5pcShbXS5jb25jYXQocHJvYy5wcmUudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLmJvZHkudGhpc1ZhcnMpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChwcm9jLnBvc3QudGhpc1ZhcnMpKVxuICB2YXJzID0gdmFycy5jb25jYXQodGhpc1ZhcnMpXG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwicFwiK2krXCJ8PTBcIilcbiAgfVxuICBcbiAgLy9JbmxpbmUgcHJlbHVkZVxuICBpZihwcm9jLnByZS5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucHJlLCBwcm9jLCBkdHlwZXMpKVxuICB9XG5cbiAgLy9Qcm9jZXNzIGJvZHlcbiAgdmFyIGJvZHkgPSBwcm9jZXNzQmxvY2socHJvYy5ib2R5LCBwcm9jLCBkdHlwZXMpXG4gIHZhciBtYXRjaGVkID0gY291bnRNYXRjaGVzKGxvb3BPcmRlcnMpXG4gIGlmKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBjb2RlLnB1c2gob3V0ZXJGaWxsKG1hdGNoZWQsIGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKSAvLyBUT0RPOiBSYXRoZXIgdGhhbiBwYXNzaW5nIGxvb3BPcmRlcnNbMF0sIGl0IG1pZ2h0IGJlIGludGVyZXN0aW5nIHRvIGxvb2sgYXQgcGFzc2luZyBhbiBvcmRlciB0aGF0IHJlcHJlc2VudHMgdGhlIG1ham9yaXR5IG9mIHRoZSBhcmd1bWVudHMgZm9yIGV4YW1wbGUuXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKGlubmVyRmlsbChsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSlcbiAgfVxuXG4gIC8vSW5saW5lIGVwaWxvZ1xuICBpZihwcm9jLnBvc3QuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnBvc3QsIHByb2MsIGR0eXBlcykpXG4gIH1cbiAgXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIGN3aXNlIHJvdXRpbmUgZm9yIFwiLCB0eXBlc2lnLCBcIjpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICB2YXIgbG9vcE5hbWUgPSBbKHByb2MuZnVuY05hbWV8fFwidW5uYW1lZFwiKSwgXCJfY3dpc2VfbG9vcF9cIiwgb3JkZXJzWzBdLmpvaW4oXCJzXCIpLFwibVwiLG1hdGNoZWQsdHlwZVN1bW1hcnkoZHR5cGVzKV0uam9pbihcIlwiKVxuICB2YXIgZiA9IG5ldyBGdW5jdGlvbihbXCJmdW5jdGlvbiBcIixsb29wTmFtZSxcIihcIiwgYXJnbGlzdC5qb2luKFwiLFwiKSxcIil7XCIsIGNvZGUuam9pbihcIlxcblwiKSxcIn0gcmV0dXJuIFwiLCBsb29wTmFtZV0uam9pbihcIlwiKSlcbiAgcmV0dXJuIGYoKVxufVxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZUNXaXNlT3BcbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICBpZihjb21wYXJlKSB7XG4gICAgaWYoIXNvcnRlZCkge1xuICAgICAgbGlzdC5zb3J0KGNvbXBhcmUpXG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKVxuICB9XG4gIGlmKCFzb3J0ZWQpIHtcbiAgICBsaXN0LnNvcnQoKVxuICB9XG4gIHJldHVybiB1bmlxdWVfZXEobGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiAoaWdub3JlZCkgKi8iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIvKiAoaWdub3JlZCkgKi8iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkYXRhVXJpVG9CdWZmZXI7XG5cbi8qKlxuICogUmV0dXJucyBhIGBCdWZmZXJgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgVVJJIGB1cmlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgRGF0YSBVUkkgdG8gdHVybiBpbnRvIGEgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IEJ1ZmZlciBpbnN0YW5jZSBmcm9tIERhdGEgVVJJXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRhdGFVcmlUb0J1ZmZlciAodXJpKSB7XG4gIGlmICghL15kYXRhXFw6L2kudGVzdCh1cmkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHVyaWAgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgRGF0YSBVUkkgKG11c3QgYmVnaW4gd2l0aCBcImRhdGE6XCIpJyk7XG4gIH1cblxuICAvLyBzdHJpcCBuZXdsaW5lc1xuICB1cmkgPSB1cmkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyk7XG5cbiAgLy8gc3BsaXQgdGhlIFVSSSB1cCBpbnRvIHRoZSBcIm1ldGFkYXRhXCIgYW5kIHRoZSBcImRhdGFcIiBwb3J0aW9uc1xuICB2YXIgZmlyc3RDb21tYSA9IHVyaS5pbmRleE9mKCcsJyk7XG4gIGlmICgtMSA9PT0gZmlyc3RDb21tYSB8fCBmaXJzdENvbW1hIDw9IDQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBkYXRhOiBVUkknKTtcblxuICAvLyByZW1vdmUgdGhlIFwiZGF0YTpcIiBzY2hlbWUgYW5kIHBhcnNlIHRoZSBtZXRhZGF0YVxuICB2YXIgbWV0YSA9IHVyaS5zdWJzdHJpbmcoNSwgZmlyc3RDb21tYSkuc3BsaXQoJzsnKTtcblxuICB2YXIgYmFzZTY0ID0gZmFsc2U7XG4gIHZhciBjaGFyc2V0ID0gJ1VTLUFTQ0lJJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCdiYXNlNjQnID09IG1ldGFbaV0pIHtcbiAgICAgIGJhc2U2NCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgwID09IG1ldGFbaV0uaW5kZXhPZignY2hhcnNldD0nKSkge1xuICAgICAgY2hhcnNldCA9IG1ldGFbaV0uc3Vic3RyaW5nKDgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCB0aGUgZW5jb2RlZCBkYXRhIHBvcnRpb24gYW5kIGRlY29kZSBVUkktZW5jb2RlZCBjaGFyc1xuICB2YXIgZGF0YSA9IHVuZXNjYXBlKHVyaS5zdWJzdHJpbmcoZmlyc3RDb21tYSArIDEpKTtcblxuICB2YXIgZW5jb2RpbmcgPSBiYXNlNjQgPyAnYmFzZTY0JyA6ICdhc2NpaSc7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcblxuICAvLyBzZXQgYC50eXBlYCBwcm9wZXJ0eSB0byBNSU1FIHR5cGVcbiAgYnVmZmVyLnR5cGUgPSBtZXRhWzBdIHx8ICd0ZXh0L3BsYWluJztcblxuICAvLyBzZXQgdGhlIGAuY2hhcnNldGAgcHJvcGVydHlcbiAgYnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuXG4gIHJldHVybiBidWZmZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpbnRlcnAxZChhcnIsIHgpIHtcbiAgdmFyIGl4ID0gTWF0aC5mbG9vcih4KVxuICAgICwgZnggPSB4IC0gaXhcbiAgICAsIHMwID0gMCA8PSBpeCAgICYmIGl4ICAgPCBhcnIuc2hhcGVbMF1cbiAgICAsIHMxID0gMCA8PSBpeCsxICYmIGl4KzEgPCBhcnIuc2hhcGVbMF1cbiAgICAsIHcwID0gczAgPyArYXJyLmdldChpeCkgICA6IDAuMFxuICAgICwgdzEgPSBzMSA/ICthcnIuZ2V0KGl4KzEpIDogMC4wXG4gIHJldHVybiAoMS4wLWZ4KSp3MCArIGZ4KncxXG59XG5cbmZ1bmN0aW9uIGludGVycDJkKGFyciwgeCwgeSkge1xuICB2YXIgaXggPSBNYXRoLmZsb29yKHgpXG4gICAgLCBmeCA9IHggLSBpeFxuICAgICwgczAgPSAwIDw9IGl4ICAgJiYgaXggICA8IGFyci5zaGFwZVswXVxuICAgICwgczEgPSAwIDw9IGl4KzEgJiYgaXgrMSA8IGFyci5zaGFwZVswXVxuICAgICwgaXkgPSBNYXRoLmZsb29yKHkpXG4gICAgLCBmeSA9IHkgLSBpeVxuICAgICwgdDAgPSAwIDw9IGl5ICAgJiYgaXkgICA8IGFyci5zaGFwZVsxXVxuICAgICwgdDEgPSAwIDw9IGl5KzEgJiYgaXkrMSA8IGFyci5zaGFwZVsxXVxuICAgICwgdzAwID0gczAmJnQwID8gYXJyLmdldChpeCAgLGl5ICApIDogMC4wXG4gICAgLCB3MDEgPSBzMCYmdDEgPyBhcnIuZ2V0KGl4ICAsaXkrMSkgOiAwLjBcbiAgICAsIHcxMCA9IHMxJiZ0MCA/IGFyci5nZXQoaXgrMSxpeSAgKSA6IDAuMFxuICAgICwgdzExID0gczEmJnQxID8gYXJyLmdldChpeCsxLGl5KzEpIDogMC4wXG4gIHJldHVybiAoMS4wLWZ5KSAqICgoMS4wLWZ4KSp3MDAgKyBmeCp3MTApICsgZnkgKiAoKDEuMC1meCkqdzAxICsgZngqdzExKVxufVxuXG5mdW5jdGlvbiBpbnRlcnAzZChhcnIsIHgsIHksIHopIHtcbiAgdmFyIGl4ID0gTWF0aC5mbG9vcih4KVxuICAgICwgZnggPSB4IC0gaXhcbiAgICAsIHMwID0gMCA8PSBpeCAgICYmIGl4ICAgPCBhcnIuc2hhcGVbMF1cbiAgICAsIHMxID0gMCA8PSBpeCsxICYmIGl4KzEgPCBhcnIuc2hhcGVbMF1cbiAgICAsIGl5ID0gTWF0aC5mbG9vcih5KVxuICAgICwgZnkgPSB5IC0gaXlcbiAgICAsIHQwID0gMCA8PSBpeSAgICYmIGl5ICAgPCBhcnIuc2hhcGVbMV1cbiAgICAsIHQxID0gMCA8PSBpeSsxICYmIGl5KzEgPCBhcnIuc2hhcGVbMV1cbiAgICAsIGl6ID0gTWF0aC5mbG9vcih6KVxuICAgICwgZnogPSB6IC0gaXpcbiAgICAsIHUwID0gMCA8PSBpeiAgICYmIGl6ICAgPCBhcnIuc2hhcGVbMl1cbiAgICAsIHUxID0gMCA8PSBpeisxICYmIGl6KzEgPCBhcnIuc2hhcGVbMl1cbiAgICAsIHcwMDAgPSBzMCYmdDAmJnUwID8gYXJyLmdldChpeCxpeSxpeikgICAgICAgOiAwLjBcbiAgICAsIHcwMTAgPSBzMCYmdDEmJnUwID8gYXJyLmdldChpeCxpeSsxLGl6KSAgICAgOiAwLjBcbiAgICAsIHcxMDAgPSBzMSYmdDAmJnUwID8gYXJyLmdldChpeCsxLGl5LGl6KSAgICAgOiAwLjBcbiAgICAsIHcxMTAgPSBzMSYmdDEmJnUwID8gYXJyLmdldChpeCsxLGl5KzEsaXopICAgOiAwLjBcbiAgICAsIHcwMDEgPSBzMCYmdDAmJnUxID8gYXJyLmdldChpeCxpeSxpeisxKSAgICAgOiAwLjBcbiAgICAsIHcwMTEgPSBzMCYmdDEmJnUxID8gYXJyLmdldChpeCxpeSsxLGl6KzEpICAgOiAwLjBcbiAgICAsIHcxMDEgPSBzMSYmdDAmJnUxID8gYXJyLmdldChpeCsxLGl5LGl6KzEpICAgOiAwLjBcbiAgICAsIHcxMTEgPSBzMSYmdDEmJnUxID8gYXJyLmdldChpeCsxLGl5KzEsaXorMSkgOiAwLjBcbiAgcmV0dXJuICgxLjAtZnopICogKCgxLjAtZnkpICogKCgxLjAtZngpKncwMDAgKyBmeCp3MTAwKSArIGZ5ICogKCgxLjAtZngpKncwMTAgKyBmeCp3MTEwKSkgKyBmeiAqICgoMS4wLWZ5KSAqICgoMS4wLWZ4KSp3MDAxICsgZngqdzEwMSkgKyBmeSAqICgoMS4wLWZ4KSp3MDExICsgZngqdzExMSkpXG59XG5cbmZ1bmN0aW9uIGludGVycE5kKGFycikge1xuICB2YXIgZCA9IGFyci5zaGFwZS5sZW5ndGh8MFxuICAgICwgaXggPSBuZXcgQXJyYXkoZClcbiAgICAsIGZ4ID0gbmV3IEFycmF5KGQpXG4gICAgLCBzMCA9IG5ldyBBcnJheShkKVxuICAgICwgczEgPSBuZXcgQXJyYXkoZClcbiAgICAsIGksIHRcbiAgZm9yKGk9MDsgaTxkOyArK2kpIHtcbiAgICB0ID0gK2FyZ3VtZW50c1tpKzFdXG4gICAgaXhbaV0gPSBNYXRoLmZsb29yKHQpXG4gICAgZnhbaV0gPSB0IC0gaXhbaV1cbiAgICBzMFtpXSA9ICgwIDw9IGl4W2ldICAgJiYgaXhbaV0gICA8IGFyci5zaGFwZVtpXSlcbiAgICBzMVtpXSA9ICgwIDw9IGl4W2ldKzEgJiYgaXhbaV0rMSA8IGFyci5zaGFwZVtpXSlcbiAgfVxuICB2YXIgciA9IDAuMCwgaiwgdywgaWR4XG5pX2xvb3A6XG4gIGZvcihpPTA7IGk8KDE8PGQpOyArK2kpIHtcbiAgICB3ID0gMS4wXG4gICAgaWR4ID0gYXJyLm9mZnNldFxuICAgIGZvcihqPTA7IGo8ZDsgKytqKSB7XG4gICAgICBpZihpICYgKDE8PGopKSB7XG4gICAgICAgIGlmKCFzMVtqXSkge1xuICAgICAgICAgIGNvbnRpbnVlIGlfbG9vcFxuICAgICAgICB9XG4gICAgICAgIHcgKj0gZnhbal1cbiAgICAgICAgaWR4ICs9IGFyci5zdHJpZGVbal0gKiAoaXhbal0gKyAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIXMwW2pdKSB7XG4gICAgICAgICAgY29udGludWUgaV9sb29wXG4gICAgICAgIH1cbiAgICAgICAgdyAqPSAxLjAgLSBmeFtqXVxuICAgICAgICBpZHggKz0gYXJyLnN0cmlkZVtqXSAqIGl4W2pdXG4gICAgICB9XG4gICAgfVxuICAgIHIgKz0gdyAqIGFyci5kYXRhW2lkeF1cbiAgfVxuICByZXR1cm4gclxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhcnIsIHgsIHksIHopIHtcbiAgc3dpdGNoKGFyci5zaGFwZS5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gMC4wXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGludGVycDFkKGFyciwgeClcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gaW50ZXJwMmQoYXJyLCB4LCB5KVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBpbnRlcnAzZChhcnIsIHgsIHksIHopXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpbnRlcnBOZC5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cylcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcnBvbGF0ZVxubW9kdWxlLmV4cG9ydHMuZDEgPSBpbnRlcnAxZFxubW9kdWxlLmV4cG9ydHMuZDIgPSBpbnRlcnAyZFxubW9kdWxlLmV4cG9ydHMuZDMgPSBpbnRlcnAzZFxuIiwiY29uc3QgQnJlc2VuaGFtID0ge307XG5cbmNvbnN0IFNsb3BlID0ge1xuICAgIERJUjoge1xuICAgICAgICBVUDogMSxcbiAgICAgICAgRE9XTjogLTEsXG4gICAgfSxcbn07XG4vKipcbiAqIFNjYW5zIGEgbGluZSBvZiB0aGUgZ2l2ZW4gaW1hZ2UgZnJvbSBwb2ludCBwMSB0byBwMiBhbmQgcmV0dXJucyBhIHJlc3VsdCBvYmplY3QgY29udGFpbmluZ1xuICogZ3JheS1zY2FsZSB2YWx1ZXMgKDAtMjU1KSBvZiB0aGUgdW5kZXJseWluZyBwaXhlbHMgaW4gYWRkaXRpb24gdG8gdGhlIG1pblxuICogYW5kIG1heCB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VXcmFwcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gcDEgVGhlIHN0YXJ0IHBvaW50IHt4LHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIgVGhlIGVuZCBwb2ludCB7eCx5fVxuICogQHJldHVybnMge2xpbmUsIG1pbiwgbWF4fVxuICovXG5CcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUgPSBmdW5jdGlvbiAoaW1hZ2VXcmFwcGVyLCBwMSwgcDIpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG4gICAgbGV0IHgwID0gcDEueCB8IDA7XG4gICAgbGV0IHkwID0gcDEueSB8IDA7XG4gICAgbGV0IHgxID0gcDIueCB8IDA7XG4gICAgbGV0IHkxID0gcDIueSB8IDA7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IHN0ZWVwID0gTWF0aC5hYnMoeTEgLSB5MCkgPiBNYXRoLmFicyh4MSAtIHgwKTtcbiAgICBsZXQgZXJyb3I7XG4gICAgbGV0IHk7XG4gICAgbGV0IHRtcDtcbiAgICBsZXQgeDtcbiAgICBjb25zdCBsaW5lID0gW107XG4gICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VXcmFwcGVyLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZVdyYXBwZXIuc2l6ZS54O1xuICAgIGxldCB2YWw7XG4gICAgbGV0IG1pbiA9IDI1NTtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlYWQoYSwgYikge1xuICAgICAgICB2YWwgPSBpbWFnZURhdGFbYiAqIHdpZHRoICsgYV07XG4gICAgICAgIG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcbiAgICAgICAgbWF4ID0gdmFsID4gbWF4ID8gdmFsIDogbWF4O1xuICAgICAgICBsaW5lLnB1c2godmFsKTtcbiAgICB9XG5cbiAgICBpZiAoc3RlZXApIHtcbiAgICAgICAgdG1wID0geDA7XG4gICAgICAgIHgwID0geTA7XG4gICAgICAgIHkwID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHgxO1xuICAgICAgICB4MSA9IHkxO1xuICAgICAgICB5MSA9IHRtcDtcbiAgICB9XG4gICAgaWYgKHgwID4geDEpIHtcbiAgICAgICAgdG1wID0geDA7XG4gICAgICAgIHgwID0geDE7XG4gICAgICAgIHgxID0gdG1wO1xuXG4gICAgICAgIHRtcCA9IHkwO1xuICAgICAgICB5MCA9IHkxO1xuICAgICAgICB5MSA9IHRtcDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geDEgLSB4MDtcbiAgICBjb25zdCBkZWx0YVkgPSBNYXRoLmFicyh5MSAtIHkwKTtcbiAgICBlcnJvciA9IChkZWx0YVggLyAyKSB8IDA7XG4gICAgeSA9IHkwO1xuICAgIGNvbnN0IHlTdGVwID0geTAgPCB5MSA/IDEgOiAtMTtcbiAgICBmb3IgKHggPSB4MDsgeCA8IHgxOyB4KyspIHtcbiAgICAgICAgaWYgKHN0ZWVwKSB7XG4gICAgICAgICAgICByZWFkKHksIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVhZCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvciAtPSBkZWx0YVk7XG4gICAgICAgIGlmIChlcnJvciA8IDApIHtcbiAgICAgICAgICAgIHkgKz0geVN0ZXA7XG4gICAgICAgICAgICBlcnJvciArPSBkZWx0YVg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lLFxuICAgICAgICBtaW4sXG4gICAgICAgIG1heCxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgcmVzdWx0IGZyb20gZ2V0QmFyY29kZUxpbmUgaW50byBhIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogYWxzbyBjb25zaWRlcmluZyB0aGUgZnJlcXVlbmN5IGFuZCBzbG9wZSBvZiB0aGUgc2lnbmFsIGZvciBtb3JlIHJvYnVzdCByZXN1bHRzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0IHtsaW5lLCBtaW4sIG1heH1cbiAqL1xuQnJlc2VuaGFtLnRvQmluYXJ5TGluZSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBjb25zdCB7IG1pbiB9ID0gcmVzdWx0O1xuICAgIGNvbnN0IHsgbWF4IH0gPSByZXN1bHQ7XG4gICAgY29uc3QgeyBsaW5lIH0gPSByZXN1bHQ7XG4gICAgbGV0IHNsb3BlO1xuICAgIGxldCBzbG9wZTI7XG4gICAgY29uc3QgY2VudGVyID0gbWluICsgKG1heCAtIG1pbikgLyAyO1xuICAgIGNvbnN0IGV4dHJlbWEgPSBbXTtcbiAgICBsZXQgY3VycmVudERpcjtcbiAgICBsZXQgZGlyO1xuICAgIGxldCB0aHJlc2hvbGQgPSAobWF4IC0gbWluKSAvIDEyO1xuICAgIGNvbnN0IHJUaHJlc2hvbGQgPSAtdGhyZXNob2xkO1xuICAgIGxldCBpO1xuICAgIGxldCBqO1xuXG4gICAgLy8gMS4gZmluZCBleHRyZW1hXG4gICAgY3VycmVudERpciA9IGxpbmVbMF0gPiBjZW50ZXIgPyBTbG9wZS5ESVIuVVAgOiBTbG9wZS5ESVIuRE9XTjtcbiAgICBleHRyZW1hLnB1c2goe1xuICAgICAgICBwb3M6IDAsXG4gICAgICAgIHZhbDogbGluZVswXSxcbiAgICB9KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgc2xvcGUgPSAobGluZVtpICsgMV0gLSBsaW5lW2ldKTtcbiAgICAgICAgc2xvcGUyID0gKGxpbmVbaSArIDJdIC0gbGluZVtpICsgMV0pO1xuICAgICAgICBpZiAoKHNsb3BlICsgc2xvcGUyKSA8IHJUaHJlc2hvbGQgJiYgbGluZVtpICsgMV0gPCAoY2VudGVyICogMS41KSkge1xuICAgICAgICAgICAgZGlyID0gU2xvcGUuRElSLkRPV047XG4gICAgICAgIH0gZWxzZSBpZiAoKHNsb3BlICsgc2xvcGUyKSA+IHRocmVzaG9sZCAmJiBsaW5lW2kgKyAxXSA+IChjZW50ZXIgKiAwLjUpKSB7XG4gICAgICAgICAgICBkaXIgPSBTbG9wZS5ESVIuVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXIgPSBjdXJyZW50RGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnREaXIgIT09IGRpcikge1xuICAgICAgICAgICAgZXh0cmVtYS5wdXNoKHtcbiAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgdmFsOiBsaW5lW2ldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50RGlyID0gZGlyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJlbWEucHVzaCh7XG4gICAgICAgIHBvczogbGluZS5sZW5ndGgsXG4gICAgICAgIHZhbDogbGluZVtsaW5lLmxlbmd0aCAtIDFdLFxuICAgIH0pO1xuXG4gICAgZm9yIChqID0gZXh0cmVtYVswXS5wb3M7IGogPCBleHRyZW1hWzFdLnBvczsgaisrKSB7XG4gICAgICAgIGxpbmVbal0gPSBsaW5lW2pdID4gY2VudGVyID8gMCA6IDE7XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGV4dHJlbWEgYW5kIGNvbnZlcnQgdG8gYmluYXJ5IGJhc2VkIG9uIGF2ZyBiZXR3ZWVuIG1pbm1heFxuICAgIGZvciAoaSA9IDE7IGkgPCBleHRyZW1hLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZXh0cmVtYVtpICsgMV0udmFsID4gZXh0cmVtYVtpXS52YWwpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IChleHRyZW1hW2ldLnZhbCArICgoZXh0cmVtYVtpICsgMV0udmFsIC0gZXh0cmVtYVtpXS52YWwpIC8gMykgKiAyKSB8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoZXh0cmVtYVtpICsgMV0udmFsICsgKChleHRyZW1hW2ldLnZhbCAtIGV4dHJlbWFbaSArIDFdLnZhbCkgLyAzKSkgfCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gZXh0cmVtYVtpXS5wb3M7IGogPCBleHRyZW1hW2kgKyAxXS5wb3M7IGorKykge1xuICAgICAgICAgICAgbGluZVtqXSA9IGxpbmVbal0gPiB0aHJlc2hvbGQgPyAwIDogMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICB9O1xufTtcblxuLyoqXG4gKiBVc2VkIGZvciBkZXZlbG9wbWVudCBvbmx5XG4gKi9cbkJyZXNlbmhhbS5kZWJ1ZyA9IHtcbiAgICBwcmludEZyZXF1ZW5jeShsaW5lLCBjYW52YXMpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgY2FudmFzLndpZHRoID0gbGluZS5sZW5ndGg7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMjU2O1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhpLCAyNTUpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhpLCAyNTUgLSBsaW5lW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgcHJpbnRQYXR0ZXJuKGxpbmUsIGNhbnZhcykge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgbGV0XG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBjYW52YXMud2lkdGggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgY3R4LmZpbGxDb2xvciA9ICdibGFjayc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChpLCAwLCAxLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEJyZXNlbmhhbTtcbiIsImltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuZXhwb3J0IGVudW0gQmFyY29kZURpcmVjdGlvbiB7XG4gICAgRm9yd2FyZCA9IDEsXG4gICAgUmV2ZXJzZSA9IC0xLFxufTtcblxuZXhwb3J0IHR5cGUgQmFyY29kZVJlYWRlclR5cGUgPSBzdHJpbmc7XG5leHBvcnQgdHlwZSBCYXJjb2RlRm9ybWF0ID0gc3RyaW5nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhcmNvZGVSZWFkZXJDb25maWcge1xuICAgIG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg/OiBib29sZWFuLFxuICAgIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlclR5cGU+LFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlQ29ycmVjdGlvbiB7XG4gICAgYmFyOiBudW1iZXIsXG4gICAgc3BhY2U6IG51bWJlcixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZVBvc2l0aW9uIHtcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIHN0YXJ0Q291bnRlcj86IG51bWJlcixcbiAgICBlbmQ6IG51bWJlcixcbiAgICBlbmRDb3VudGVyPzogbnVtYmVyLFxuICAgIGVycm9yPzogbnVtYmVyLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXJjb2RlSW5mbyBleHRlbmRzIEJhcmNvZGVQb3NpdGlvbiB7XG4gICAgY29kZTogbnVtYmVyLFxuICAgIGNvcnJlY3Rpb24/OiBCYXJjb2RlQ29ycmVjdGlvbixcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFyY29kZSB7XG4gICAgY29kZTogc3RyaW5nLFxuICAgIGNvZGVzZXQ/OiBudW1iZXIsXG4gICAgY29ycmVjdGlvbj86IEJhcmNvZGVDb3JyZWN0aW9uLFxuICAgIGRlY29kZWRDb2Rlcz86IEFycmF5PHN0cmluZyB8IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPixcbiAgICBkaXJlY3Rpb24/OiBCYXJjb2RlRGlyZWN0aW9uLFxuICAgIGVuZDogbnVtYmVyLFxuICAgIGVuZEluZm8/OiBCYXJjb2RlUG9zaXRpb24sXG4gICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgc3RhcnRJbmZvOiBCYXJjb2RlUG9zaXRpb24sXG4gICAgc3VwcGxlbWVudD86IEJhcmNvZGUsXG59O1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFyY29kZVJlYWRlciB7XG4gICAgX3JvdzogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIGNvbmZpZzogQmFyY29kZVJlYWRlckNvbmZpZyA9IHt9O1xuICAgIHN1cHBsZW1lbnRzOiBBcnJheTxCYXJjb2RlUmVhZGVyPiA9IFtdO1xuICAgIFNJTkdMRV9DT0RFX0VSUk9SID0gMDtcbiAgICBGT1JNQVQ6IEJhcmNvZGVGb3JtYXQgPSAndW5rbm93bic7XG4gICAgQ09ORklHX0tFWVM6IEJhcmNvZGVSZWFkZXJDb25maWcgPSB7fTtcbiAgICAvLyBUT0RPOiBzaG91bGQgYWRkIEFMUEhBQkVUSF9TVFJJTkcsIEFMUEhBQkVULCBDSEFSQUNURVJfRU5DT0RJTkdTIHRvIGJhc2UgY2xhc3MsIGlmIHRoZXlcbiAgICAvLyBhcmUgdXNlZnVsIGluIG1vc3QgcmVhZGVycy5cblxuICAgIGFic3RyYWN0IF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24gfCBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbDtcblxuICAgIHN0YXRpYyBnZXQgRXhjZXB0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgU3RhcnROb3RGb3VuZEV4Y2VwdGlvbjogJ1N0YXJ0LUluZm8gd2FzIG5vdCBmb3VuZCEnLFxuICAgICAgICAgICAgQ29kZU5vdEZvdW5kRXhjZXB0aW9uOiAnQ29kZSBjb3VsZCBub3QgYmUgZm91bmQhJyxcbiAgICAgICAgICAgIFBhdHRlcm5Ob3RGb3VuZEV4Y2VwdGlvbjogJ1BhdHRlcm4gY291bGQgbm90IGJlIGZvdW5kISdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IEJhcmNvZGVSZWFkZXJDb25maWcsIHN1cHBsZW1lbnRzPzogQXJyYXk8QmFyY29kZVJlYWRlcj4pIHtcblxuICAgICAgICB0aGlzLl9yb3cgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIGlmIChzdXBwbGVtZW50cykge1xuICAgICAgICAgICAgdGhpcy5zdXBwbGVtZW50cyA9IHN1cHBsZW1lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9uZXh0VW5zZXQobGluZTogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBzdGFydDogbnVtYmVyID0gMCk6IG51bWJlciB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghbGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIF9tYXRjaFBhdHRlcm4oY291bnRlcjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBjb2RlOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG1heFNpbmdsZUVycm9yPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGVycm9yID0gMDtcbiAgICAgICAgbGV0IHNpbmdsZUVycm9yID0gMDtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBtb2R1bG8gPSAwO1xuICAgICAgICBsZXQgYmFyV2lkdGggPSAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBsZXQgc2NhbGVkID0gMDtcblxuICAgICAgICBtYXhTaW5nbGVFcnJvciA9IG1heFNpbmdsZUVycm9yIHx8IHRoaXMuU0lOR0xFX0NPREVfRVJST1IgfHwgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgbW9kdWxvICs9IGNvZGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1bSA8IG1vZHVsbykge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cblxuICAgICAgICBiYXJXaWR0aCA9IHN1bSAvIG1vZHVsbztcbiAgICAgICAgbWF4U2luZ2xlRXJyb3IgKj0gYmFyV2lkdGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgc2NhbGVkID0gY29kZVtpXSAqIGJhcldpZHRoO1xuICAgICAgICAgICAgc2luZ2xlRXJyb3IgPSBNYXRoLmFicyhjb3VudCAtIHNjYWxlZCkgLyBzY2FsZWQ7XG4gICAgICAgICAgICBpZiAoc2luZ2xlRXJyb3IgPiBtYXhTaW5nbGVFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IgKz0gc2luZ2xlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yIC8gbW9kdWxvO1xuICAgIH1cblxuICAgIF9uZXh0U2V0KGxpbmU6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0OiBudW1iZXIgPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtpXSkgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmUubGVuZ3RoO1xuICAgIH1cblxuICAgIF9jb3JyZWN0QmFycyhjb3VudGVyOiBBcnJheTxudW1iZXI+LCBjb3JyZWN0aW9uOiBudW1iZXIsIGluZGljZXM6IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgICBsZXQgdG1wID0gMDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB0bXAgPSBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gKiAoMSAtICgoMSAtIGNvcnJlY3Rpb24pIC8gMikpO1xuICAgICAgICAgICAgaWYgKHRtcCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2luZGljZXNbbGVuZ3RoXV0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNvZGVQYXR0ZXJuKHBhdHRlcm46IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4nLCBwYXR0ZXJuKTtcbiAgICAgICAgdGhpcy5fcm93ID0gcGF0dGVybjtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBhdHRlcm4gY2FsbGluZyBkZWNvZGUnLCB0eXBlb2YgdGhpcywgdGhpcy5jb25zdHJ1Y3RvciwgdGhpcy5GT1JNQVQsIEpTT04uc3RyaW5naWZ5KHRoaXMpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuX2RlY29kZSgpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3QgcmVzdWx0PScsIHJlc3VsdCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvdy5yZXZlcnNlKCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvZGUoKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXZlcnNlZCByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlyZWN0aW9uID0gQmFyY29kZURpcmVjdGlvbi5SZXZlcnNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSByZXN1bHQuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmRpcmVjdGlvbiA9IEJhcmNvZGVEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuZm9ybWF0ID0gdGhpcy5GT1JNQVQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX21hdGNoUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPCAwID8gMCA6IHN0YXJ0O1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfZmlsbENvdW50ZXJzKG9mZnNldDogbnVtYmVyID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3JvdyksIGVuZDogbnVtYmVyID0gdGhpcy5fcm93Lmxlbmd0aCwgaXNXaGl0ZTogYm9vbGVhbiA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgY291bnRlcnM6IEFycmF5PG51bWJlcj4gPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zXSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50ZXJzO1xuICAgIH1cblxuICAgIF90b0NvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSB8IEFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBpc1doaXRlID0gIXRoaXMuX3Jvd1tzdGFydF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBBcnJheUhlbHBlci5pbml0KGNvdW50ZXJzLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gbnVtQ291bnRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudGVycztcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhcmNvZGVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlQ29ycmVjdGlvbiwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBDb2RlMTI4UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgQ09ERV9TSElGVCA9IDk4O1xuICAgIENPREVfQyA9IDk5O1xuICAgIENPREVfQiA9IDEwMDtcbiAgICBDT0RFX0EgPSAxMDE7XG4gICAgU1RBUlRfQ09ERV9BID0gMTAzO1xuICAgIFNUQVJUX0NPREVfQiA9IDEwNDtcbiAgICBTVEFSVF9DT0RFX0MgPSAxMDU7XG4gICAgU1RPUF9DT0RFID0gMTA2O1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgICAgIFsyLCAxLCAyLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAyLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAzLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAzLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAzLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAyLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAyLCAzLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAyLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFszLCAyLCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAxLCAzLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAyLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAzLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAzLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAzLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAzLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAzLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAxLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFszLCAxLCAyLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAzLCAyLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAzLCAxLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCA0LCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCAyLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCA0LCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAxLCAyLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAxLCAyLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAxLCAyLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFsxLCAyLCAyLCA0LCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCA0LCAyLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAyLCAxLCAxLCAxLCA0XSxcbiAgICAgICAgICAgIFs0LCAxLCAzLCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCA0LCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAzLCA0LCAxLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAyLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAxLCA0LCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCAxLCAyLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFsxLCAyLCA0LCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAyLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgICAgIFs0LCAyLCAxLCAyLCAxLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAyLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCA0LCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAyLCAxLCAyLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAxLCA0LCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCAxLCAzLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAzLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAxLCAzXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAzLCAxLCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCAzLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFsxLCAxLCA0LCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFszLCAxLCAxLCAxLCA0LCAxXSxcbiAgICAgICAgICAgIFs0LCAxLCAxLCAxLCAzLCAxXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCA0LCAxLCAyXSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAxLCA0XSxcbiAgICAgICAgICAgIFsyLCAxLCAxLCAyLCAzLCAyXSxcbiAgICAgICAgICAgIFsyLCAzLCAzLCAxLCAxLCAxLCAyXSxcbiAgICAgICAgXTtcbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNjQ7XG4gICAgQVZHX0NPREVfRVJST1IgPSAwLjMwO1xuICAgIEZPUk1BVCA9ICdjb2RlXzEyOCc7XG4gICAgTU9EVUxFX0lORElDRVMgPSB7IGJhcjogWzAsIDIsIDRdLCBzcGFjZTogWzEsIDMsIDVdIH07XG5cbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb3JyZWN0aW9uPzogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoID0ge1xuICAgICAgICAgICAgZXJyb3I6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgICAgICBjb2RlOiAtMSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnQsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBsZXQgaXNXaGl0ZSA9ICF0aGlzLl9yb3dbb2Zmc2V0XTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ycmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ycmVjdChjb3VudGVyLCBjb3JyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IHRoaXMuQ09ERV9QQVRURVJOLmxlbmd0aDsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCB0aGlzLkNPREVfUEFUVEVSTltjb2RlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guY29kZSA9PT0gLTEgfHwgYmVzdE1hdGNoLmVycm9yID4gdGhpcy5BVkdfQ09ERV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvcnJlY3Rpb24uYmFyID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLmJhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5zcGFjZSA9IHRoaXMuY2FsY3VsYXRlQ29ycmVjdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkNPREVfUEFUVEVSTltiZXN0TWF0Y2guY29kZV0sIGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX2NvcnJlY3QoY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29ycmVjdGlvbjogQmFyY29kZUNvcnJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5iYXIsIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgdGhpcy5fY29ycmVjdEJhcnMoY291bnRlciwgY29ycmVjdGlvbi5zcGFjZSwgdGhpcy5NT0RVTEVfSU5ESUNFUy5zcGFjZSk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IF9maW5kU3RhcnQgYW5kIGRlY29kZUNvZGUgc2hhcmUgc2ltaWxhciBjb2RlLCBjYW4gd2UgcmUtdXNlIHNvbWU/XG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgYmFyOiAxLFxuICAgICAgICAgICAgICAgIHNwYWNlOiAxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVyLnJlZHVjZSgocHJldiwgbmV4dCkgPT4gcHJldiArIG5leHQsIDApO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gdGhpcy5TVEFSVF9DT0RFX0E7IGNvZGUgPD0gdGhpcy5TVEFSVF9DT0RFX0M7IGNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCB0aGlzLkFWR19DT0RFX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gc3VtO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guY29ycmVjdGlvbi5iYXIgPSB0aGlzLmNhbGN1bGF0ZUNvcnJlY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5DT0RFX1BBVFRFUk5bYmVzdE1hdGNoLmNvZGVdLCBjb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuTU9EVUxFX0lORElDRVMuYmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb3JyZWN0aW9uLnNwYWNlID0gdGhpcy5jYWxjdWxhdGVDb3JyZWN0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQ09ERV9QQVRURVJOW2Jlc3RNYXRjaC5jb2RlXSwgY291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLk1PRFVMRV9JTkRJQ0VTLnNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICBjb25zdCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKHN0YXJ0SW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAvLyAgICAgZG9uZSA9IGZhbHNlLFxuICAgICAgICAvLyAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgIC8vICAgICBtdWx0aXBsaWVyID0gMCxcbiAgICAgICAgLy8gICAgIGNoZWNrc3VtID0gMCxcbiAgICAgICAgLy8gICAgIGNvZGVzZXQsXG4gICAgICAgIC8vICAgICByYXdSZXN1bHQgPSBbXSxcbiAgICAgICAgLy8gICAgIGRlY29kZWRDb2RlcyA9IFtdLFxuICAgICAgICAvLyAgICAgc2hpZnROZXh0ID0gZmFsc2UsXG4gICAgICAgIC8vICAgICB1bnNoaWZ0LFxuICAgICAgICAvLyAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IHRydWU7XG5cbiAgICAgICAgbGV0IGNvZGU6IEJhcmNvZGVJbmZvIHwgbnVsbCA9IHtcbiAgICAgICAgICAgIGNvZGU6IHN0YXJ0SW5mby5jb2RlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZCxcbiAgICAgICAgICAgIGNvcnJlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBiYXI6IHN0YXJ0SW5mby5jb3JyZWN0aW9uLmJhcixcbiAgICAgICAgICAgICAgICBzcGFjZTogc3RhcnRJbmZvLmNvcnJlY3Rpb24uc3BhY2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIGxldCBjaGVja3N1bSA9IGNvZGUuY29kZTtcbiAgICAgICAgbGV0IGNvZGVzZXQgPSAoKGM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUQVJUX0NPREVfQTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5TVEFSVF9DT0RFX0I6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RBUlRfQ09ERV9DOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5DT0RFX0M7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGNvZGUuY29kZSk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGxldCBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgIGxldCByZW1vdmVMYXN0Q2hhcmFjdGVyID0gdHJ1ZTtcbiAgICAgICAgbGV0IG11bHRpcGxpZXIgPSAwO1xuICAgICAgICBsZXQgcmF3UmVzdWx0OiBBcnJheTxudW1iZXI+ID0gW107XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZyB8IG51bWJlcj4gPSBbXTsgLy8gVE9ETzogaSB0aGluayB0aGlzIHNob3VsZCBiZSBzdHJpbmcgb25seSwgYnV0IGl0IGNyZWF0ZXMgcHJvYmxlbXMgaWYgaXQgaXNcblxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIHVuc2hpZnQgPSBzaGlmdE5leHQ7XG4gICAgICAgICAgICBzaGlmdE5leHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvZGUhLmVuZCwgY29kZSEuY29ycmVjdGlvbik7XG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxhc3RDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhd1Jlc3VsdC5wdXNoKGNvZGUuY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gbXVsdGlwbGllciAqIGNvZGUuY29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGVzZXQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlLmNvZGUgPCA5Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlLmNvZGUgLSA2NCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuY29kZSAhPT0gdGhpcy5TVE9QX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMYXN0Q2hhcmFjdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfU0hJRlQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9DO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9COlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5jb2RlIDwgOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoMzIgKyBjb2RlLmNvZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9TSElGVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnROZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuQ09ERV9BOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVzZXQgPSB0aGlzLkNPREVfQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLlNUT1BfQ09ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0M6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSA8IDEwID8gJzAnICsgY29kZS5jb2RlIDogY29kZS5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgIT09IHRoaXMuU1RPUF9DT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGFzdENoYXJhY3RlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5DT0RFX0E6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZXNldCA9IHRoaXMuQ09ERV9BO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkNPREVfQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2Rlc2V0ID0gdGhpcy5DT0RFX0I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuU1RPUF9DT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5zaGlmdCkge1xuICAgICAgICAgICAgICAgIGNvZGVzZXQgPSBjb2Rlc2V0ID09PSB0aGlzLkNPREVfQSA/IHRoaXMuQ09ERV9CIDogdGhpcy5DT0RFX0E7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlLmVuZCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIGNvZGUuZW5kKTtcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoY29kZSkpe1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaGVja3N1bSAtPSBtdWx0aXBsaWVyICogcmF3UmVzdWx0W3Jhd1Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNoZWNrc3VtICUgMTAzICE9PSByYXdSZXN1bHRbcmF3UmVzdWx0Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgbGFzdCBjb2RlIGZyb20gcmVzdWx0IChjaGVja3N1bSlcbiAgICAgICAgaWYgKHJlbW92ZUxhc3RDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UocmVzdWx0Lmxlbmd0aCAtIDEsIDEpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogY29kZS5lbmQsXG4gICAgICAgICAgICBjb2Rlc2V0OiBjb2Rlc2V0IGFzIG51bWJlcixcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmRJbmZvOiBjb2RlLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlSW5mbyk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kO1xuXG4gICAgICAgIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCBzZWxmLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIGNhbGN1bGF0ZUNvcnJlY3Rpb24oZXhwZWN0ZWQ6IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgbm9ybWFsaXplZDogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBpbmRpY2VzOiBSZWFkb25seUFycmF5PG51bWJlcj4pOiBudW1iZXIge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkID0gMCxcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkID0gMDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHN1bUV4cGVjdGVkICs9IGV4cGVjdGVkW2luZGljZXNbbGVuZ3RoXV07XG4gICAgICAgICAgICBzdW1Ob3JtYWxpemVkICs9IG5vcm1hbGl6ZWRbaW5kaWNlc1tsZW5ndGhdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtRXhwZWN0ZWQgLyBzdW1Ob3JtYWxpemVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTEyOFJlYWRlcjtcbiIsImltcG9ydCBCYXJjb2RlUmVhZGVyLCB7IEJhcmNvZGVSZWFkZXJDb25maWcsIEJhcmNvZGVJbmZvLCBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcblxuLy8gY29uc3QgQ09ERV9MX1NUQVJUID0gMDtcbmNvbnN0IENPREVfR19TVEFSVCA9IDEwO1xuZXhwb3J0IHsgQ09ERV9HX1NUQVJUIH07XG5jb25zdCBTVEFSVF9QQVRURVJOID0gWzEsIDEsIDFdO1xuY29uc3QgTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XG5leHBvcnQgeyBNSURETEVfUEFUVEVSTiB9O1xuY29uc3QgRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMl07XG5jb25zdCBDT0RFX1BBVFRFUk4gPSBbXG4gICAgWzMsIDIsIDEsIDFdLFxuICAgIFsyLCAyLCAyLCAxXSxcbiAgICBbMiwgMSwgMiwgMl0sXG4gICAgWzEsIDQsIDEsIDFdLFxuICAgIFsxLCAxLCAzLCAyXSxcbiAgICBbMSwgMiwgMywgMV0sXG4gICAgWzEsIDEsIDEsIDRdLFxuICAgIFsxLCAzLCAxLCAyXSxcbiAgICBbMSwgMiwgMSwgM10sXG4gICAgWzMsIDEsIDEsIDJdLFxuICAgIFsxLCAxLCAyLCAzXSxcbiAgICBbMSwgMiwgMiwgMl0sXG4gICAgWzIsIDIsIDEsIDJdLFxuICAgIFsxLCAxLCA0LCAxXSxcbiAgICBbMiwgMywgMSwgMV0sXG4gICAgWzEsIDMsIDIsIDFdLFxuICAgIFs0LCAxLCAxLCAxXSxcbiAgICBbMiwgMSwgMywgMV0sXG4gICAgWzMsIDEsIDIsIDFdLFxuICAgIFsyLCAxLCAxLCAzXSxcbl07XG5jb25zdCBDT0RFX0ZSRVFVRU5DWSA9IFswLCAxMSwgMTMsIDE0LCAxOSwgMjUsIDI4LCAyMSwgMjIsIDI2XTtcbi8vIGNvbnN0IFNJTkdMRV9DT0RFX0VSUk9SID0gMC43MDtcbmNvbnN0IEFWR19DT0RFX0VSUk9SID0gMC40ODtcblxuY2xhc3MgRUFOUmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2Vhbl8xMyc7XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjcwO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxLCAxLCAxXTsgLy8gVE9ETzogZG9lcyB0aGlzIG5lZWQgdG8gYmUgaW4gdGhlIGNsYXNzP1xuXG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogQmFyY29kZVJlYWRlckNvbmZpZywgc3VwcGxlbWVudHM/OiBBcnJheTxCYXJjb2RlUmVhZGVyPikge1xuICAgICAgICBzdXBlcihtZXJnZSh7IHN1cHBsZW1lbnRzOiBbXSB9LCBjb25maWcpLCBzdXBwbGVtZW50cyk7XG4gICAgfVxuICAgIF9maW5kUGF0dGVybihwYXR0ZXJuOiBSZWFkb25seUFycmF5PG51bWJlcj4sIG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuLCB0cnlIYXJkZXI6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2g6IEJhcmNvZGVQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IEFWR19DT0RFX0VSUk9SO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm4nLCBwYXR0ZXJuLCBvZmZzZXQsIGlzV2hpdGUsIHRyeUhhcmRlciwgZXBzaWxvbik7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHRoaXMuX3Jvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGAqIGxvb3AgaT0ke29mZnNldH0gbGVuPSR7dGhpcy5fcm93Lmxlbmd0aH0gaXNXaGl0ZT0ke2lzV2hpdGV9IGNvdW50ZXJQb3M9JHtjb3VudGVyUG9zfWApO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvd1tpXSBeIChpc1doaXRlID8gMSA6IDApKSB7XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvcyA9PT0gY291bnRlci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogbWF0Y2hQYXR0ZXJuJywgZXJyb3IsIGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uICYmIGJlc3RNYXRjaC5lcnJvciAmJiBlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guc3RhcnQgPSBpIC0gY291bnRlci5yZWR1Y2UoKHN1bSwgdmFsdWUpID0+IHN1bSArIHZhbHVlLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBiZXN0TWF0Y2gnLCBKU09OLnN0cmluZ2lmeShiZXN0TWF0Y2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdID0gMTtcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kID8gYmVzdE1hdGNoIDogbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBmaW5kUGF0dGVybiBhbmQgZGVjb2RlQ29kZSBhcHBlYXIgdG8gc2hhcmUgcXVpdGUgc2ltaWxhciBjb2RlLCBjYW4gaXQgYmUgcmVkdWNlZD9cbiAgICBfZGVjb2RlQ29kZShzdGFydDogbnVtYmVyLCBjb2RlcmFuZ2U/OiBudW1iZXIpOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZScsIHN0YXJ0LCBjb2RlcmFuZ2UpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydDtcbiAgICAgICAgY29uc3QgYmVzdE1hdGNoOiBCYXJjb2RlSW5mbyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVwc2lsb24gPSBBVkdfQ09ERV9FUlJPUjtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSAhdGhpcy5fcm93W29mZnNldF07XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcblxuICAgICAgICBpZiAoIWNvZGVyYW5nZSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUNvZGUgYmVmb3JlIGxlbmd0aCcpO1xuICAgICAgICAgICAgY29kZXJhbmdlID0gQ09ERV9QQVRURVJOLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBkZWNvZGVDb2RlIGFmdGVyIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IGNvZGVyYW5nZTsgY29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuX21hdGNoUGF0dGVybihjb3VudGVyLCBDT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2guZXJyb3IhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IhID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuIGJlc3RNYXRjaCcsIEpTT04uc3RyaW5naWZ5KGJlc3RNYXRjaCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZCA/IGJlc3RNYXRjaCA6IG51bGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kU3RhcnQoKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBmaW5kU3RhcnQnKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IHN0YXJ0SW5mbzogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRQYXR0ZXJuKFNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHN0YXJ0SW5mbz0nLCBKU09OLnN0cmluZ2lmeShzdGFydEluZm8pKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSAoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm5pbmcgc3RhcnRJbmZvJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nIG51bGwnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2FsY3VsYXRlRmlyc3REaWdpdChjb2RlRnJlcXVlbmN5OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGNhbGN1bGF0ZUZpcnN0RGlnaXQnLCBjb2RlRnJlcXVlbmN5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDT0RFX0ZSRVFVRU5DWS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IENPREVfRlJFUVVFTkNZW2ldKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybmluZycsIGkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2RlY29kZVBheWxvYWQoaW5Db2RlOiBCYXJjb2RlUG9zaXRpb24sIHJlc3VsdDogQXJyYXk8bnVtYmVyPiwgZGVjb2RlZENvZGVzOiBBcnJheTxCYXJjb2RlUG9zaXRpb24+KTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZVBheWxvYWQnLCBpbkNvZGUsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgbGV0IG91dENvZGU6IEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uIHwgbnVsbCA9IHsgLi4uaW5Db2RlIH07XG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMHgwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRDb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvdXRDb2RlLmVuZCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBvdXRDb2RlKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlIC09IENPREVfR19TVEFSVDtcbiAgICAgICAgICAgICAgICBjb2RlRnJlcXVlbmN5IHw9IDEgPDwgKDUgLSBpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAwIDw8ICg1IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCgob3V0Q29kZSBhcyBCYXJjb2RlSW5mbykuY29kZSk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChvdXRDb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpcnN0RGlnaXQgPSB0aGlzLl9jYWxjdWxhdGVGaXJzdERpZ2l0KGNvZGVGcmVxdWVuY3kpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmlyc3REaWdpdD0nLCBmaXJzdERpZ2l0KTtcbiAgICAgICAgaWYgKGZpcnN0RGlnaXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQudW5zaGlmdChmaXJzdERpZ2l0KTtcblxuICAgICAgICBsZXQgbWlkZGxlUGF0dGVybiA9IHRoaXMuX2ZpbmRQYXR0ZXJuKE1JRERMRV9QQVRURVJOLCBvdXRDb2RlLmVuZCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZmluZFBhdHRlcm49JywgSlNPTi5zdHJpbmdpZnkobWlkZGxlUGF0dGVybikpO1xuXG4gICAgICAgIGlmIChtaWRkbGVQYXR0ZXJuID09PSBudWxsIHx8ICFtaWRkbGVQYXR0ZXJuLmVuZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHJldHVybiBudWxsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG1pZGRsZVBhdHRlcm4pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBtaWRkbGVQYXR0ZXJuID0gdGhpcy5fZGVjb2RlQ29kZShtaWRkbGVQYXR0ZXJuIS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlQ29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG5cbiAgICAgICAgICAgIGlmICghbWlkZGxlUGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChtaWRkbGVQYXR0ZXJuKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChtaWRkbGVQYXR0ZXJuIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgY29kZT0nLCBKU09OLnN0cmluZ2lmeShtaWRkbGVQYXR0ZXJuKSk7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgcmVzdWx0PScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGRlY29kZWRDb2Rlcz0nLCBkZWNvZGVkQ29kZXMpO1xuICAgICAgICByZXR1cm4gbWlkZGxlUGF0dGVybiBhcyBCYXJjb2RlSW5mbztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZScsIEpTT04uc3RyaW5naWZ5KGVuZEluZm8pKTtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KTtcblxuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogcmV0dXJuaW5nJywgSlNPTi5zdHJpbmdpZnkoZW5kSW5mbykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiByZXR1cm4gbnVsbCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2ZpbmRFbmQob2Zmc2V0OiBudW1iZXIsIGlzV2hpdGU6IGJvb2xlYW4pOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGZpbmRFbmQnLCBvZmZzZXQsIGlzV2hpdGUpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4sIG9mZnNldCwgaXNXaGl0ZSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogX2NoZWNrc3VtJywgcmVzdWx0KTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICAgICAgc3VtICs9IHJlc3VsdFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1bSAqPSAzO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZW5kIGNoZWNrc3VtJywgc3VtICUgMTAgPT09IDApO1xuICAgICAgICByZXR1cm4gc3VtICUgMTAgPT09IDA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZGVjb2RlRXh0ZW5zaW9ucyhvZmZzZXQ6IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oRVhURU5TSU9OX1NUQVJUX1BBVFRFUk4sIHN0YXJ0LCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChzdGFydEluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMnLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIHRoZXJlIGFyZSAnLCB0aGlzLnN1cHBsZW1lbnRzLmxlbmd0aCwgJyBzdXBwbGVtZW50cycpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignKiBleHRlbnNpb25zIGxvb3AnLCBpLCB0aGlzLnN1cHBsZW1lbnRzW2ldLCB0aGlzLnN1cHBsZW1lbnRzW2ldLl9kZWNvZGUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdXBwbGVtZW50c1tpXS5fZGVjb2RlKHRoaXMuX3Jvdywgc3RhcnRJbmZvLmVuZCk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZSByZXN1bHQ9JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiByZXN1bHQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiByZXN1bHQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQuZGVjb2RlZENvZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLnN1cHBsZW1lbnRzW2ldLkZPUk1BVCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCcqIGRlY29kZUV4dGVuc2lvbnMgZXJyb3IgaW4gJywgdGhpcy5zdXBwbGVtZW50c1tpXSwgJzogJywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignKiBlbmQgZGVjb2RlRXh0ZW5zaW9ucycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogZGVjb2RlJywgcm93KTtcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZScsIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PG51bWJlcj4oKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gbmV3IEFycmF5PEJhcmNvZGVJbmZvIHwgQmFyY29kZVBvc2l0aW9uPigpO1xuICAgICAgICBsZXQgcmVzdWx0SW5mbzogQmFyY29kZSB8IHt9ID0ge307XG4gICAgICAgIGxldCBzdGFydEluZm8gPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZTogQmFyY29kZVBvc2l0aW9uIHwgQmFyY29kZUluZm8gfCBudWxsID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5mby5zdGFydCxcbiAgICAgICAgICAgIGVuZDogc3RhcnRJbmZvLmVuZFxuICAgICAgICB9O1xuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlUGF5bG9hZChjb2RlLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSB0aGlzLl9maW5kRW5kKGNvZGUuZW5kLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuXG4gICAgICAgIC8vIENoZWNrc3VtXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tzdW0ocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJyogdGhpcy5zdXBwbGVtZW50cz0nLCB0aGlzLnN1cHBsZW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcGxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc3VwcGxlbWVudCA9IHRoaXMuX2RlY29kZUV4dGVuc2lvbnMoY29kZS5lbmQpO1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCcqIGRlY29kZUV4dGVuc2lvbnMgcmV0dXJucycsIHN1cHBsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFzdXBwbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3VwcGxlbWVudC5kZWNvZGVkQ29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdENvZGUgPSBzdXBwbGVtZW50LmRlY29kZWRDb2Rlc1tzdXBwbGVtZW50LmRlY29kZWRDb2Rlcy5sZW5ndGggLSAxXSBhcyBCYXJjb2RlSW5mbztcbiAgICAgICAgICAgIGNvbnN0IGVuZEluZm8gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGxhc3RDb2RlLnN0YXJ0ICsgKCgobGFzdENvZGUuZW5kIC0gbGFzdENvZGUuc3RhcnQpIC8gMikgfCAwKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGxhc3RDb2RlLmVuZFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0SW5mbyA9IHtcbiAgICAgICAgICAgICAgICBzdXBwbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSArIHN1cHBsZW1lbnQuY29kZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb2RlLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIC4uLnJlc3VsdEluZm8sXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOUmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgQXJyYXlIZWxwZXIgZnJvbSAnLi4vY29tbW9uL2FycmF5X2hlbHBlcic7XG5cbmNvbnN0IEFMUEhBQkVUSF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gKiQvKyUnO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgwMzQsIDB4MTIxLCAweDA2MSwgMHgxNjAsIDB4MDMxLCAweDEzMCwgMHgwNzAsIDB4MDI1LCAweDEyNCwgMHgwNjQsIDB4MTA5LCAweDA0OSxcbiAgICAweDE0OCwgMHgwMTksIDB4MTE4LCAweDA1OCwgMHgwMEQsIDB4MTBDLCAweDA0QywgMHgwMUMsIDB4MTAzLCAweDA0MywgMHgxNDIsIDB4MDEzLCAweDExMiwgMHgwNTIsIDB4MDA3LCAweDEwNixcbiAgICAweDA0NiwgMHgwMTYsIDB4MTgxLCAweDBDMSwgMHgxQzAsIDB4MDkxLCAweDE5MCwgMHgwRDAsIDB4MDg1LCAweDE4NCwgMHgwQzQsIDB4MDk0LCAweDBBOCwgMHgwQTIsIDB4MDhBLCAweDAyQSxcbl0pO1xuY29uc3QgQVNURVJJU0sgPSAweDA5NDtcblxuY2xhc3MgQ29kZTM5UmVhZGVyIGV4dGVuZHMgQmFyY29kZVJlYWRlciB7XG4gICAgRk9STUFUID0gJ2NvZGVfMzknO1xuXG4gICAgX2ZpbmRTdGFydCgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBsZXQgcGF0dGVyblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCBjb3VudGVyUG9zID0gMDtcbiAgICAgICAgbGV0IGlzV2hpdGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBzdGFydCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b1BhdHRlcm4oY291bnRlcikgPT09IEFTVEVSSVNLKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aGl0ZVNwYWNlTXVzdFN0YXJ0ID0gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gNCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKHdoaXRlU3BhY2VNdXN0U3RhcnQsIHBhdHRlcm5TdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcGF0dGVyblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyWzBdICsgY291bnRlclsxXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzddID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcls4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MtLTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3RvUGF0dGVybihjb3VudGVyczogVWludDE2QXJyYXkpIHtcbiAgICAgICAgY29uc3QgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXhOYXJyb3dXaWR0aCA9IDA7XG4gICAgICAgIGxldCBudW1XaWRlQmFycyA9IG51bUNvdW50ZXJzO1xuICAgICAgICBsZXQgd2lkZUJhcldpZHRoID0gMDtcblxuICAgICAgICB3aGlsZSAobnVtV2lkZUJhcnMgPiAzKSB7XG4gICAgICAgICAgICBtYXhOYXJyb3dXaWR0aCA9IHRoaXMuX2ZpbmROZXh0V2lkdGgoY291bnRlcnMsIG1heE5hcnJvd1dpZHRoKTtcbiAgICAgICAgICAgIG51bVdpZGVCYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc1tpXSA+IG1heE5hcnJvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gfD0gMSA8PCAobnVtQ291bnRlcnMgLSAxIC0gaSk7XG4gICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzKys7XG4gICAgICAgICAgICAgICAgICAgIHdpZGVCYXJXaWR0aCArPSBjb3VudGVyc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1XaWRlQmFycyA9PT0gMykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnMgJiYgbnVtV2lkZUJhcnMgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzW2ldID4gbWF4TmFycm93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVdpZGVCYXJzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXJzW2ldICogMikgPj0gd2lkZUJhcldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuXG4gICAgX2ZpbmROZXh0V2lkdGgoY291bnRlcnM6IFVpbnQxNkFycmF5LCBjdXJyZW50OiBudW1iZXIpIHtcbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY291bnRlcnNbaV0gPCBtaW5XaWR0aCAmJiBjb3VudGVyc1tpXSA+IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCA9IGNvdW50ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbldpZHRoO1xuICAgIH07XG5cbiAgICBfcGF0dGVyblRvQ2hhcihwYXR0ZXJuOiBudW1iZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDSEFSQUNURVJfRU5DT0RJTkdTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQ0hBUkFDVEVSX0VOQ09ESU5HU1tpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKEFMUEhBQkVUW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShsYXN0U3RhcnQ6IG51bWJlciwgbmV4dFN0YXJ0OiBudW1iZXIsIGNvdW50ZXJzOiBVaW50MTZBcnJheSkge1xuICAgICAgICBjb25zdCBwYXR0ZXJuU2l6ZSA9IEFycmF5SGVscGVyLnN1bShjb3VudGVycyk7XG5cbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gcGF0dGVyblNpemU7XG4gICAgICAgIGlmICgodHJhaWxpbmdXaGl0ZXNwYWNlRW5kICogMykgPj0gcGF0dGVyblNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGxldCBjb3VudGVycyA9IG5ldyBVaW50MTZBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcblxuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIHN0YXJ0LmVuZCk7XG5cbiAgICAgICAgbGV0IGRlY29kZWRDaGFyO1xuICAgICAgICBsZXQgbGFzdFN0YXJ0OiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvdW50ZXJzID0gdGhpcy5fdG9Db3VudGVycyhuZXh0U3RhcnQsIGNvdW50ZXJzKSBhcyBVaW50MTZBcnJheTtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4oY291bnRlcnMpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ2hhciA9IHRoaXMuX3BhdHRlcm5Ub0NoYXIocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoZGVjb2RlZENoYXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgIGxhc3RTdGFydCA9IG5leHRTdGFydDtcbiAgICAgICAgICAgIG5leHRTdGFydCArPSBBcnJheUhlbHBlci5zdW0oY291bnRlcnMpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3csIG5leHRTdGFydCk7XG4gICAgICAgIH0gd2hpbGUgKGRlY29kZWRDaGFyICE9PSAnKicpO1xuICAgICAgICByZXN1bHQucG9wKCk7XG5cbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGxhc3RTdGFydCwgbmV4dFN0YXJ0LCBjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogbmV4dFN0YXJ0LFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCxcbiAgICAgICAgfTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29kZTM5UmVhZGVyO1xuIiwiaW1wb3J0IENvZGUzOVJlYWRlciBmcm9tICcuL2NvZGVfMzlfcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBwYXR0ZXJucyA9IHtcbiAgICBJT1E6IC9bSU9RXS9nLFxuICAgIEFaMDk6IC9bQS1aMC05XXsxN30vLFxufTtcblxuY2xhc3MgQ29kZTM5VklOUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zOV92aW4nO1xuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIC8vIENyaWJiZWQgZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20venhpbmcvenhpbmcvYmxvYi9tYXN0ZXIvY29yZS9zcmMvbWFpbi9qYXZhL2NvbS9nb29nbGUvenhpbmcvY2xpZW50L3Jlc3VsdC9WSU5SZXN1bHRQYXJzZXIuamF2YVxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuSU9RLCAnJyk7XG5cbiAgICAgICAgaWYgKCFjb2RlLm1hdGNoKHBhdHRlcm5zLkFaMDkpKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCBBWjA5IHBhdHRlcm4gY29kZTonLCBjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jaGVja0NoZWNrc3VtKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlMzlWSU5SZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlLCBCYXJjb2RlUG9zaXRpb24gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuLy8gY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5LSQ6Ly4rQUJDRCc7XG5jb25zdCBBTFBIQUJFVCA9IFs0OCwgNDksIDUwLCA1MSwgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNDUsIDM2LCA1OCwgNDcsIDQ2LCA0MywgNjUsIDY2LCA2NywgNjhdO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9XG4gICAgWzB4MDAzLCAweDAwNiwgMHgwMDksIDB4MDYwLCAweDAxMiwgMHgwNDIsIDB4MDIxLCAweDAyNCwgMHgwMzAsIDB4MDQ4LCAweDAwYywgMHgwMTgsXG4gICAgICAgIDB4MDQ1LCAweDA1MSwgMHgwNTQsIDB4MDE1LCAweDAxQSwgMHgwMjksIDB4MDBCLCAweDAwRV07XG5jb25zdCBTVEFSVF9FTkQgPSBbMHgwMUEsIDB4MDI5LCAweDAwQiwgMHgwMEVdO1xuY29uc3QgTUlOX0VOQ09ERURfQ0hBUlMgPSA0O1xuY29uc3QgTUFYX0FDQ0VQVEFCTEUgPSAyLjA7XG5jb25zdCBQQURESU5HID0gMS41O1xuXG5pbnRlcmZhY2UgVGhyZXNob2xkU2l6ZSB7XG4gICAgc2l6ZTogbnVtYmVyLFxuICAgIGNvdW50czogbnVtYmVyLFxuICAgIG1pbjogbnVtYmVyLFxuICAgIG1heDogbnVtYmVyLFxufTtcblxuaW50ZXJmYWNlIFRocmVzaG9sZCB7XG4gICAgc3BhY2U6IHtcbiAgICAgICAgbmFycm93OiBUaHJlc2hvbGRTaXplLFxuICAgICAgICB3aWRlOiBUaHJlc2hvbGRTaXplLFxuICAgIH0sXG4gICAgYmFyOiB7XG4gICAgICAgIG5hcnJvdzogVGhyZXNob2xkU2l6ZSxcbiAgICAgICAgd2lkZTogVGhyZXNob2xkU2l6ZSxcbiAgICB9LFxufTtcblxuY2xhc3MgTmV3Q29kYWJhclJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIF9jb3VudGVyczogQXJyYXk8bnVtYmVyPiA9IFtdO1xuICAgIEZPUk1BVCA9ICdjb2RhYmFyJztcblxuICAgIF9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBlbmQ7IGkgKz0gMikge1xuICAgICAgICAgICAgY291bnRlciA9IHRoaXMuX2NvdW50ZXJzW2ldO1xuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBjb3VudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgobWluICsgbWF4KSAvIDIuMCkgfCAwO1xuICAgIH07XG5cbiAgICBfdG9QYXR0ZXJuKG9mZnNldDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gNztcbiAgICAgICAgY29uc3QgZW5kID0gb2Zmc2V0ICsgbnVtQ291bnRlcnM7XG5cbiAgICAgICAgaWYgKGVuZCA+IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmFyVGhyZXNob2xkID0gdGhpcy5fY29tcHV0ZUFsdGVybmF0aW5nVGhyZXNob2xkKG9mZnNldCwgZW5kKTtcbiAgICAgICAgY29uc3Qgc3BhY2VUaHJlc2hvbGQgPSB0aGlzLl9jb21wdXRlQWx0ZXJuYXRpbmdUaHJlc2hvbGQob2Zmc2V0ICsgMSwgZW5kKTtcblxuICAgICAgICBsZXQgYml0bWFzayA9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSk7XG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xuICAgICAgICBsZXQgcGF0dGVybiA9IDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGQgPSAoaSAmIDEpID09PSAwID8gYmFyVGhyZXNob2xkIDogc3BhY2VUaHJlc2hvbGQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fY291bnRlcnNbb2Zmc2V0ICsgaV0gPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IGJpdG1hc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaXRtYXNrID4+PSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIF9pc1N0YXJ0RW5kKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFNUQVJUX0VORC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKFNUQVJUX0VORFtpXSA9PT0gcGF0dGVybikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3N1bUNvdW50ZXJzKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9O1xuXG4gICAgX2ZpbmRTdGFydCgpOiBCYXJjb2RlUG9zaXRpb24gfCBudWxsIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGkpO1xuICAgICAgICAgICAgaWYgKHBhdHRlcm4gIT09IC0xICYmIHRoaXMuX2lzU3RhcnRFbmQocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBMb29rIGZvciB3aGl0ZXNwYWNlIGFoZWFkXG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gdGhpcy5fc3VtQ291bnRlcnMoMCwgaSk7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnQgKyB0aGlzLl9zdW1Db3VudGVycyhpLCBpICsgOCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudGVyOiBpLFxuICAgICAgICAgICAgICAgICAgICBlbmRDb3VudGVyOiBpICsgOCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9wYXR0ZXJuVG9DaGFyKHBhdHRlcm46IG51bWJlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENIQVJBQ1RFUl9FTkNPRElOR1MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChDSEFSQUNURVJfRU5DT0RJTkdTW2ldID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoQUxQSEFCRVRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfY2FsY3VsYXRlUGF0dGVybkxlbmd0aChvZmZzZXQ6IG51bWJlcikge1xuICAgICAgICBsZXQgc3VtID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNzsgaSsrKSB7XG4gICAgICAgICAgICBzdW0gKz0gdGhpcy5fY291bnRlcnNbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5V2hpdGVzcGFjZShzdGFydENvdW50ZXI6IG51bWJlciwgZW5kQ291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGlmICgoc3RhcnRDb3VudGVyIC0gMSA8PSAwKVxuICAgICAgICAgICAgfHwgdGhpcy5fY291bnRlcnNbc3RhcnRDb3VudGVyIC0gMV0gPj0gKHRoaXMuX2NhbGN1bGF0ZVBhdHRlcm5MZW5ndGgoc3RhcnRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgIGlmICgoZW5kQ291bnRlciArIDggPj0gdGhpcy5fY291bnRlcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2NvdW50ZXJzW2VuZENvdW50ZXIgKyA3XSA+PSAodGhpcy5fY2FsY3VsYXRlUGF0dGVybkxlbmd0aChlbmRDb3VudGVyKSAvIDIuMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jaGFyVG9QYXR0ZXJuKGNoYXI6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGNoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoQUxQSEFCRVRbaV0gPT09IGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENIQVJBQ1RFUl9FTkNPRElOR1NbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDB4MDtcbiAgICB9O1xuXG4gICAgX3RocmVzaG9sZFJlc3VsdFBhdHRlcm4ocmVzdWx0OiBSZWFkb25seUFycmF5PHN0cmluZz4sIHN0YXJ0Q291bnRlcjogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGNhdGVnb3JpemF0aW9uOiBUaHJlc2hvbGQgPSB7XG4gICAgICAgICAgICAgICAgc3BhY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiYXI6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFycm93OiB7IHNpemU6IDAsIGNvdW50czogMCwgbWluOiAwLCBtYXg6IE51bWJlci5NQVhfVkFMVUUgfSxcbiAgICAgICAgICAgICAgICAgICAgd2lkZTogeyBzaXplOiAwLCBjb3VudHM6IDAsIG1pbjogMCwgbWF4OiBOdW1iZXIuTUFYX1ZBTFVFIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMiA/IGNhdGVnb3JpemF0aW9uLmJhciA6IGNhdGVnb3JpemF0aW9uLnNwYWNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdCA9IChwYXR0ZXJuICYgMSkgPT09IDEgPyBraW5kLndpZGUgOiBraW5kLm5hcnJvdztcbiAgICAgICAgICAgICAgICBjYXQuc2l6ZSArPSB0aGlzLl9jb3VudGVyc1twb3MgKyBqXTtcbiAgICAgICAgICAgICAgICBjYXQuY291bnRzKys7XG4gICAgICAgICAgICAgICAgcGF0dGVybiA+Pj0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgKFsnc3BhY2UnLCAnYmFyJ10gYXMgY29uc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29uc3QgbmV3a2luZCA9IGNhdGVnb3JpemF0aW9uW2tleV07XG4gICAgICAgICAgICBuZXdraW5kLndpZGUubWluID1cbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKChuZXdraW5kLm5hcnJvdy5zaXplIC8gbmV3a2luZC5uYXJyb3cuY291bnRzICsgbmV3a2luZC53aWRlLnNpemUgLyBuZXdraW5kLndpZGUuY291bnRzKSAvIDIpO1xuICAgICAgICAgICAgbmV3a2luZC5uYXJyb3cubWF4ID0gTWF0aC5jZWlsKG5ld2tpbmQud2lkZS5taW4pO1xuICAgICAgICAgICAgbmV3a2luZC53aWRlLm1heCA9IE1hdGguY2VpbCgobmV3a2luZC53aWRlLnNpemUgKiBNQVhfQUNDRVBUQUJMRSArIFBBRERJTkcpIC8gbmV3a2luZC53aWRlLmNvdW50cyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjYXRlZ29yaXphdGlvbjtcbiAgICB9O1xuXG4gICAgX3ZhbGlkYXRlUmVzdWx0KHJlc3VsdDogUmVhZG9ubHlBcnJheTxzdHJpbmc+LCBzdGFydENvdW50ZXI6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkUmVzdWx0UGF0dGVybihyZXN1bHQsIHN0YXJ0Q291bnRlcik7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydENvdW50ZXI7XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl9jaGFyVG9QYXR0ZXJuKHJlc3VsdFtpXSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gNjsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gKGogJiAxKSA9PT0gMCA/IHRocmVzaG9sZHMuYmFyIDogdGhyZXNob2xkcy5zcGFjZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXQgPSAocGF0dGVybiAmIDEpID09PSAxID8ga2luZC53aWRlIDoga2luZC5uYXJyb3c7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2NvdW50ZXJzW3BvcyArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChzaXplIDwgY2F0Lm1pbiB8fCBzaXplID4gY2F0Lm1heCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPj49IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG5cbiAgICAgICAgdGhpcy5fY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoKTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLl9maW5kU3RhcnQoKTtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRTdGFydCA9IHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXI7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuOiBudW1iZXI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLl90b1BhdHRlcm4obmV4dFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gODtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMSAmJiB0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5leHRTdGFydCA8IHRoaXMuX2NvdW50ZXJzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gdmVyaWZ5IGVuZFxuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggLSAyKSA8IE1JTl9FTkNPREVEX0NIQVJTIHx8ICF0aGlzLl9pc1N0YXJ0RW5kKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSBlbmQgd2hpdGUgc3BhY2VcbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlXaGl0ZXNwYWNlKHN0YXJ0LnN0YXJ0Q291bnRlciBhcyBudW1iZXIsIG5leHRTdGFydCAtIDgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fdmFsaWRhdGVSZXN1bHQocmVzdWx0LCBzdGFydC5zdGFydENvdW50ZXIgYXMgbnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0U3RhcnQgPSBuZXh0U3RhcnQgPiB0aGlzLl9jb3VudGVycy5sZW5ndGggPyB0aGlzLl9jb3VudGVycy5sZW5ndGggOiBuZXh0U3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0LnN0YXJ0ICsgdGhpcy5fc3VtQ291bnRlcnMoc3RhcnQuc3RhcnRDb3VudGVyIGFzIG51bWJlciwgbmV4dFN0YXJ0IC0gOCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3VsdC5qb2luKCcnKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydC5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydCxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlczogcmVzdWx0LFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLkZPUk1BVCwgLy8gVE9ETzogaSB0aGluayBpdCBzaG91bGQgbm90IGJlIHJlcXVpcmVkIHRvIHJldHVybiBmb3JtYXQgZnJvbSB0aGlzLCBhcyBiYXJjb2RlX3JlYWRlciBmb3JjZSBzZXRzIHRoZSBmb3JtYXQgYW55d2F5XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTmV3Q29kYWJhclJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIgZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICd1cGNfYSc7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRUFOUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29kZSAmJiByZXN1bHQuY29kZS5sZW5ndGggPT09IDEzICYmIHJlc3VsdC5jb2RlLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IHJlc3VsdC5jb2RlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVUENSZWFkZXI7XG4iLCJpbXBvcnQgRUFOUmVhZGVyLCB7IENPREVfR19TVEFSVCwgTUlERExFX1BBVFRFUk4gfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBFQU44UmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzgnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0gaW5Db2RlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShjb2RlLmVuZCwgQ09ERV9HX1NUQVJUKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlID0gdGhpcy5fZmluZFBhdHRlcm4oTUlERExFX1BBVFRFUk4sIGNvZGUuZW5kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIGlmIChjb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUoY29kZS5lbmQsIENPREVfR19TVEFSVCk7XG4gICAgICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGUpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGNvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGUgYXMgQmFyY29kZUluZm87XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRUFOOFJlYWRlcjtcbiIsImltcG9ydCBFQU5SZWFkZXIsIHsgQ09ERV9HX1NUQVJUIH0gZnJvbSAnLi9lYW5fcmVhZGVyJztcbmltcG9ydCB7IEJhcmNvZGVQb3NpdGlvbiwgQmFyY29kZSwgQmFyY29kZUluZm8gfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcblxuXG5jbGFzcyBFQU4yUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnZWFuXzInO1xuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBudW1iZXIpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdyA9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlRnJlcXVlbmN5ID0gMDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9yb3cubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMiAmJiBvZmZzZXQgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuX2RlY29kZUNvZGUob2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goY29kZSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlLmNvZGUgJSAxMCk7XG4gICAgICAgICAgICBpZiAoY29kZS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIGNvZGVGcmVxdWVuY3kgfD0gMSA8PCAoMSAtIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3JvdywgY29kZS5lbmQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRVbnNldCh0aGlzLl9yb3csIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCAocGFyc2VJbnQocmVzdWx0LmpvaW4oJycpKSAlIDQpICE9PSBjb2RlRnJlcXVlbmN5KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU4yUmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZSwgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBDSEVDS19ESUdJVF9FTkNPRElOR1MgPSBbMjQsIDIwLCAxOCwgMTcsIDEyLCA2LCAzLCAxMCwgOSwgNV07XG5cbmZ1bmN0aW9uIGRldGVybWluZUNoZWNrRGlnaXQoY29kZUZyZXF1ZW5jeTogbnVtYmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlRnJlcXVlbmN5ID09PSBDSEVDS19ESUdJVF9FTkNPRElOR1NbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBleHRlbnNpb25DaGVja3N1bShyZXN1bHQ6IEFycmF5PG51bWJlcj4pIHtcbiAgICBjb25zdCBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIHN1bSArPSByZXN1bHRbaV07XG4gICAgfVxuICAgIHN1bSAqPSAzO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgICAgICBzdW0gKz0gcmVzdWx0W2ldO1xuICAgIH1cbiAgICBzdW0gKj0gMztcbiAgICByZXR1cm4gc3VtICUgMTA7XG59XG5cbmNsYXNzIEVBTjVSZWFkZXIgZXh0ZW5kcyBFQU5SZWFkZXIge1xuICAgIEZPUk1BVCA9ICdlYW5fNSc7XG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IG51bWJlcik6IEJhcmNvZGUgfCBudWxsIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgdGhpcy5fcm93ID0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAwO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3Jvdy5sZW5ndGg7XG4gICAgICAgIGxldCBjb2RlOiBCYXJjb2RlSW5mbyB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgY29uc3QgZGVjb2RlZENvZGVzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1ICYmIG9mZnNldCA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5fZGVjb2RlQ29kZShvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvZGUuY29kZSAlIDEwKTtcbiAgICAgICAgICAgIGlmIChjb2RlLmNvZGUgPj0gQ09ERV9HX1NUQVJUKSB7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAxIDw8ICg0IC0gaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBjb2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFVuc2V0KHRoaXMuX3Jvdywgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoICE9PSA1KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb25DaGVja3N1bShyZXN1bHQpICE9PSBkZXRlcm1pbmVDaGVja0RpZ2l0KGNvZGVGcmVxdWVuY3kpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBlbmQ6IChjb2RlIGFzIEJhcmNvZGVJbmZvKS5lbmQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICAgICAgc3RhcnRJbmZvOiBzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uLFxuICAgICAgICAgICAgc3RhcnQ6IChzdGFydEluZm8gYXMgQmFyY29kZVBvc2l0aW9uKS5zdGFydCxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFQU41UmVhZGVyO1xuIiwiaW1wb3J0IEVBTlJlYWRlciwgeyBDT0RFX0dfU1RBUlQgfSBmcm9tICcuL2Vhbl9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlSW5mbyB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jbGFzcyBVUENFUmVhZGVyIGV4dGVuZHMgRUFOUmVhZGVyIHtcbiAgICBDT0RFX0ZSRVFVRU5DWSA9IFtcbiAgICAgICAgWyA1NiwgNTIsIDUwLCA0OSwgNDQsIDM4LCAzNSwgNDIsIDQxLCAzNyBdLFxuICAgICAgICBbNywgMTEsIDEzLCAxNCwgMTksIDI1LCAyOCwgMjEsIDIyLCAyNl1dO1xuICAgIFNUT1BfUEFUVEVSTiA9IFsxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3LCAxIC8gNiAqIDcsIDEgLyA2ICogNywgMSAvIDYgKiA3XTtcbiAgICBGT1JNQVQgPSAndXBjX2UnO1xuICAgIHByb3RlY3RlZCBfZGVjb2RlUGF5bG9hZChpbkNvZGU6IEJhcmNvZGVQb3NpdGlvbiwgcmVzdWx0OiBBcnJheTxudW1iZXI+LCBkZWNvZGVkQ29kZXM6IEFycmF5PEJhcmNvZGVQb3NpdGlvbj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBsZXQgb3V0Q29kZTogQmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24gfCBudWxsID0geyAuLi5pbkNvZGUgfTtcbiAgICAgICAgbGV0IGNvZGVGcmVxdWVuY3kgPSAweDA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgIG91dENvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKG91dENvZGUuZW5kKTtcbiAgICAgICAgICAgIGlmICghb3V0Q29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID49IENPREVfR19TVEFSVCkge1xuICAgICAgICAgICAgICAgIChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlID0gKG91dENvZGUgYXMgQmFyY29kZUluZm8pLmNvZGUgLSBDT0RFX0dfU1RBUlQ7XG4gICAgICAgICAgICAgICAgY29kZUZyZXF1ZW5jeSB8PSAoMSA8PCAoNSAtIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChvdXRDb2RlIGFzIEJhcmNvZGVJbmZvKS5jb2RlKTtcbiAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKG91dENvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3ksIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRDb2RlIGFzIEJhcmNvZGVJbmZvO1xuICAgIH07XG5cbiAgICBfZGV0ZXJtaW5lUGFyaXR5KGNvZGVGcmVxdWVuY3k6IG51bWJlciwgcmVzdWx0OiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGZvciAobGV0IG5yU3lzdGVtID0gMDsgbnJTeXN0ZW0gPCB0aGlzLkNPREVfRlJFUVVFTkNZLmxlbmd0aDsgbnJTeXN0ZW0rKyl7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGVGcmVxdWVuY3kgPT09IHRoaXMuQ09ERV9GUkVRVUVOQ1lbbnJTeXN0ZW1dW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KG5yU3lzdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9jb252ZXJ0VG9VUENBKHJlc3VsdDogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICBsZXQgdXBjYSA9IFtyZXN1bHRbMF1dO1xuICAgICAgICBjb25zdCBsYXN0RGlnaXQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDJdO1xuXG4gICAgICAgIGlmIChsYXN0RGlnaXQgPD0gMikge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCAzKSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFtsYXN0RGlnaXQsIDAsIDAsIDAsIDBdKVxuICAgICAgICAgICAgICAgIC5jb25jYXQocmVzdWx0LnNsaWNlKDMsIDYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXN0RGlnaXQgPT09IDMpIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNCkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgMF0pXG4gICAgICAgICAgICAgICAgLmNvbmNhdChyZXN1bHQuc2xpY2UoNCwgNikpO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3REaWdpdCA9PT0gNCkge1xuICAgICAgICAgICAgdXBjYSA9IHVwY2EuY29uY2F0KHJlc3VsdC5zbGljZSgxLCA1KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KFswLCAwLCAwLCAwLCAwLCByZXN1bHRbNV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwY2EgPSB1cGNhLmNvbmNhdChyZXN1bHQuc2xpY2UoMSwgNikpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChbMCwgMCwgMCwgMCwgbGFzdERpZ2l0XSk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGNhLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiB1cGNhO1xuICAgIH07XG5cbiAgICBwcm90ZWN0ZWQgX2NoZWNrc3VtKHJlc3VsdDogQXJyYXk8bnVtYmVyPik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gc3VwZXIuX2NoZWNrc3VtKHRoaXMuX2NvbnZlcnRUb1VQQ0EocmVzdWx0KSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9maW5kRW5kKG9mZnNldDogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuKTogQmFyY29kZVBvc2l0aW9uIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiBzdXBlci5fZmluZEVuZChvZmZzZXQsIHRydWUpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVQb3NpdGlvbik6IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwge1xuICAgICAgICBjb25zdCB0cmFpbGluZ1doaXRlc3BhY2VFbmQgPSBlbmRJbmZvLmVuZCArICgoZW5kSW5mby5lbmQgLSBlbmRJbmZvLnN0YXJ0KSAvIDIpO1xuICAgICAgICBpZiAodHJhaWxpbmdXaGl0ZXNwYWNlRW5kIDwgdGhpcy5fcm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2UoZW5kSW5mby5lbmQsIHRyYWlsaW5nV2hpdGVzcGFjZUVuZCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBVUENFUmVhZGVyO1xuIiwiLy8gVE9ETzogaTJvZjVfcmVhZGVyIGFuZCAyb2Y1X3JlYWRlciBzaGFyZSB2ZXJ5IHNpbWlsYXIgY29kZSwgbWFrZSB1c2Ugb2YgdGhhdFxuXG5pbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUmVhZGVyQ29uZmlnLCBCYXJjb2RlSW5mbywgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQge21lcmdlfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuXG5jbGFzcyBJMm9mNVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG4gICAgU0lOR0xFX0NPREVfRVJST1IgPSAwLjc4O1xuICAgIEFWR19DT0RFX0VSUk9SID0gMC4zODtcblxuICAgIFNUQVJUX1BBVFRFUk4gPSBbTiwgTiwgTiwgTl07XG4gICAgU1RPUF9QQVRURVJOID0gW04sIE4sIFddO1xuICAgIENPREVfUEFUVEVSTiA9IFtcbiAgICAgICAgW04sIE4sIFcsIFcsIE5dLFxuICAgICAgICBbVywgTiwgTiwgTiwgV10sXG4gICAgICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICAgICAgW1csIFcsIE4sIE4sIE5dLFxuICAgICAgICBbTiwgTiwgVywgTiwgV10sXG4gICAgICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICAgICAgW04sIFcsIFcsIE4sIE5dLFxuICAgICAgICBbTiwgTiwgTiwgVywgV10sXG4gICAgICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICAgICAgW04sIFcsIE4sIFcsIE5dLFxuICAgIF07XG4gICAgTUFYX0NPUlJFQ1RJT05fRkFDVE9SID0gNTtcbiAgICBGT1JNQVQgPSAnaTJvZjUnO1xuXG4gICAgY29uc3RydWN0b3Iob3B0czogQmFyY29kZVJlYWRlckNvbmZpZykge1xuICAgICAgICBzdXBlcihtZXJnZSh7IG5vcm1hbGl6ZUJhclNwYWNlV2lkdGg6IGZhbHNlIH0sIG9wdHMpKTtcbiAgICAgICAgaWYgKG9wdHMubm9ybWFsaXplQmFyU3BhY2VXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5TSU5HTEVfQ09ERV9FUlJPUiA9IDAuMzg7XG4gICAgICAgICAgICB0aGlzLkFWR19DT0RFX0VSUk9SID0gMC4wOTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IG9wdHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9tYXRjaFBhdHRlcm4oY291bnRlcjogQXJyYXk8bnVtYmVyPiwgY29kZTogUmVhZG9ubHlBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5ub3JtYWxpemVCYXJTcGFjZVdpZHRoKSB7XG4gICAgICAgICAgICBjb25zdCBjb3VudGVyU3VtID0gWzAsIDBdO1xuICAgICAgICAgICAgY29uc3QgY29kZVN1bSA9IFswLCAwXTtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb24gPSBbMCwgMF07XG4gICAgICAgICAgICBjb25zdCBjb3JyZWN0aW9uUmF0aW8gPSB0aGlzLk1BWF9DT1JSRUNUSU9OX0ZBQ1RPUjtcbiAgICAgICAgICAgIGNvbnN0IGNvcnJlY3Rpb25SYXRpb0ludmVyc2UgPSAxIC8gY29ycmVjdGlvblJhdGlvO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyU3VtW2kgJSAyXSArPSBjb3VudGVyW2ldO1xuICAgICAgICAgICAgICAgIGNvZGVTdW1baSAlIDJdICs9IGNvZGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzBdID0gY29kZVN1bVswXSAvIGNvdW50ZXJTdW1bMF07XG4gICAgICAgICAgICBjb3JyZWN0aW9uWzFdID0gY29kZVN1bVsxXSAvIGNvdW50ZXJTdW1bMV07XG5cbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMF0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzBdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgICAgIGNvcnJlY3Rpb25bMV0gPSBNYXRoLm1heChNYXRoLm1pbihjb3JyZWN0aW9uWzFdLCBjb3JyZWN0aW9uUmF0aW8pLCBjb3JyZWN0aW9uUmF0aW9JbnZlcnNlKTtcbiAgICAgICAgICAgIHRoaXMuYmFyU3BhY2VSYXRpbyA9IGNvcnJlY3Rpb247XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldICo9IHRoaXMuYmFyU3BhY2VSYXRpb1tpICUgMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJhcmNvZGVSZWFkZXIucHJvdG90eXBlLl9tYXRjaFBhdHRlcm4uY2FsbCh0aGlzLCBjb3VudGVyLCBjb2RlKTtcbiAgICB9O1xuXG4gICAgX2ZpbmRQYXR0ZXJuKHBhdHRlcm46IFJlYWRvbmx5QXJyYXk8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyLCBpc1doaXRlOiBib29sZWFuID0gZmFsc2UsIHRyeUhhcmRlcjogYm9vbGVhbiA9IGZhbHNlKTogQmFyY29kZUluZm8gfCBudWxsIHtcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBBcnJheTxudW1iZXI+KHBhdHRlcm4ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgICBsZXQgY291bnRlclBvcyA9IDA7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpc1doaXRlID0gaXNXaGl0ZSB8fCBmYWxzZTtcbiAgICAgICAgdHJ5SGFyZGVyID0gdHJ5SGFyZGVyIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgdGhpcy5fcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm93W2ldIF4gKGlzV2hpdGUgPyAxIDogMCkpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXJQb3NdKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zID09PSBjb3VudGVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VtID0gY291bnRlci5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgcGF0dGVybik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA8IGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdE1hdGNoLnN0YXJ0ID0gaSAtIHN1bTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ5SGFyZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoIC0gMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyLmxlbmd0aCAtIDJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBsZXQgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBzdGFydEluZm86IEJhcmNvZGVQb3NpdGlvbiB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgbmFycm93QmFyV2lkdGggPSAxO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybih0aGlzLlNUQVJUX1BBVFRFUk4sIG9mZnNldCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFzdGFydEluZm8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hcnJvd0JhcldpZHRoID0gTWF0aC5mbG9vcigoc3RhcnRJbmZvLmVuZCAtIHN0YXJ0SW5mby5zdGFydCkgLyA0KTtcbiAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSBzdGFydEluZm8uc3RhcnQgLSBuYXJyb3dCYXJXaWR0aCAqIDEwO1xuICAgICAgICAgICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQsIHN0YXJ0SW5mby5zdGFydCwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSBzdGFydEluZm8uZW5kO1xuICAgICAgICAgICAgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgX3ZlcmlmeVRyYWlsaW5nV2hpdGVzcGFjZShlbmRJbmZvOiBCYXJjb2RlUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kID0gZW5kSW5mby5lbmQgKyAoKGVuZEluZm8uZW5kIC0gZW5kSW5mby5zdGFydCkgLyAyKTtcbiAgICAgICAgaWYgKHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA8IHRoaXMuX3Jvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tYXRjaFJhbmdlKGVuZEluZm8uZW5kLCB0cmFpbGluZ1doaXRlc3BhY2VFbmQsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZEluZm87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF9maW5kRW5kKCkge1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4odGhpcy5TVE9QX1BBVFRFUk4pO1xuICAgICAgICB0aGlzLl9yb3cucmV2ZXJzZSgpO1xuXG4gICAgICAgIGlmIChlbmRJbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldmVyc2UgbnVtYmVyc1xuICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmZvLnN0YXJ0O1xuICAgICAgICBlbmRJbmZvLnN0YXJ0ID0gdGhpcy5fcm93Lmxlbmd0aCAtIGVuZEluZm8uZW5kO1xuICAgICAgICBlbmRJbmZvLmVuZCA9IHRoaXMuX3Jvdy5sZW5ndGggLSB0bXA7XG5cbiAgICAgICAgcmV0dXJuIGVuZEluZm8gIT09IG51bGwgPyB0aGlzLl92ZXJpZnlUcmFpbGluZ1doaXRlc3BhY2UoZW5kSW5mbykgOiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlUGFpcihjb3VudGVyUGFpcjogQXJyYXk8QXJyYXk8bnVtYmVyPj4pIHtcbiAgICAgICAgY29uc3QgY29kZXM6IEFycmF5PEJhcmNvZGVJbmZvPiA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnRlclBhaXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXJQYWlyW2ldKTtcbiAgICAgICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfTtcblxuICAgIF9kZWNvZGVDb2RlKGNvdW50ZXI6IEFycmF5PG51bWJlcj4pOiBCYXJjb2RlSW5mbyB8IG51bGwge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgY29kZSA9IDA7IGNvZGUgPCB0aGlzLkNPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgdGhpcy5DT0RFX1BBVFRFUk5bY29kZV0pO1xuICAgICAgICAgICAgaWYgKGVycm9yIDwgYmVzdE1hdGNoLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoLmNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiZXN0TWF0Y2guZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8gfCBCYXJjb2RlUG9zaXRpb24+KSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyUGFpciA9IFtbMCwgMCwgMCwgMCwgMF0sIFswLCAwLCAwLCAwLCAwXV07XG4gICAgICAgIGxldCBjb2RlczogQmFyY29kZUluZm9bXSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb3VudGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJQYWlyWzBdW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBjb3VudGVyUGFpclsxXVtpXSA9IGNvdW50ZXJzW3BvcyArIDFdICogdGhpcy5iYXJTcGFjZVJhdGlvWzFdO1xuICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29kZXMgPSB0aGlzLl9kZWNvZGVQYWlyKGNvdW50ZXJQYWlyKTtcbiAgICAgICAgICAgIGlmICghY29kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjb2Rlc1tpXS5jb2RlICsgJycpO1xuICAgICAgICAgICAgICAgIGRlY29kZWRDb2Rlcy5wdXNoKGNvZGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZXM7XG4gICAgfTtcblxuICAgIF92ZXJpZnlDb3VudGVyTGVuZ3RoKGNvdW50ZXJzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgICAgIHJldHVybiAoY291bnRlcnMubGVuZ3RoICUgMTAgPT09IDApO1xuICAgIH07XG5cbiAgICBfZGVjb2RlKHJvdz86IEFycmF5PG51bWJlcj4sIHN0YXJ0PzogQmFyY29kZVBvc2l0aW9uIHwgbnVtYmVyKTogQmFyY29kZSB8IG51bGwge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgICAgICAgdmFyIGRlY29kZWRDb2RlcyA9IG5ldyBBcnJheTxCYXJjb2RlUG9zaXRpb24+KCk7XG5cbiAgICAgICAgY29uc3Qgc3RhcnRJbmZvID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChzdGFydEluZm8pO1xuXG4gICAgICAgIGNvbnN0IGVuZEluZm8gPSB0aGlzLl9maW5kRW5kKCk7XG4gICAgICAgIGlmICghZW5kSW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb3VudGVycyA9IHRoaXMuX2ZpbGxDb3VudGVycyhzdGFydEluZm8uZW5kLCBlbmRJbmZvLnN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLl9kZWNvZGVQYXlsb2FkKGNvdW50ZXJzLCByZXN1bHQsIGRlY29kZWRDb2Rlcyk7XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggJSAyICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmxlbmd0aCA8IDYpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbzogc3RhcnRJbmZvLFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiBkZWNvZGVkQ29kZXMsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEkyb2Y1UmVhZGVyO1xuIiwiaW1wb3J0IEJhcmNvZGVSZWFkZXIsIHsgQmFyY29kZSwgQmFyY29kZUluZm8sIEJhcmNvZGVQb3NpdGlvbiB9IGZyb20gJy4vYmFyY29kZV9yZWFkZXInO1xuXG5jb25zdCBOID0gMTtcbmNvbnN0IFcgPSAzO1xuY29uc3QgU1RBUlRfUEFUVEVSTiA9IFtXLCBOLCBXLCBOLCBOLCBOXTtcbmNvbnN0IFNUT1BfUEFUVEVSTiA9IFtXLCBOLCBOLCBOLCBXXTtcbmNvbnN0IENPREVfUEFUVEVSTiA9IFtcbiAgICBbTiwgTiwgVywgVywgTl0sXG4gICAgW1csIE4sIE4sIE4sIFddLFxuICAgIFtOLCBXLCBOLCBOLCBXXSxcbiAgICBbVywgVywgTiwgTiwgTl0sXG4gICAgW04sIE4sIFcsIE4sIFddLFxuICAgIFtXLCBOLCBXLCBOLCBOXSxcbiAgICBbTiwgVywgVywgTiwgTl0sXG4gICAgW04sIE4sIE4sIFcsIFddLFxuICAgIFtXLCBOLCBOLCBXLCBOXSxcbiAgICBbTiwgVywgTiwgVywgTl0sXG5dO1xuY29uc3QgU1RBUlRfUEFUVEVSTl9MRU5HVEggPSBTVEFSVF9QQVRURVJOLnJlZHVjZSgoc3VtLCB2YWwpID0+IHN1bSArIHZhbCwgMCk7XG5cbmNsYXNzIFR3b09mRml2ZVJlYWRlciBleHRlbmRzIEJhcmNvZGVSZWFkZXIge1xuICAgIGJhclNwYWNlUmF0aW8gPSBbMSwgMV07XG5cbiAgICBGT1JNQVQgPSAnMm9mNSc7XG5cbiAgICBTSU5HTEVfQ09ERV9FUlJPUiA9IDAuNzg7XG5cbiAgICBBVkdfQ09ERV9FUlJPUiA9IDAuMzA7XG5cbiAgICBfZmluZFBhdHRlcm4ocGF0dGVybjogUmVhZG9ubHlBcnJheTxudW1iZXI+LCBvZmZzZXQ6IG51bWJlciwgaXNXaGl0ZSA9IGZhbHNlLCB0cnlIYXJkZXIgPSBmYWxzZSk6IEJhcmNvZGVJbmZvIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBjb25zdCBiZXN0TWF0Y2ggPSB7XG4gICAgICAgICAgICBlcnJvcjogTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAgICAgICAgIGNvZGU6IC0xLFxuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBlbmQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBsZXQgZXJyb3IgPSAwO1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gdGhpcy5BVkdfQ09ERV9FUlJPUjtcblxuICAgICAgICBpZiAoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyW2ldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBjb3VudGVyW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gdGhpcy5fbWF0Y2hQYXR0ZXJuKGNvdW50ZXIsIHBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5zdGFydCA9IGkgLSBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZW5kID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUhhcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudGVyLmxlbmd0aCAtIDI7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbal0gPSBjb3VudGVyW2ogKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlci5sZW5ndGggLSAyXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyW2NvdW50ZXIubGVuZ3RoIC0gMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10gPSAxO1xuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBsZXQgc3RhcnRJbmZvID0gbnVsbDtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93KTtcbiAgICAgICAgbGV0IG5hcnJvd0JhcldpZHRoID0gMTtcbiAgICAgICAgbGV0IGxlYWRpbmdXaGl0ZXNwYWNlU3RhcnQgPSAwO1xuXG4gICAgICAgIHdoaWxlICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICBzdGFydEluZm8gPSB0aGlzLl9maW5kUGF0dGVybihTVEFSVF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghc3RhcnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXJyb3dCYXJXaWR0aCA9IE1hdGguZmxvb3IoKHN0YXJ0SW5mby5lbmQgLSBzdGFydEluZm8uc3RhcnQpIC8gU1RBUlRfUEFUVEVSTl9MRU5HVEgpO1xuICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2VTdGFydCA9IHN0YXJ0SW5mby5zdGFydCAtIG5hcnJvd0JhcldpZHRoICogNTtcbiAgICAgICAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShsZWFkaW5nV2hpdGVzcGFjZVN0YXJ0LCBzdGFydEluZm8uc3RhcnQsIDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGFydEluZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gc3RhcnRJbmZvLmVuZDtcbiAgICAgICAgICAgIHN0YXJ0SW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5mbztcbiAgICB9XG5cbiAgICBfdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm86IEJhcmNvZGVJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nV2hpdGVzcGFjZUVuZCA9IGVuZEluZm8uZW5kICsgKChlbmRJbmZvLmVuZCAtIGVuZEluZm8uc3RhcnQpIC8gMik7XG4gICAgICAgIGlmICh0cmFpbGluZ1doaXRlc3BhY2VFbmQgPCB0aGlzLl9yb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWF0Y2hSYW5nZShlbmRJbmZvLmVuZCwgdHJhaWxpbmdXaGl0ZXNwYWNlRW5kLCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmRJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIF9maW5kRW5kKCkge1xuICAgICAgICAvLyBUT0RPOiByZXZlcnNlLCBmb2xsb3dlZCBieSBzb21lIGNhbGNzLCBmb2xsb3dlZCBieSBhbm90aGVyIHJldmVyc2U/IHJlYWxseT9cbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fbmV4dFNldCh0aGlzLl9yb3cpO1xuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZFBhdHRlcm4oU1RPUF9QQVRURVJOLCBvZmZzZXQsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcm93LnJldmVyc2UoKTtcblxuICAgICAgICBpZiAoZW5kSW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXZlcnNlIG51bWJlcnNcbiAgICAgICAgY29uc3QgdG1wID0gZW5kSW5mby5zdGFydDtcbiAgICAgICAgZW5kSW5mby5zdGFydCA9IHRoaXMuX3Jvdy5sZW5ndGggLSBlbmRJbmZvLmVuZDtcbiAgICAgICAgZW5kSW5mby5lbmQgPSB0aGlzLl9yb3cubGVuZ3RoIC0gdG1wO1xuXG4gICAgICAgIHJldHVybiBlbmRJbmZvICE9PSBudWxsID8gdGhpcy5fdmVyaWZ5VHJhaWxpbmdXaGl0ZXNwYWNlKGVuZEluZm8pIDogbnVsbDtcbiAgICB9XG5cbiAgICBfdmVyaWZ5Q291bnRlckxlbmd0aChjb3VudGVyczogQXJyYXk8bnVtYmVyPikge1xuICAgICAgICByZXR1cm4gKGNvdW50ZXJzLmxlbmd0aCAlIDEwID09PSAwKTtcbiAgICB9XG5cbiAgICBfZGVjb2RlQ29kZShjb3VudGVyOiBSZWFkb25seUFycmF5PG51bWJlcj4pIHtcbiAgICAgICAgY29uc3QgZXBzaWxvbiA9IHRoaXMuQVZHX0NPREVfRVJST1I7XG4gICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IHtcbiAgICAgICAgICAgIGVycm9yOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgY29kZTogLTEsXG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBjb2RlID0gMDsgY29kZSA8IENPREVfUEFUVEVSTi5sZW5ndGg7IGNvZGUrKykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9tYXRjaFBhdHRlcm4oY291bnRlciwgQ09ERV9QQVRURVJOW2NvZGVdKTtcbiAgICAgICAgICAgIGlmIChlcnJvciA8IGJlc3RNYXRjaC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGJlc3RNYXRjaC5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2guZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdE1hdGNoLmVycm9yIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfZGVjb2RlUGF5bG9hZChjb3VudGVyczogUmVhZG9ubHlBcnJheTxudW1iZXI+LCByZXN1bHQ6IEFycmF5PHN0cmluZz4sIGRlY29kZWRDb2RlczogQXJyYXk8QmFyY29kZUluZm8+KSB7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBjb25zdCBjb3VudGVyTGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gWzAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBsZXQgY29kZTogQmFyY29kZUluZm8gfCBudWxsID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgY291bnRlckxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyW2ldID0gY291bnRlcnNbcG9zXSAqIHRoaXMuYmFyU3BhY2VSYXRpb1swXTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLl9kZWNvZGVDb2RlKGNvdW50ZXIpO1xuICAgICAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChgJHtjb2RlLmNvZGV9YCk7XG4gICAgICAgICAgICBkZWNvZGVkQ29kZXMucHVzaChjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG5cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5mbyA9IHRoaXMuX2ZpbmRTdGFydCgpO1xuICAgICAgICBpZiAoIXN0YXJ0SW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbmRJbmZvID0gdGhpcy5fZmluZEVuZCgpO1xuICAgICAgICBpZiAoIWVuZEluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY291bnRlcnMgPSB0aGlzLl9maWxsQ291bnRlcnMoc3RhcnRJbmZvLmVuZCwgZW5kSW5mby5zdGFydCwgZmFsc2UpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUNvdW50ZXJMZW5ndGgoY291bnRlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNvZGVkQ29kZXMgPSBbXTtcbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goc3RhcnRJbmZvKTtcblxuICAgICAgICBjb25zdCByZXN1bHQ6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX2RlY29kZVBheWxvYWQoY291bnRlcnMsIHJlc3VsdCwgZGVjb2RlZENvZGVzKTtcbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVjb2RlZENvZGVzLnB1c2goZW5kSW5mbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiByZXN1bHQuam9pbignJyksXG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmZvLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRJbmZvLmVuZCxcbiAgICAgICAgICAgIHN0YXJ0SW5mbyxcbiAgICAgICAgICAgIGRlY29kZWRDb2RlcyxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5GT1JNQVQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUd29PZkZpdmVSZWFkZXI7XG4iLCJpbXBvcnQgQmFyY29kZVJlYWRlciwgeyBCYXJjb2RlUG9zaXRpb24sIEJhcmNvZGUgfSBmcm9tICcuL2JhcmNvZGVfcmVhZGVyJztcbmltcG9ydCBBcnJheUhlbHBlciBmcm9tICcuLi9jb21tb24vYXJyYXlfaGVscGVyJztcblxuY29uc3QgQUxQSEFCRVRIX1NUUklORyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotLiAkLyslYWJjZConO1xuY29uc3QgQUxQSEFCRVQgPSBuZXcgVWludDE2QXJyYXkoWy4uLkFMUEhBQkVUSF9TVFJJTkddLm1hcChjaGFyID0+IGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuY29uc3QgQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IG5ldyBVaW50MTZBcnJheShbXG4gICAgMHgxMTQsIDB4MTQ4LCAweDE0NCwgMHgxNDIsIDB4MTI4LCAweDEyNCwgMHgxMjIsIDB4MTUwLCAweDExMiwgMHgxMEEsXG4gICAgMHgxQTgsIDB4MUE0LCAweDFBMiwgMHgxOTQsIDB4MTkyLCAweDE4QSwgMHgxNjgsIDB4MTY0LCAweDE2MiwgMHgxMzQsXG4gICAgMHgxMUEsIDB4MTU4LCAweDE0QywgMHgxNDYsIDB4MTJDLCAweDExNiwgMHgxQjQsIDB4MUIyLCAweDFBQywgMHgxQTYsXG4gICAgMHgxOTYsIDB4MTlBLCAweDE2QywgMHgxNjYsIDB4MTM2LCAweDEzQSwgMHgxMkUsIDB4MUQ0LCAweDFEMiwgMHgxQ0EsXG4gICAgMHgxNkUsIDB4MTc2LCAweDFBRSwgMHgxMjYsIDB4MURBLCAweDFENiwgMHgxMzIsIDB4MTVFLFxuXSk7XG5jb25zdCBBU1RFUklTSyA9IDB4MTVFO1xuXG5jbGFzcyBDb2RlOTNSZWFkZXIgZXh0ZW5kcyBCYXJjb2RlUmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV85Myc7XG4gICAgX3BhdHRlcm5Ub0NoYXIocGF0dGVybjogbnVtYmVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKENIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBTFBIQUJFVFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIF90b1BhdHRlcm4oY291bnRlcnM6IFVpbnQxNkFycmF5KSB7XG4gICAgICAgIGNvbnN0IG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdW0gPSBjb3VudGVycy5yZWR1Y2UoKHByZXYsIG5leHQpID0+IHByZXYgKyBuZXh0LCAwKTtcbiAgICAgICAgbGV0IHBhdHRlcm4gPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ291bnRlcnM7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBNYXRoLnJvdW5kKGNvdW50ZXJzW2ldICogOSAvIHN1bSk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZCA8IDEgfHwgbm9ybWFsaXplZCA+IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGkgJiAxKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9ybWFsaXplZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAocGF0dGVybiA8PCAxKSB8IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuIDw8PSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH07XG5cbiAgICBfZmluZFN0YXJ0KCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdyk7XG4gICAgICAgIGxldCBwYXR0ZXJuU3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDE2QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDBdKTtcbiAgICAgICAgbGV0IGNvdW50ZXJQb3MgPSAwO1xuICAgICAgICBsZXQgaXNXaGl0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCB0aGlzLl9yb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yb3dbaV0gXiAoaXNXaGl0ZSA/IDEgOiAwKSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZXJbY291bnRlclBvc10rKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3MgPT09IGNvdW50ZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHN0YXJ0IHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RvUGF0dGVybihjb3VudGVyKSA9PT0gQVNURVJJU0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaXRlU3BhY2VNdXN0U3RhcnQgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtICgoaSAtIHBhdHRlcm5TdGFydCkgLyA0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21hdGNoUmFuZ2Uod2hpdGVTcGFjZU11c3RTdGFydCwgcGF0dGVyblN0YXJ0LCAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwYXR0ZXJuU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJbMF0gKyBjb3VudGVyWzFdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcltqXSA9IGNvdW50ZXJbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJbNF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyWzVdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvcy0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3MrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlcltjb3VudGVyUG9zXSA9IDE7XG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cbiAgICBfdmVyaWZ5RW5kKGxhc3RTdGFydDogbnVtYmVyLCBuZXh0U3RhcnQ6IG51bWJlcikge1xuICAgICAgICBpZiAobGFzdFN0YXJ0ID09PSBuZXh0U3RhcnQgfHwgIXRoaXMuX3Jvd1tuZXh0U3RhcnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIF9kZWNvZGVFeHRlbmRlZChjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4pIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2hhckFycmF5Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmVzdWx0OiBBcnJheTxzdHJpbmc+ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBjaGFyQXJyYXlbaV07XG4gICAgICAgICAgICBpZiAoY2hhciA+PSAnYScgJiYgY2hhciA8PSAnZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IChsZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXIgPSBjaGFyQXJyYXlbKytpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBuZXh0Q2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGxldCBkZWNvZGVkQ2hhcjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dENoYXIgPj0gJ0EnICYmIG5leHRDaGFyIDw9ICdaJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgLSA2NCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnRicgJiYgbmV4dENoYXIgPD0gJ0onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyQ29kZSAtIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dENoYXIgPj0gJ0snICYmIG5leHRDaGFyIDw9ICdPJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhckNvZGUgKyAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID49ICdQJyAmJiBuZXh0Q2hhciA8PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgNDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA+PSAnVCcgJiYgbmV4dENoYXIgPD0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnTycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlIC0gMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2hhciA9PT0gJ1onKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnOic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyID49ICdBJyAmJiBuZXh0Q2hhciA8PSAnWicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXJDb2RlICsgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIGNvZGVfOTNfcmVhZGVyIF9kZWNvZGVFeHRlbmRlZCBoaXQgZGVmYXVsdCBjYXNlLCB0aGlzIG1heSBiZSBhbiBlcnJvcicsIGRlY29kZWRDaGFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIF9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXk6IEFycmF5PHN0cmluZz4sIGluZGV4OiBudW1iZXIsIG1heFdlaWdodDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGFycmF5VG9DaGVjayA9IGNoYXJBcnJheS5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5VG9DaGVjay5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHdlaWdodGVkU3VtcyA9IGFycmF5VG9DaGVjay5yZWR1Y2UoKHN1bSwgY2hhciwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gKCgoaSAqIC0xKSArIChsZW5ndGggLSAxKSkgJSBtYXhXZWlnaHQpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQUxQSEFCRVQuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArICh3ZWlnaHQgKiB2YWx1ZSk7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGNvbnN0IGNoZWNrQ2hhciA9IEFMUEhBQkVUWyh3ZWlnaHRlZFN1bXMgJSA0NyldO1xuICAgICAgICByZXR1cm4gY2hlY2tDaGFyID09PSBjaGFyQXJyYXlbaW5kZXhdLmNoYXJDb2RlQXQoMCk7XG4gICAgfTtcblxuICAgIF92ZXJpZnlDaGVja3N1bXMoY2hhckFycmF5OiBBcnJheTxzdHJpbmc+KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRjaENoZWNrQ2hhcihjaGFyQXJyYXksIGNoYXJBcnJheS5sZW5ndGggLSAyLCAyMClcbiAgICAgICAgICAgICYmIHRoaXMuX21hdGNoQ2hlY2tDaGFyKGNoYXJBcnJheSwgY2hhckFycmF5Lmxlbmd0aCAtIDEsIDE1KTtcbiAgICB9O1xuXG4gICAgX2RlY29kZShyb3c/OiBBcnJheTxudW1iZXI+LCBzdGFydD86IEJhcmNvZGVQb3NpdGlvbiB8IG51bWJlciB8IG51bGwpOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fZmluZFN0YXJ0KCk7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbmV3IFVpbnQxNkFycmF5KFswLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgICAgIGxldCByZXN1bHQ6IEFycmF5PHN0cmluZz4gfCBudWxsID0gW107XG4gICAgICAgIGxldCBuZXh0U3RhcnQgPSB0aGlzLl9uZXh0U2V0KHRoaXMuX3Jvdywgc3RhcnQuZW5kKTtcbiAgICAgICAgbGV0IGxhc3RTdGFydDtcbiAgICAgICAgbGV0IGRlY29kZWRDaGFyOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb3VudGVycyA9IHRoaXMuX3RvQ291bnRlcnMobmV4dFN0YXJ0LCBjb3VudGVycykgYXMgVWludDE2QXJyYXk7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fdG9QYXR0ZXJuKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb2RlZENoYXIgPSB0aGlzLl9wYXR0ZXJuVG9DaGFyKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKGRlY29kZWRDaGFyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkQ2hhcik7XG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gQXJyYXlIZWxwZXIuc3VtKGNvdW50ZXJzKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHRoaXMuX25leHRTZXQodGhpcy5fcm93LCBuZXh0U3RhcnQpO1xuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuXG4gICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3ZlcmlmeUVuZChsYXN0U3RhcnQsIG5leHRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl92ZXJpZnlDaGVja3N1bXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgcmVzdWx0Lmxlbmd0aCAtIDIpO1xuICAgICAgICAvLyB5ZXMsIHRoaXMgaXMgYW4gYXNzaWduIGluc2lkZSBhbiBpZi5cbiAgICAgICAgaWYgKChyZXN1bHQgPSB0aGlzLl9kZWNvZGVFeHRlbmRlZChyZXN1bHQpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogcmVzdWx0LmpvaW4oJycpLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBuZXh0U3RhcnQsXG4gICAgICAgICAgICBzdGFydEluZm86IHN0YXJ0LFxuICAgICAgICAgICAgZGVjb2RlZENvZGVzOiByZXN1bHQsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuRk9STUFULFxuICAgICAgICB9O1xuXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb2RlOTNSZWFkZXI7XG4iLCJpbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4vY29kZV8zOV9yZWFkZXInO1xuaW1wb3J0IHsgQmFyY29kZVBvc2l0aW9uLCBCYXJjb2RlIH0gZnJvbSAnLi9iYXJjb2RlX3JlYWRlcic7XG5cbmNvbnN0IHBhdHRlcm5zID0ge1xuICAgIEFFSU86IC9bQUVJT10vZyxcbiAgICBBWjA5OiAvW0EtWjAtOV0vLFxufTtcblxuY29uc3QgcGxhaW50ZXh0Y29kZSA9IFtcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAwLCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiMFwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMSwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIjFcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDIsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCIyXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAzLCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiM1wiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogNCwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIjRcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDUsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCI1XCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiA2LCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiNlwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogNywgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIjdcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDgsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCI4XCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiA5LCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiOVwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMTAsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJCXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAxMSwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIkNcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDEyLCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiRFwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMTMsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJGXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAxNCwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIkdcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDE1LCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiSFwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMTYsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJKXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAxNywgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIktcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDE4LCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiTFwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMTksIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJNXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAyMCwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIk5cIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDIxLCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiUFwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMjIsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJRXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAyMywgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIlJcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDI0LCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiU1wiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMjUsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJUXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAyNiwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIlVcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDI3LCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiVlwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMjgsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJXXCIgfSxcbiAgICB7IFwiZGlnaXRfY29kZVwiOiAyOSwgXCJjaGFyYWN0ZXJfY29kZVwiOiBcIlhcIiB9LFxuICAgIHsgXCJkaWdpdF9jb2RlXCI6IDMwLCBcImNoYXJhY3Rlcl9jb2RlXCI6IFwiWVwiIH0sXG4gICAgeyBcImRpZ2l0X2NvZGVcIjogMzEsIFwiY2hhcmFjdGVyX2NvZGVcIjogXCJaXCIgfVxuXTtcblxuY2xhc3MgQ29kZTMyUmVhZGVyIGV4dGVuZHMgQ29kZTM5UmVhZGVyIHtcbiAgICBGT1JNQVQgPSAnY29kZV8zMl9yZWFkZXInO1xuXG4gICAgLy8gVE9ETyAodGhpcyB3YXMgdG9kbyBpbiBvcmlnaW5hbCByZXBvLCBubyB0ZXh0IHdhcyB0aGVyZS4gc29ycnkuKVxuICAgIF9jaGVja0NoZWNrc3VtKGNvZGU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gISFjb2RlO1xuICAgIH1cblxuICAgIF9kZWNvZGUocm93PzogQXJyYXk8bnVtYmVyPiwgc3RhcnQ/OiBCYXJjb2RlUG9zaXRpb24pOiBCYXJjb2RlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLl9kZWNvZGUocm93LCBzdGFydCk7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlID0gcmVzdWx0LmNvZGU7XG5cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocGF0dGVybnMuQUVJTywgJycpO1xuXG4gICAgICAgIGlmICghY29kZS5tYXRjaChwYXR0ZXJucy5BWjA5KSkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgQVowOSBwYXR0ZXJuIGNvZGU6JywgY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY2hlY2tDaGVja3N1bShjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2NvZGUgPSAwO1xuICAgICAgICB2YXIgY29kZV9maW5hbDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBjb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hhcl9jb2RlID0gY29kZS5jaGFyQXQoaSk7XG4gICAgICAgICAgICBsZXQgc2VhcmNoX2RpZ2l0X2NvZGUgPSBwbGFpbnRleHRjb2RlLmZpbmQoZSA9PiBlLmNoYXJhY3Rlcl9jb2RlID09PSBjaGFyX2NvZGUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlYXJjaF9kaWdpdF9jb2RlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGxldCBkaWdpdF9jb2RlID0gc2VhcmNoX2RpZ2l0X2NvZGUuZGlnaXRfY29kZTtcblxuICAgICAgICAgICAgICAgIGxldCBleHBvbmVudF9udW1iZXIgPSBjb2RlLmxlbmd0aCAtIGkgLSAxO1xuXG4gICAgICAgICAgICAgICAgZGlnaXRfY29kZSA9IGRpZ2l0X2NvZGUgKiBNYXRoLnBvdygzMiwgZXhwb25lbnRfbnVtYmVyKTtcbiAgICAgICAgICAgICAgICBuZXdfY29kZSArPSBkaWdpdF9jb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3X2NvZGUudG9TdHJpbmcoKS5sZW5ndGggPCA5KSB7XG4gICAgICAgICAgICBsZXQgY29kZV9kaWZmX2xlbmd0aCA9IDkgLSBuZXdfY29kZS50b1N0cmluZygpLmxlbmd0aDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBjb2RlX2RpZmZfbGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICBjb2RlX2ZpbmFsID0gXCIwXCIrbmV3X2NvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb2RlX2ZpbmFsID0gXCJBXCIrbmV3X2NvZGU7XG5cbiAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlX2ZpbmFsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvZGUzMlJlYWRlcjtcbiIsImltcG9ydCBCcmVzZW5oYW0gZnJvbSAnLi9icmVzZW5oYW0nO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi4vY29tbW9uL2ltYWdlX2RlYnVnJztcbmltcG9ydCBDb2RlMTI4UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzEyOF9yZWFkZXInO1xuaW1wb3J0IEVBTlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuX3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5UmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3JlYWRlcic7XG5pbXBvcnQgQ29kZTM5VklOUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzM5X3Zpbl9yZWFkZXInO1xuaW1wb3J0IENvZGFiYXJSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2NvZGFiYXJfcmVhZGVyJztcbmltcG9ydCBVUENSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19yZWFkZXInO1xuaW1wb3J0IEVBTjhSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2Vhbl84X3JlYWRlcic7XG5pbXBvcnQgRUFOMlJlYWRlciBmcm9tICcuLi9yZWFkZXIvZWFuXzJfcmVhZGVyJztcbmltcG9ydCBFQU41UmVhZGVyIGZyb20gJy4uL3JlYWRlci9lYW5fNV9yZWFkZXInO1xuaW1wb3J0IFVQQ0VSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL3VwY19lX3JlYWRlcic7XG5pbXBvcnQgSTJvZjVSZWFkZXIgZnJvbSAnLi4vcmVhZGVyL2kyb2Y1X3JlYWRlcic7XG5pbXBvcnQgVHdvT2ZGaXZlUmVhZGVyIGZyb20gJy4uL3JlYWRlci8yb2Y1X3JlYWRlcic7XG5pbXBvcnQgQ29kZTkzUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzkzX3JlYWRlcic7XG5pbXBvcnQgQ29kZTMyUmVhZGVyIGZyb20gJy4uL3JlYWRlci9jb2RlXzMyX3JlYWRlcic7XG5cbmNvbnN0IFJFQURFUlMgPSB7XG4gICAgY29kZV8xMjhfcmVhZGVyOiBDb2RlMTI4UmVhZGVyLFxuICAgIGVhbl9yZWFkZXI6IEVBTlJlYWRlcixcbiAgICBlYW5fNV9yZWFkZXI6IEVBTjVSZWFkZXIsXG4gICAgZWFuXzJfcmVhZGVyOiBFQU4yUmVhZGVyLFxuICAgIGVhbl84X3JlYWRlcjogRUFOOFJlYWRlcixcbiAgICBjb2RlXzM5X3JlYWRlcjogQ29kZTM5UmVhZGVyLFxuICAgIGNvZGVfMzlfdmluX3JlYWRlcjogQ29kZTM5VklOUmVhZGVyLFxuICAgIGNvZGFiYXJfcmVhZGVyOiBDb2RhYmFyUmVhZGVyLFxuICAgIHVwY19yZWFkZXI6IFVQQ1JlYWRlcixcbiAgICB1cGNfZV9yZWFkZXI6IFVQQ0VSZWFkZXIsXG4gICAgaTJvZjVfcmVhZGVyOiBJMm9mNVJlYWRlcixcbiAgICAnMm9mNV9yZWFkZXInOiBUd29PZkZpdmVSZWFkZXIsXG4gICAgY29kZV85M19yZWFkZXI6IENvZGU5M1JlYWRlcixcbiAgICBjb2RlXzMyX3JlYWRlcjogQ29kZTMyUmVhZGVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIHJlZ2lzdGVyUmVhZGVyOiAobmFtZSwgcmVhZGVyKSA9PiB7XG4gICAgICAgIFJFQURFUlNbbmFtZV0gPSByZWFkZXI7XG4gICAgfSxcbiAgICBjcmVhdGUoY29uZmlnLCBpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICBjb25zdCBfY2FudmFzID0ge1xuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgICAgICAgICAgb3ZlcmxheTogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdmVybGF5OiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgX2JhcmNvZGVSZWFkZXJzID0gW107XG5cbiAgICAgICAgaW5pdENhbnZhcygpO1xuICAgICAgICBpbml0UmVhZGVycygpO1xuICAgICAgICBpbml0Q29uZmlnKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENhbnZhcygpIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRkZWJ1ZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNkZWJ1Zy5kZXRlY3Rpb24nKTtcbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5mcmVxdWVuY3kgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuZnJlcXVlbmN5Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFfY2FudmFzLmRvbS5mcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20uZnJlcXVlbmN5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICAgICAgICAgIF9jYW52YXMuZG9tLmZyZXF1ZW5jeS5jbGFzc05hbWUgPSAnZnJlcXVlbmN5JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2NhbnZhcy5jdHguZnJlcXVlbmN5ID0gX2NhbnZhcy5kb20uZnJlcXVlbmN5LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLnBhdHRlcm5CdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoIV9jYW52YXMuZG9tLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgX2NhbnZhcy5kb20ucGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5wYXR0ZXJuLmNsYXNzTmFtZSA9ICdwYXR0ZXJuQnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlYnVnLmFwcGVuZENoaWxkKF9jYW52YXMuZG9tLnBhdHRlcm4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jYW52YXMuY3R4LnBhdHRlcm4gPSBfY2FudmFzLmRvbS5wYXR0ZXJuLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICBfY2FudmFzLmRvbS5vdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmRyYXdpbmdCdWZmZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoX2NhbnZhcy5kb20ub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBfY2FudmFzLmN0eC5vdmVybGF5ID0gX2NhbnZhcy5kb20ub3ZlcmxheS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRSZWFkZXJzKCkge1xuICAgICAgICAgICAgY29uZmlnLnJlYWRlcnMuZm9yRWFjaCgocmVhZGVyQ29uZmlnKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRlcjtcbiAgICAgICAgICAgICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCBzdXBwbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWFkZXJDb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRlckNvbmZpZy5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYXRpb24gPSByZWFkZXJDb25maWcuY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRlckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZGVyQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCZWZvcmUgcmVnaXN0ZXJpbmcgcmVhZGVyOiAnLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbi5zdXBwbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBzdXBwbGVtZW50cyA9IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdXBwbGVtZW50cy5tYXAoKHN1cHBsZW1lbnQpID0+IG5ldyBSRUFERVJTW3N1cHBsZW1lbnRdKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXJPYmogPSBuZXcgUkVBREVSU1tyZWFkZXJdKGNvbmZpZ3VyYXRpb24sIHN1cHBsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLnB1c2gocmVhZGVyT2JqKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKiBFcnJvciBjb25zdHJ1Y3RpbmcgcmVhZGVyICcsIHJlYWRlciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSZWdpc3RlcmVkIFJlYWRlcnM6ICR7X2JhcmNvZGVSZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHJlYWRlcikgPT4gSlNPTi5zdHJpbmdpZnkoeyBmb3JtYXQ6IHJlYWRlci5GT1JNQVQsIGNvbmZpZzogcmVhZGVyLmNvbmZpZyB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbml0Q29uZmlnKCkge1xuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogX2NhbnZhcy5kb20uZnJlcXVlbmN5LFxuICAgICAgICAgICAgICAgICAgICBwcm9wOiBjb25maWcuZGVidWcuc2hvd0ZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IF9jYW52YXMuZG9tLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHByb3A6IGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybixcbiAgICAgICAgICAgICAgICB9XTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc1tpXS5wcm9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNbaV0ubm9kZS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc1tpXS5ub2RlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kIHRoZSBsaW5lIG9uIGJvdGggZW5kc1xuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRMaW5lKGxpbmUsIGFuZ2xlLCBleHQpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4dGVuZExpbmUoYW1vdW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB5OiBhbW91bnQgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICAgICAgICAgIHg6IGFtb3VudCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueDtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLnk7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgaW5zaWRlIGltYWdlXG4gICAgICAgICAgICBleHRlbmRMaW5lKGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ID4gMSAmJiAoIWlucHV0SW1hZ2VXcmFwcGVyLmluSW1hZ2VXaXRoQm9yZGVyKGxpbmVbMF0pXG4gICAgICAgICAgICAgICAgICAgIHx8ICFpbnB1dEltYWdlV3JhcHBlci5pbkltYWdlV2l0aEJvcmRlcihsaW5lWzFdKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBleHQgLT0gTWF0aC5jZWlsKGV4dCAvIDIpO1xuICAgICAgICAgICAgICAgIGV4dGVuZExpbmUoLWV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldExpbmUoYm94KSB7XG4gICAgICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICAgICAgICB4OiAoYm94WzFdWzBdIC0gYm94WzBdWzBdKSAvIDIgKyBib3hbMF1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGJveFsxXVsxXSAtIGJveFswXVsxXSkgLyAyICsgYm94WzBdWzFdLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IChib3hbM11bMF0gLSBib3hbMl1bMF0pIC8gMiArIGJveFsyXVswXSxcbiAgICAgICAgICAgICAgICB5OiAoYm94WzNdWzFdIC0gYm94WzJdWzFdKSAvIDIgKyBib3hbMl1bMV0sXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyeURlY29kZShsaW5lKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgYmFyY29kZUxpbmUgPSBCcmVzZW5oYW0uZ2V0QmFyY29kZUxpbmUoaW5wdXRJbWFnZVdyYXBwZXIsIGxpbmVbMF0sIGxpbmVbMV0pO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93RnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgSW1hZ2VEZWJ1Zy5kcmF3UGF0aChsaW5lLCB7IHg6ICd4JywgeTogJ3knIH0sIF9jYW52YXMuY3R4Lm92ZXJsYXksIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICAgICAgQnJlc2VuaGFtLmRlYnVnLnByaW50RnJlcXVlbmN5KGJhcmNvZGVMaW5lLmxpbmUsIF9jYW52YXMuZG9tLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEJyZXNlbmhhbS50b0JpbmFyeUxpbmUoYmFyY29kZUxpbmUpO1xuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZWJ1Zy5zaG93UGF0dGVybikge1xuICAgICAgICAgICAgICAgIEJyZXNlbmhhbS5kZWJ1Zy5wcmludFBhdHRlcm4oYmFyY29kZUxpbmUubGluZSwgX2NhbnZhcy5kb20ucGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZVBhdHRlcm4oYmFyY29kZUxpbmUubGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGVSZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBiYXJjb2RlTGluZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgc2xpY2VzIHRoZSBnaXZlbiBhcmVhIGFwYXJ0IGFuZCB0cmllcyB0byBkZXRlY3QgYSBiYXJjb2RlLXBhdHRlcm5cbiAgICAgICAgICogZm9yIGVhY2ggc2xpY2UuIEl0IHJldHVybnMgdGhlIGRlY29kZWQgYmFyY29kZSwgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib3hcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbGluZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbGluZUFuZ2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKSB7XG4gICAgICAgICAgICBjb25zdCBzaWRlTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KGJveFsxXVswXSAtIGJveFswXVswXSwgMikgKyBNYXRoLnBvdygoYm94WzFdWzFdIC0gYm94WzBdWzFdKSwgMikpO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBjb25zdCBzbGljZXMgPSAxNjtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGRpcjtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb247XG4gICAgICAgICAgICBjb25zdCB4ZGlyID0gTWF0aC5zaW4obGluZUFuZ2xlKTtcbiAgICAgICAgICAgIGNvbnN0IHlkaXIgPSBNYXRoLmNvcyhsaW5lQW5nbGUpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgc2xpY2VzICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSBsaW5lIHBlcnBlbmRpY3VsYXIgdG8gYW5nbGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgZGlyID0gc2lkZUxlbmd0aCAvIHNsaWNlcyAqIGkgKiAoaSAlIDIgPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeTogZGlyICogeGRpcixcbiAgICAgICAgICAgICAgICAgICAgeDogZGlyICogeWRpcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4gICAgICAgICAgICAgICAgbGluZVswXS55ICs9IGV4dGVuc2lvbi54O1xuICAgICAgICAgICAgICAgIGxpbmVbMF0ueCAtPSBleHRlbnNpb24ueTtcbiAgICAgICAgICAgICAgICBsaW5lWzFdLnkgKz0gZXh0ZW5zaW9uLng7XG4gICAgICAgICAgICAgICAgbGluZVsxXS54IC09IGV4dGVuc2lvbi55O1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTWF0aC5hYnMobGluZVsxXS55IC0gbGluZVswXS55KSwgMilcbiAgICAgICAgICAgICAgICArIE1hdGgucG93KE1hdGguYWJzKGxpbmVbMV0ueCAtIGxpbmVbMF0ueCksIDIpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRlY29kZUZyb21JbWFnZShpbWFnZVdyYXBwZXIpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYmFyY29kZVJlYWRlcnMubGVuZ3RoICYmIHJlc3VsdCA9PT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZUltYWdlID8gX2JhcmNvZGVSZWFkZXJzW2ldLmRlY29kZUltYWdlKGltYWdlV3JhcHBlcikgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCB0aGUgaGVscCBvZiB0aGUgY29uZmlndXJlZCByZWFkZXJzIChDb2RlMTI4IG9yIEVBTikgdGhpcyBmdW5jdGlvbiB0cmllcyB0byBkZXRlY3QgYVxuICAgICAgICAgKiB2YWxpZCBiYXJjb2RlIHBhdHRlcm4gd2l0aGluIHRoZSBnaXZlbiBhcmVhLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYm94IFRoZSBhcmVhIHRvIHNlYXJjaCBpblxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVzdWx0IHtjb2RlUmVzdWx0LCBsaW5lLCBhbmdsZSwgcGF0dGVybiwgdGhyZXNob2xkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBfY2FudmFzLmN0eC5vdmVybGF5O1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcblxuICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZGVidWcuZHJhd0JvdW5kaW5nQm94ICYmIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBJbWFnZURlYnVnLmRyYXdQYXRoKGJveCwgeyB4OiAwLCB5OiAxIH0sIGN0eCwgeyBjb2xvcjogJ2JsdWUnLCBsaW5lV2lkdGg6IDIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsaW5lID0gZ2V0TGluZShib3gpO1xuICAgICAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IGdldExpbmVMZW5ndGgobGluZSk7XG4gICAgICAgICAgICBjb25zdCBsaW5lQW5nbGUgPSBNYXRoLmF0YW4yKGxpbmVbMV0ueSAtIGxpbmVbMF0ueSwgbGluZVsxXS54IC0gbGluZVswXS54KTtcbiAgICAgICAgICAgIGxpbmUgPSBnZXRFeHRlbmRlZExpbmUobGluZSwgbGluZUFuZ2xlLCBNYXRoLmZsb29yKGxpbmVMZW5ndGggKiAwLjEpKTtcbiAgICAgICAgICAgIGlmIChsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeURlY29kZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlEZWNvZGVCcnV0ZUZvcmNlKGJveCwgbGluZSwgbGluZUFuZ2xlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50ICYmIHJlc3VsdCAmJiBjb25maWcuZGVidWcuZHJhd1NjYW5saW5lICYmIGN0eCkge1xuICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd1BhdGgobGluZSwgeyB4OiAneCcsIHk6ICd5JyB9LCBjdHgsIHsgY29sb3I6ICdyZWQnLCBsaW5lV2lkdGg6IDMgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29kZVJlc3VsdDogcmVzdWx0LmNvZGVSZXN1bHQsXG4gICAgICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgICAgICBhbmdsZTogbGluZUFuZ2xlLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlc3VsdC5iYXJjb2RlTGluZS5saW5lLFxuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogcmVzdWx0LmJhcmNvZGVMaW5lLnRocmVzaG9sZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVjb2RlRnJvbUJvdW5kaW5nQm94KGJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGVGcm9tQm91bmRpbmdCb3hlcyhib3hlcykge1xuICAgICAgICAgICAgICAgIGxldCBpOyBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhcmNvZGVzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtdWx0aXBsZSB9ID0gY29uZmlnO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGJveGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveCA9IGJveGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVGcm9tQm91bmRpbmdCb3goYm94KSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmJveCA9IGJveDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuY29kZVJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFyY29kZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZUZyb21JbWFnZShpbnB1dEltYWdlV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZUZyb21JbWFnZShpbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoUkVBREVSU1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWdpc3RlciBleGlzdGluZyByZWFkZXInLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUkVBREVSU1tuYW1lXSA9IHJlYWRlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXRSZWFkZXJzKHJlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBjb25maWcucmVhZGVycyA9IHJlYWRlcnM7XG4gICAgICAgICAgICAgICAgX2JhcmNvZGVSZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgaW5pdFJlYWRlcnMoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJ0eXBlIEV2ZW50TmFtZSA9IHN0cmluZztcblxuaW50ZXJmYWNlIFN1YnNjcmlwdGlvbiB7XG4gICAgYXN5bmM/OiBib29sZWFuO1xuICAgIGNhbGxiYWNrOiBGdW5jdGlvbjtcbiAgICBvbmNlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEV2ZW50RGF0YSB7XG4gICAgc3Vic2NyaWJlcnM6IEFycmF5PFN1YnNjcmlwdGlvbj47XG59XG5cbmludGVyZmFjZSBFdmVudHMge1xuICAgIFtrZXk6IHN0cmluZ106IEV2ZW50RGF0YTtcbn1cblxuaW50ZXJmYWNlIEV2ZW50SW50ZXJmYWNlIHtcbiAgICBzdWJzY3JpYmUoZXZlbnQ6IEV2ZW50TmFtZSwgY2FsbGJhY2s6IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uLCBhc3luYz86IGJvb2xlYW4pOiB2b2lkO1xuICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQ7XG4gICAgb25jZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIEV2ZW50SW50ZXJmYWNlKCk6IEV2ZW50SW50ZXJmYWNlIHtcbiAgICBsZXQgZXZlbnRzOiBFdmVudHMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGdldEV2ZW50KGV2ZW50TmFtZTogRXZlbnROYW1lKTogRXZlbnREYXRhIHtcbiAgICAgICAgaWYgKCFldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzW2V2ZW50TmFtZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJFdmVudHMoKTogdm9pZCB7XG4gICAgICAgIGV2ZW50cyA9IHt9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24sIGRhdGE6IG5ldmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH0sIDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLmNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3N1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhc3luYyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghc3Vic2NyaXB0aW9uLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsYmFjayB3YXMgbm90IHNwZWNpZmllZCBvbiBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXRFdmVudChldmVudCkuc3Vic2NyaWJlcnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZShldmVudDogRXZlbnROYW1lLCBjYWxsYmFjazogRnVuY3Rpb24gfCBTdWJzY3JpcHRpb24sIGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICAgICAgcmV0dXJuIF9zdWJzY3JpYmUoZXZlbnQsIGNhbGxiYWNrLCBhc3luYyk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1Ymxpc2goZXZlbnROYW1lOiBFdmVudE5hbWUsIGRhdGE/OiBuZXZlcik6IHZvaWQge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggb25lLXRpbWUgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZmlsdGVyKChzdWJzY3JpYmVyKSA9PiAhIXN1YnNjcmliZXIub25jZSkuZm9yRWFjaCgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHB1Ymxpc2hTdWJzY3JpcHRpb24oc3Vic2NyaWJlciwgZGF0YSBhcyBuZXZlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc3Vic2NyaWJlclxuICAgICAgICAgICAgZXZlbnQuc3Vic2NyaWJlcnMgPSBzdWJzY3JpYmVycy5maWx0ZXIoKHN1YnNjcmliZXIpID0+ICFzdWJzY3JpYmVyLm9uY2UpO1xuXG4gICAgICAgICAgICAvLyBwdWJsaXNoIHRoZSByZXN0XG4gICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycy5mb3JFYWNoKChzdWJzY3JpYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcHVibGlzaFN1YnNjcmlwdGlvbihzdWJzY3JpYmVyLCBkYXRhIGFzIG5ldmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBvbmNlKGV2ZW50OiBFdmVudE5hbWUsIGNhbGxiYWNrOiBGdW5jdGlvbiwgYXN5bmMgPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgX3N1YnNjcmliZShldmVudCwge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGFzeW5jLFxuICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdWJzY3JpYmUoZXZlbnROYW1lPzogRXZlbnROYW1lLCBjYWxsYmFjaz86IEZ1bmN0aW9uIHwgU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBnZXRFdmVudChldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdWJzY3JpYmVycyA9IGV2ZW50LnN1YnNjcmliZXJzLmZpbHRlcigoc3Vic2NyaWJlcikgPT4gc3Vic2NyaWJlci5jYWxsYmFjayAhPT0gY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN1YnNjcmliZXJzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhckV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59KCkpO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGVudW1lcmF0ZURldmljZXMoKTogUHJvbWlzZTxBcnJheTxNZWRpYURldmljZUluZm8+PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdlbnVtZXJhdGVEZXZpY2VzIGlzIG5vdCBkZWZpbmVkJykpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJNZWRpYShjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8TWVkaWFTdHJlYW0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdnZXRVc2VyTWVkaWEgaXMgbm90IGRlZmluZWQnKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcGljayB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBnZXRVc2VyTWVkaWEsIGVudW1lcmF0ZURldmljZXMgfSBmcm9tICcuLi9jb21tb24vbWVkaWFEZXZpY2VzJztcbmltcG9ydCB7IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkIH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmxldCBzdHJlYW1SZWY6IE1lZGlhU3RyZWFtIHwgbnVsbDtcblxuZnVuY3Rpb24gd2FpdEZvclZpZGVvKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMTA7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tWaWRlbygpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8udmlkZW9XaWR0aCA+IDEwICYmIHZpZGVvLnZpZGVvSGVpZ2h0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCogZGV2OiBjaGVja1ZpZGVvIGZvdW5kICR7dmlkZW8udmlkZW9XaWR0aH1weCB4ICR7dmlkZW8udmlkZW9IZWlnaHR9cHhgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2hlY2tWaWRlbywgNTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwbGF5IHZpZGVvIHN0cmVhbS4gSXMgd2ViY2FtIHdvcmtpbmc/JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgfVxuICAgICAgICBjaGVja1ZpZGVvKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gYXR0YWNoIHRoZSBjYW1lcmEtc3RyZWFtIHRvIGEgZ2l2ZW4gdmlkZW8tZWxlbWVudFxuICogYW5kIGNhbGxzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHRoZSBjb250ZW50IGlzIHJlYWR5XG4gKiBAcGFyYW0ge09iamVjdH0gY29uc3RyYWludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSB2aWRlb1xuICovXG5hc3luYyBmdW5jdGlvbiBpbml0Q2FtZXJhKHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50LCBjb25zdHJhaW50czogTWVkaWFTdHJlYW1Db25zdHJhaW50cyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IGdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgc3RyZWFtUmVmID0gc3RyZWFtO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgnbXV0ZWQnLCAndHJ1ZScpO1xuICAgIHZpZGVvLnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAndHJ1ZScpOyAvLyBub3QgbGlzdGVkIG9uIE1ETi4uLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsICgpID0+IHtcbiAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgIH0pO1xuICAgIHJldHVybiB3YWl0Rm9yVmlkZW8odmlkZW8pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50czogTWVkaWFUcmFja0NvbnN0cmFpbnRzV2l0aERlcHJlY2F0ZWQpOiBNZWRpYVRyYWNrQ29uc3RyYWludHMge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBwaWNrKHZpZGVvQ29uc3RyYWludHMsIFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2ZhY2luZ01vZGUnLFxuICAgICAgICAnYXNwZWN0UmF0aW8nLCAnZGV2aWNlSWQnXSk7XG5cbiAgICBpZiAodHlwZW9mIHZpZGVvQ29uc3RyYWludHMubWluQXNwZWN0UmF0aW8gIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAmJiB2aWRlb0NvbnN0cmFpbnRzLm1pbkFzcGVjdFJhdGlvID4gMCkge1xuICAgICAgICBub3JtYWxpemVkLmFzcGVjdFJhdGlvID0gdmlkZW9Db25zdHJhaW50cy5taW5Bc3BlY3RSYXRpbztcbiAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IENvbnN0cmFpbnQgXFwnbWluQXNwZWN0UmF0aW9cXCcgaXMgZGVwcmVjYXRlZDsgVXNlIFxcJ2FzcGVjdFJhdGlvXFwnIGluc3RlYWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzLmZhY2luZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbm9ybWFsaXplZC5mYWNpbmdNb2RlID0gdmlkZW9Db25zdHJhaW50cy5mYWNpbmc7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBDb25zdHJhaW50IFxcJ2ZhY2luZ1xcJyBpcyBkZXByZWNhdGVkLiBVc2UgXFwnZmFjaW5nTW9kZVxcJyBpbnN0ZWFkXFwnJyk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVkO1xufVxuXG4vLyBUT0RPOiAjMTkyIEkgZG9uJ3QgdGhpbmsgdGhlcmUncyBhbnkgZ29vZCByZWFzb24gcGlja0NvbnN0cmFpbnRzIHNob3VsZCByZXR1cm4gYSBQcm9taXNlLFxuLy8gSSB0aGluayBpdCB3YXMganVzdCB0aGF0IHdheSBzbyBpdCBjb3VsZCBiZSBjaGFpbmVkIHRvIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGRpZCByZXR1cm4gYSBQcm9taXNlLlxuLy8gVGhhdCdzIG5vdCBuZWNlc3Nhcnkgd2l0aCBhc3luYyBmdW5jdGlvbnMgYmVpbmcgYSB0aGluZywgc28gdGhhdCBzaG91bGQgYmUgZml4ZWQuXG5leHBvcnQgZnVuY3Rpb24gcGlja0NvbnN0cmFpbnRzKHZpZGVvQ29uc3RyYWludHM6IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkID0ge30pOiBQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+IHtcbiAgICBjb25zdCB2aWRlbyA9IGRlcHJlY2F0ZWRDb25zdHJhaW50cyh2aWRlb0NvbnN0cmFpbnRzKTtcblxuICAgIGlmICh2aWRlbyAmJiB2aWRlby5kZXZpY2VJZCAmJiB2aWRlby5mYWNpbmdNb2RlKSB7XG4gICAgICAgIGRlbGV0ZSB2aWRlby5mYWNpbmdNb2RlO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgYXVkaW86IGZhbHNlLCB2aWRlbyB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW51bWVyYXRlVmlkZW9EZXZpY2VzKCk6IFByb21pc2U8QXJyYXk8TWVkaWFEZXZpY2VJbmZvPj4ge1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBlbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgcmV0dXJuIGRldmljZXMuZmlsdGVyKChkZXZpY2U6IE1lZGlhRGV2aWNlSW5mbykgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZVRyYWNrKCk6IE1lZGlhU3RyZWFtVHJhY2sgfCBudWxsIHtcbiAgICBpZiAoIXN0cmVhbVJlZikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtUmVmLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgcmV0dXJuIHRyYWNrcyAmJiB0cmFja3M/Lmxlbmd0aCA/IHRyYWNrc1swXSA6IG51bGw7XG59XG5cbi8qKlxuICogVXNlZCBmb3IgYWNjZXNzaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3RpdmUgc3RyZWFtIHRyYWNrIGFuZCBhdmFpbGFibGUgdmlkZW8gZGV2aWNlcy5cbiAqL1xuY29uc3QgUXVhZ2dhSlNDYW1lcmFBY2Nlc3MgPSB7XG4gICAgYXN5bmMgcmVxdWVzdCh2aWRlbzogSFRNTFZpZGVvRWxlbWVudCwgdmlkZW9Db25zdHJhaW50cz86IE1lZGlhVHJhY2tDb25zdHJhaW50c1dpdGhEZXByZWNhdGVkKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgbmV3Q29uc3RyYWludHMgPSBhd2FpdCBwaWNrQ29uc3RyYWludHModmlkZW9Db25zdHJhaW50cyk7XG4gICAgICAgIHJldHVybiBpbml0Q2FtZXJhKHZpZGVvLCBuZXdDb25zdHJhaW50cyk7XG4gICAgfSxcbiAgICByZWxlYXNlKCk6IHZvaWQge1xuICAgICAgICAvLyBUT0RPOiBpIHdvbmRlciBpZiB0ZWxsaW5nIHRoZSBWaWRlbyBlbGVtZW50IHRvIHBhdXNlKCkgYmVmb3JlIGNhbGxpbmcgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCkgd291bGQgYWxsZXZpYXRlIHNvbWUgb2YgdGhlIGlzc3VlcyB3aXRoIHRoZSBjYW1lcmEgYXBwZWFyaW5nIHRvIHN0YXkgb3BlbiBvbiBBbmRyb2lkIGV2ZW4gYWZ0ZXIgc3RvcHBpbmcuXG4gICAgICAgIGNvbnN0IHRyYWNrcyA9IHN0cmVhbVJlZiAmJiBzdHJlYW1SZWYuZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgaWYgKHRyYWNrcyAmJiB0cmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0cmFja3NbMF0uc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVJlZiA9IG51bGw7XG4gICAgfSxcbiAgICBlbnVtZXJhdGVWaWRlb0RldmljZXMsXG4gICAgZ2V0QWN0aXZlU3RyZWFtTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBnZXRBY3RpdmVUcmFjaygpO1xuICAgICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5sYWJlbCA6ICcnO1xuICAgIH0sXG4gICAgZ2V0QWN0aXZlVHJhY2ssXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU0NhbWVyYUFjY2VzcztcbiIsImltcG9ydCBJbWFnZURlYnVnIGZyb20gJy4uL2NvbW1vbi9pbWFnZV9kZWJ1Zyc7XG5pbXBvcnQge1xuICAgIFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvcixcbiAgICBRdWFnZ2FKU1Jlc3VsdENvbGxlY3RvckZpbHRlckZ1bmN0aW9uLFxuICAgIFhZU2l6ZSxcbiAgICBRdWFnZ2FJbWFnZURhdGEsXG59IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5mdW5jdGlvbiBjb250YWlucyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQsIGxpc3Q6IEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gbGlzdCAmJiBsaXN0LnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pIGFzIEFycmF5PGtleW9mIFF1YWdnYUpTQ29kZVJlc3VsdD47XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KChrZXkpID0+IGl0ZW1ba2V5XSA9PT0gY29kZVJlc3VsdFtrZXldKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzc2VzRmlsdGVyKFxuICAgIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCxcbiAgICBmaWx0ZXI6IFF1YWdnYUpTUmVzdWx0Q29sbGVjdG9yRmlsdGVyRnVuY3Rpb24gfCB1bmRlZmluZWQsXG4pOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IGZpbHRlcihjb2RlUmVzdWx0KSA6IHRydWU7XG59XG5cbmludGVyZmFjZSBSZXN1bHRDb2xsZWN0b3Ige1xuICAgIGFkZFJlc3VsdDogKGRhdGE6IFF1YWdnYUltYWdlRGF0YSwgaW1hZ2VTaXplOiBYWVNpemUsIGNvZGVSZXN1bHQ6IFF1YWdnYUpTQ29kZVJlc3VsdCkgPT4gdm9pZDtcbiAgICBnZXRSZXN1bHRzOiAoKSA9PiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY3JlYXRlKGNvbmZpZzogUXVhZ2dhSlNSZXN1bHRDb2xsZWN0b3IpOiBSZXN1bHRDb2xsZWN0b3Ige1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJykgYXMgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEO1xuICAgICAgICBjb25zdCByZXN1bHRzOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+ID0gW107XG4gICAgICAgIGxldCBjYXBhY2l0eSA9IGNvbmZpZy5jYXBhY2l0eSA/PyAyMDtcbiAgICAgICAgY29uc3QgY2FwdHVyZSA9IGNvbmZpZy5jYXB0dXJlID09PSB0cnVlO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiBib29sZWFuIHtcbiAgICAgICAgICAgIHJldHVybiAhIWNhcGFjaXR5XG4gICAgICAgICAgICAgICAgJiYgY29kZVJlc3VsdFxuICAgICAgICAgICAgICAgICYmICFjb250YWlucyhjb2RlUmVzdWx0LCBjb25maWcuYmxhY2tsaXN0IGFzIEFycmF5PFF1YWdnYUpTQ29kZVJlc3VsdD4pXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzRmlsdGVyKGNvZGVSZXN1bHQsIGNvbmZpZy5maWx0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZFJlc3VsdChkYXRhOiBRdWFnZ2FJbWFnZURhdGEsIGltYWdlU2l6ZTogWFlTaXplLCBjb2RlUmVzdWx0OiBRdWFnZ2FKU0NvZGVSZXN1bHQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQ6IGFueSA9IHsgfTsgLy8gdGhpcyBpcyAnYW55JyB0byBhdm9pZCBoYXZpbmcgdG8gY29uc3RydWN0IGEgd2hvbGUgUXVhZ2dhSlNDb2RlUmVzdWx0IDp8XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNDb25zdHJhaW50cyhjb2RlUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYXBhY2l0eS0tO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29kZVJlc3VsdCA9IGNvZGVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZVNpemUueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZVNpemUueTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlRGVidWcuZHJhd0ltYWdlKGRhdGEsIGltYWdlU2l6ZSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5mcmFtZSA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0UmVzdWx0cygpOiBBcnJheTxRdWFnZ2FKU0NvZGVSZXN1bHQ+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbn07XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBEZXZDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICAgICAgZGVidWc6IHtcbiAgICAgICAgICAgIGRyYXdCb3VuZGluZ0JveDogZmFsc2UsXG4gICAgICAgICAgICBzaG93RnJlcXVlbmN5OiBmYWxzZSxcbiAgICAgICAgICAgIGRyYXdTY2FubGluZTogZmFsc2UsXG4gICAgICAgICAgICBzaG93UGF0dGVybjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBsb2NhdG9yOiB7XG4gICAgICAgIGhhbGZTYW1wbGU6IHRydWUsXG4gICAgICAgIHBhdGNoU2l6ZTogJ21lZGl1bScsIC8vIHgtc21hbGwsIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICAgIGRlYnVnOiB7XG4gICAgICAgICAgICBzaG93Q2FudmFzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dQYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dGb3VuZFBhdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1NrZWxldG9uOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgc2hvd1BhdGNoTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHNob3dSZW1haW5pbmdQYXRjaExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBib3hGcm9tUGF0Y2hlczoge1xuICAgICAgICAgICAgICAgIHNob3dUcmFuc2Zvcm1lZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1RyYW5zZm9ybWVkQm94OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93QkI6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRGV2Q29uZmlnO1xuIiwiaW1wb3J0IHsgUXVhZ2dhSlNDb25maWdPYmplY3QgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuY29uc3QgTm9kZUNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QgPSB7XG4gICAgaW5wdXRTdHJlYW06IHtcbiAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgc2VxdWVuY2U6IGZhbHNlLFxuICAgICAgICBzaXplOiA4MDAsXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDAsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTm9kZUNvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmNvbnN0IFByb2RDb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0ID0ge1xuICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgIG5hbWU6ICdMaXZlJyxcbiAgICAgICAgdHlwZTogJ0xpdmVTdHJlYW0nLFxuICAgICAgICBjb25zdHJhaW50czoge1xuICAgICAgICAgICAgd2lkdGg6IDY0MCxcbiAgICAgICAgICAgIGhlaWdodDogNDgwLFxuICAgICAgICAgICAgLy8gYXNwZWN0UmF0aW86IDY0MC80ODAsIC8vIG9wdGlvbmFsXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnLCAvLyBvciB1c2VyXG4gICAgICAgICAgICAvLyBkZXZpY2VJZDogXCIzODc0NTk4MzQ1NzM4NzU5ODM3NTk4Mzc1OTgzNFwiXG4gICAgICAgIH0sXG4gICAgICAgIGFyZWE6IHtcbiAgICAgICAgICAgIHRvcDogJzAlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAnMCUnLFxuICAgICAgICAgICAgbGVmdDogJzAlJyxcbiAgICAgICAgICAgIGJvdHRvbTogJzAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlQ2hhbm5lbDogZmFsc2UsIC8vIHRydWU6IG9ubHkgdGhlIHJlZCBjb2xvci1jaGFubmVsIGlzIHJlYWRcbiAgICB9LFxuICAgIGxvY2F0ZTogdHJ1ZSxcbiAgICBudW1PZldvcmtlcnM6IDQsXG4gICAgZGVjb2Rlcjoge1xuICAgICAgICByZWFkZXJzOiBbXG4gICAgICAgICAgICAnY29kZV8xMjhfcmVhZGVyJyxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGxvY2F0b3I6IHtcbiAgICAgICAgaGFsZlNhbXBsZTogdHJ1ZSxcbiAgICAgICAgcGF0Y2hTaXplOiAnbWVkaXVtJywgLy8geC1zbWFsbCwgc21hbGwsIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgUHJvZENvbmZpZztcbiIsImltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgRGV2Q29uZmlnIGZyb20gJy4vY29uZmlnLmRldic7XG5pbXBvcnQgTm9kZUNvbmZpZyBmcm9tICcuL2NvbmZpZy5ub2RlJztcbmltcG9ydCBQcm9kQ29uZmlnIGZyb20gJy4vY29uZmlnLnByb2QnO1xuXG4vLyBAdHMtaWdub3JlIC8vIFRPRE86IHRoaXMgcHJvZHVjZXMgYSBiaXphcnJlIHR5cGVzY3JpcHQgZXJyb3Jcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuY29uc3QgUXVhZ2dhQ29uZmlnOiBRdWFnZ2FKU0NvbmZpZ09iamVjdCA9IEVOVi5kZXZlbG9wbWVudFxuICAgID8gRGV2Q29uZmlnXG4gICAgOiBFTlYubm9kZVxuICAgICAgICA/IE5vZGVDb25maWdcbiAgICAgICAgOiBQcm9kQ29uZmlnO1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FDb25maWc7XG4iLCJpbXBvcnQgeyBRdWFnZ2FKU0NvbmZpZ09iamVjdCB9IGZyb20gXCIuLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tIFwiY29tbW9uL2ltYWdlX3dyYXBwZXJcIjtcblxuZXhwb3J0IGNsYXNzIFF1YWdnYUNvbnRleHQge1xuICAgIHB1YmxpYyBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdDtcblxuICAgIHB1YmxpYyBpbnB1dFN0cmVhbTogYW55O1xuXG4gICAgcHVibGljIGZyYW1lZ3JhYmJlcjogYW55O1xuXG4gICAgcHVibGljIGlucHV0SW1hZ2VXcmFwcGVyPzogSW1hZ2VXcmFwcGVyO1xuXG4gICAgcHVibGljIHN0b3BwZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHB1YmxpYyBib3hTaXplOiBhbnk7XG5cbiAgICBwdWJsaWMgcmVzdWx0Q29sbGVjdG9yOiBhbnk7XG5cbiAgICBwdWJsaWMgZGVjb2RlcjogYW55O1xuXG4gICAgcHVibGljIHdvcmtlclBvb2w6IGFueVtdID0gW107XG5cbiAgICBwdWJsaWMgb25VSVRocmVhZCA9IHRydWU7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgY2FudmFzQ29udGFpbmVyID0gbmV3IENhbnZhc0NvbnRhaW5lcigpO1xufVxuXG5leHBvcnQgY2xhc3MgQ2FudmFzSW5mbyB7XG4gICAgaW1hZ2U6IGFueTtcbiAgICBvdmVybGF5OiBhbnk7XG59XG5cbmV4cG9ydCBjbGFzcyBDYW52YXNDb250YWluZXIge1xuICAgIHB1YmxpYyByZWFkb25seSBjdHg6IENhbnZhc0luZm87XG4gICAgcHVibGljIHJlYWRvbmx5IGRvbTogQ2FudmFzSW5mbztcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN0eCA9IG5ldyBDYW52YXNJbmZvKCk7XG4gICAgICAgIHRoaXMuZG9tID0gbmV3IENhbnZhc0luZm8oKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjbG9uZSB9IGZyb20gJ2dsLXZlYzInO1xuaW1wb3J0IHR5cGUgeyBJbnB1dFN0cmVhbSB9IGZyb20gJy4uL2lucHV0L2lucHV0X3N0cmVhbV9mYWN0b3J5JztcbmltcG9ydCBJbWFnZVdyYXBwZXIgZnJvbSAnLi4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVMb2NhdG9yIGZyb20gJy4uL2xvY2F0b3IvYmFyY29kZV9sb2NhdG9yJztcblxudHlwZSBCdWZmZXJSZXR1cm4gPSB7XG4gICAgaW5wdXRJbWFnZVdyYXBwZXI6IEltYWdlV3JhcHBlcjtcbiAgICAvLyBib3hTaXplIHNob3VsZCBiZSBsaWtlIFtbIG51bWJlciwgbnVtYmVyXSwgLi4uXSBidXQgY2xvbmUncyBzaWduYXR1cmUgZG9lc24ndCBzZWVtIHRvIGFsbG93IHRoYXRcbiAgICBib3hTaXplOiBBcnJheTxBcnJheTxudW1iZXI+Pjtcbn07XG5cbi8vIFRPRE86IG5lZWQgdHlwZXNjcmlwdCBkZWYgZm9yIEJhcmNvZGVMb2NhdG9yXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0QnVmZmVycyhcbiAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0sXG4gICAgaW1hZ2VXcmFwcGVyOiBJbWFnZVdyYXBwZXIgfCB1bmRlZmluZWQsXG4gICAgbG9jYXRvcjogYW55LFxuKTogQnVmZmVyUmV0dXJuIHtcbiAgICBjb25zdCBpbnB1dEltYWdlV3JhcHBlciA9IGltYWdlV3JhcHBlciB8fCBuZXcgSW1hZ2VXcmFwcGVyKHtcbiAgICAgICAgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSxcbiAgICAgICAgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCksXG4gICAgICAgIHR5cGU6ICdYWVNpemUnLFxuICAgIH0pO1xuXG4gICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgaW1hZ2Ugd3JhcHBlciBzaXplICR7aW5wdXRJbWFnZVdyYXBwZXIuc2l6ZX1gKTtcbiAgICB9XG4gICAgY29uc3QgYm94U2l6ZSA9IFtcbiAgICAgICAgY2xvbmUoWzAsIDBdKSxcbiAgICAgICAgY2xvbmUoWzAsIGlucHV0SW1hZ2VXcmFwcGVyLnNpemUueV0pLFxuICAgICAgICBjbG9uZShbaW5wdXRJbWFnZVdyYXBwZXIuc2l6ZS54LCBpbnB1dEltYWdlV3JhcHBlci5zaXplLnldKSxcbiAgICAgICAgY2xvbmUoW2lucHV0SW1hZ2VXcmFwcGVyLnNpemUueCwgMF0pLFxuICAgIF07XG4gICAgQmFyY29kZUxvY2F0b3IuaW5pdChpbnB1dEltYWdlV3JhcHBlciwgbG9jYXRvcik7XG4gICAgcmV0dXJuIHsgaW5wdXRJbWFnZVdyYXBwZXIsIGJveFNpemUgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdQb3J0KHRhcmdldD86IEVsZW1lbnQgfCBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGFyZ2V0IGlzIGFscmVhZHkgYSBET00gZWxlbWVudFxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0YXJnZXQubm9kZU5hbWUgJiYgdGFyZ2V0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIFVzZSAnI2ludGVyYWN0aXZlLnZpZXdwb3J0JyBhcyBhIGZhbGxiYWNrIHNlbGVjdG9yIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogJyNpbnRlcmFjdGl2ZS52aWV3cG9ydCc7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuIiwiaW1wb3J0IHsgUXVhZ2dhQ29udGV4dCwgQ2FudmFzQ29udGFpbmVyIH0gZnJvbSAnUXVhZ2dhQ29udGV4dCc7XG5pbXBvcnQgeyBYWVNpemUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcbmltcG9ydCBnZXRWaWV3UG9ydCBmcm9tICcuL2dldFZpZXdQb3J0JztcblxuZnVuY3Rpb24gZmluZE9yQ3JlYXRlQ2FudmFzKHNlbGVjdG9yOiBzdHJpbmcsIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIGdldENhbnZhc0FuZENvbnRleHQoc2VsZWN0b3I6IHN0cmluZywgY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYW52YXMgPSBmaW5kT3JDcmVhdGVDYW52YXMoc2VsZWN0b3IsIGNsYXNzTmFtZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB7IGNhbnZhcywgY29udGV4dCB9O1xufVxuXG5mdW5jdGlvbiBpbml0Q2FudmFzZXMoY2FudmFzU2l6ZTogWFlTaXplKTogQ2FudmFzQ29udGFpbmVyIHwgbnVsbCB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBnZXRDYW52YXNBbmRDb250ZXh0KCdjYW52YXMuaW1nQnVmZmVyJywgJ2ltZ0J1ZmZlcicpO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gZ2V0Q2FudmFzQW5kQ29udGV4dCgnY2FudmFzLmRyYXdpbmdCdWZmZXInLCAnZHJhd2luZ0J1ZmZlcicpO1xuXG4gICAgICAgIGltYWdlLmNhbnZhcy53aWR0aCA9IG92ZXJsYXkuY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZS54O1xuICAgICAgICBpbWFnZS5jYW52YXMuaGVpZ2h0ID0gb3ZlcmxheS5jYW52YXMuaGVpZ2h0ID0gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb206IHtcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UuY2FudmFzLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY2FudmFzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZS5jb250ZXh0LFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IG92ZXJsYXkuY29udGV4dCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0Q2FudmFzKGNvbnRleHQ6IFF1YWdnYUNvbnRleHQpOiBDYW52YXNDb250YWluZXIgfCBudWxsIHtcbiAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdQb3J0KGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnRhcmdldCk7XG4gICAgY29uc3QgdHlwZSA9IGNvbnRleHQ/LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGU7XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBjb250YWluZXIgPSBpbml0Q2FudmFzZXMoY29udGV4dC5pbnB1dFN0cmVhbS5nZXRDYW52YXNTaXplKCkpO1xuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4geyBkb206IHsgaW1hZ2U6IG51bGwsIG92ZXJsYXk6IG51bGwgfSwgY3R4OiB7IGltYWdlOiBudWxsLCBvdmVybGF5OiBudWxsIH0gfTtcblxuICAgIGNvbnN0IHsgZG9tIH0gPSBjb250YWluZXI7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHZpZXdwb3J0KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlU3RyZWFtJyAmJiAhdmlld3BvcnQuY29udGFpbnMoZG9tLmltYWdlKSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5pbWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZpZXdwb3J0LmNvbnRhaW5zKGRvbS5vdmVybGF5KSkge1xuICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGRvbS5vdmVybGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuIiwiLy8gTk9URTogKFNPTUUgT0YpIFRISVMgSVMgQlJPV1NFUiBPTkxZIENPREUuICBOb2RlIGRvZXMgbm90IGhhdmUgJ2F0b2InIGJ1aWx0IGluLCBub3IgWE1MSHR0cFJlcXVlc3QuXG4vLyBIb3cgZXhhY3RseSBpcyB0aGlzIHNldCBvZiBmdW5jdGlvbnMgdXNlZCBpbiBRdWFnZ2E/IERvIHdlIG5lZWQgdGhlIGJyb3dzZXIgc3BlY2lmaWMgY29kZT8gRG8gd2Vcbi8vIG5lZWQgdG8gcG9ydCBhbnkgcGFydCBvZiB0aGlzIHRoYXQgZG9lc24ndCB3b3JrIGluIE5vZGUgdG8gbm9kZT9cblxuLy8gVGFncyBzY3JhcGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V4aWYtanMvZXhpZi1qc1xuY29uc3QgRXhpZlRhZ3MgPSB7IDB4MDExMjogJ29yaWVudGF0aW9uJyB9O1xuZXhwb3J0IGNvbnN0IEF2YWlsYWJsZVRhZ3MgPSBPYmplY3Qua2V5cyhFeGlmVGFncykubWFwKChrZXkpID0+IEV4aWZUYWdzW2tleV0pO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbk9iamVjdFVSTChzcmMsIHRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgaWYgKC9eYmxvYjovaS50ZXN0KHNyYykpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFVSTFRvQmxvYihzcmMpXG4gICAgICAgICAgICAudGhlbihyZWFkVG9CdWZmZXIpXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiBmaW5kVGFnc0luQnVmZmVyKGJ1ZmZlciwgdGFncykpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihkYXRhVXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YVVybC5yZXBsYWNlKC9eZGF0YTooW147XSspO2Jhc2U2NCwvZ21pLCAnJyk7XG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGxlbiA9IGJpbmFyeS5sZW5ndGg7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGxlbik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZpZXdbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gcmVhZFRvQnVmZmVyKGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFVSTFRvQmxvYih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaHR0cC5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGh0dHAucmVhZHlTdGF0ZSA9PT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiAoaHR0cC5zdGF0dXMgPT09IDIwMCB8fCBodHRwLnN0YXR1cyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBodHRwLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIGh0dHAuc2VuZCgpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZFRhZ3NJbkJ1ZmZlcihmaWxlLCBzZWxlY3RlZFRhZ3MgPSBBdmFpbGFibGVUYWdzKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZmlsZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gZmlsZS5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGV4aWZUYWdzID0gc2VsZWN0ZWRUYWdzLnJlZHVjZSgocmVzdWx0LCBzZWxlY3RlZFRhZykgPT4ge1xuICAgICAgICBjb25zdCBleGlmVGFnID0gT2JqZWN0LmtleXMoRXhpZlRhZ3MpLmZpbHRlcigodGFnKSA9PiBFeGlmVGFnc1t0YWddID09PSBzZWxlY3RlZFRhZylbMF07XG4gICAgICAgIGlmIChleGlmVGFnKSB7XG4gICAgICAgICAgICByZXN1bHRbZXhpZlRhZ10gPSBzZWxlY3RlZFRhZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBsZXQgb2Zmc2V0ID0gMjtcbiAgICBsZXQgbWFya2VyO1xuXG4gICAgaWYgKChkYXRhVmlldy5nZXRVaW50OCgwKSAhPT0gMHhGRikgfHwgKGRhdGFWaWV3LmdldFVpbnQ4KDEpICE9PSAweEQ4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4RTEpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRVhJRkRhdGEoZGF0YVZpZXcsIG9mZnNldCArIDQsIGV4aWZUYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gMiArIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQgKyAyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlYWRFWElGRGF0YShmaWxlLCBzdGFydCwgZXhpZlRhZ3MpIHtcbiAgICBpZiAoZ2V0U3RyaW5nRnJvbUJ1ZmZlcihmaWxlLCBzdGFydCwgNCkgIT09ICdFeGlmJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGlmZk9mZnNldCA9IHN0YXJ0ICsgNjtcbiAgICBsZXQgYmlnRW5kO1xuXG4gICAgaWYgKGZpbGUuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDQ5NDkpIHtcbiAgICAgICAgYmlnRW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0KSA9PT0gMHg0RDREKSB7XG4gICAgICAgIGJpZ0VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlLmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyQSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBmaWxlLmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgMHgwMDAwMDAwOCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdGFncyA9IHJlYWRUYWdzKGZpbGUsIHRpZmZPZmZzZXQsIHRpZmZPZmZzZXQgKyBmaXJzdElGRE9mZnNldCwgZXhpZlRhZ3MsIGJpZ0VuZCk7XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdzKGZpbGUsIHRpZmZTdGFydCwgZGlyU3RhcnQsIHN0cmluZ3MsIGJpZ0VuZCkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBmaWxlLmdldFVpbnQxNihkaXJTdGFydCwgIWJpZ0VuZCk7XG4gICAgY29uc3QgdGFncyA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW50cnlPZmZzZXQgPSBkaXJTdGFydCArIGkgKiAxMiArIDI7XG4gICAgICAgIGNvbnN0IHRhZyA9IHN0cmluZ3NbZmlsZS5nZXRVaW50MTYoZW50cnlPZmZzZXQsICFiaWdFbmQpXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gcmVhZFRhZ1ZhbHVlKGZpbGUsIGVudHJ5T2Zmc2V0LCB0aWZmU3RhcnQsIGRpclN0YXJ0LCBiaWdFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiByZWFkVGFnVmFsdWUoZmlsZSwgZW50cnlPZmZzZXQsIHRpZmZTdGFydCwgZGlyU3RhcnQsIGJpZ0VuZCkge1xuICAgIGNvbnN0IHR5cGUgPSBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDIsICFiaWdFbmQpO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IGZpbGUuZ2V0VWludDMyKGVudHJ5T2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmdldFVpbnQxNihlbnRyeU9mZnNldCArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRTdHJpbmdGcm9tQnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIGxldCBvdXRzdHIgPSAnJztcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBzdGFydCArIGxlbmd0aDsgbisrKSB7XG4gICAgICAgIG91dHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZlci5nZXRVaW50OChuKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRzdHI7XG59XG4iLCJpbXBvcnQgeyBmaW5kVGFnc0luT2JqZWN0VVJMIH0gZnJvbSAnLi9leGlmX2hlbHBlcic7XG5cbmNvbnN0IEltYWdlTG9hZGVyID0ge307XG5JbWFnZUxvYWRlci5sb2FkID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgY2FsbGJhY2ssIG9mZnNldCwgc2l6ZSwgc2VxdWVuY2UpIHtcbiAgICBjb25zdCBodG1sSW1hZ2VzU3JjQXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgaHRtbEltYWdlc0FycmF5ID0gbmV3IEFycmF5KGh0bWxJbWFnZXNTcmNBcnJheS5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGxldCBpbWc7XG4gICAgbGV0IG51bTtcblxuICAgIGlmIChzZXF1ZW5jZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaHRtbEltYWdlc1NyY0FycmF5WzBdID0gZGlyZWN0b3J5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBodG1sSW1hZ2VzU3JjQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG51bSA9IChvZmZzZXQgKyBpKTtcbiAgICAgICAgICAgIGh0bWxJbWFnZXNTcmNBcnJheVtpXSA9IGAke2RpcmVjdG9yeX1pbWFnZS0keyhgMDAke251bX1gKS5zbGljZSgtMyl9LmpwZ2A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbEltYWdlc0FycmF5Lm5vdExvYWRlZCA9IFtdO1xuICAgIGh0bWxJbWFnZXNBcnJheS5hZGRJbWFnZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkubm90TG9hZGVkLnB1c2goaW1hZ2UpO1xuICAgIH07XG4gICAgaHRtbEltYWdlc0FycmF5LmxvYWRlZCA9IGZ1bmN0aW9uIChsb2FkZWRJbWcpIHtcbiAgICAgICAgY29uc3Qgbm90bG9hZGVkSW1ncyA9IGh0bWxJbWFnZXNBcnJheS5ub3RMb2FkZWQ7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgbm90bG9hZGVkSW1ncy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgaWYgKG5vdGxvYWRlZEltZ3NbeF0gPT09IGxvYWRlZEltZykge1xuICAgICAgICAgICAgICAgIG5vdGxvYWRlZEltZ3Muc3BsaWNlKHgsIDEpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ05hbWUgPSBodG1sSW1hZ2VzU3JjQXJyYXlbeV0uc3Vic3RyKGh0bWxJbWFnZXNTcmNBcnJheVt5XS5sYXN0SW5kZXhPZignLycpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRlZEltZy5zcmMubGFzdEluZGV4T2YoaW1nTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbeV0gPSB7IGltZzogbG9hZGVkSW1nIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm90bG9hZGVkSW1ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2VzIGxvYWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGZpbmRUYWdzSW5PYmplY3RVUkwoZGlyZWN0b3J5LCBbJ29yaWVudGF0aW9uJ10pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh0YWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sSW1hZ2VzQXJyYXlbMF0udGFncyA9IHRhZ3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhodG1sSW1hZ2VzQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHRtbEltYWdlc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaHRtbEltYWdlc1NyY0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBodG1sSW1hZ2VzQXJyYXkuYWRkSW1hZ2UoaW1nKTtcbiAgICAgICAgYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSk7XG4gICAgICAgIGltZy5zcmMgPSBodG1sSW1hZ2VzU3JjQXJyYXlbaV07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gYWRkT25sb2FkSGFuZGxlcihpbWcsIGh0bWxJbWFnZXNBcnJheSkge1xuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGh0bWxJbWFnZXNBcnJheS5sb2FkZWQodGhpcyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEltYWdlTG9hZGVyKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuaW1wb3J0IEltYWdlTG9hZGVyIGZyb20gJy4uL2ltYWdlX2xvYWRlcic7XG5pbXBvcnQgeyBYWVNpemUsIFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5pbXBvcnQgeyBJbnB1dFN0cmVhbUZhY3RvcnksIElucHV0U3RyZWFtLCBFdmVudEhhbmRsZXJMaXN0IH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0uZCc7XG5cbmNvbnN0IGlucHV0U3RyZWFtRmFjdG9yeTogSW5wdXRTdHJlYW1GYWN0b3J5ID0ge1xuICAgIGNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTogSW5wdXRTdHJlYW0ge1xuICAgICAgICBsZXQgX2NvbmZpZzogeyBzaXplOiBudW1iZXI7IHR5cGU6IHN0cmluZyB9IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkV2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IF9jYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0U2l6ZSgpOiB2b2lkIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIF9jYWxjdWxhdGVkV2lkdGggPSBfY29uZmlnPy5zaXplID8gd2lkdGggLyBoZWlnaHQgPiAxID8gX2NvbmZpZy5zaXplIDogTWF0aC5mbG9vcigod2lkdGggLyBoZWlnaHQpICogX2NvbmZpZy5zaXplKSA6IHdpZHRoO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBfY2FsY3VsYXRlZEhlaWdodCA9IF9jb25maWc/LnNpemUgPyB3aWR0aCAvIGhlaWdodCA+IDEgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpIDogX2NvbmZpZy5zaXplIDogaGVpZ2h0O1xuXG4gICAgICAgICAgICBfY2FudmFzU2l6ZS54ID0gX2NhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgIF9jYW52YXNTaXplLnkgPSBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0gPSB7XG4gICAgICAgICAgICBnZXRSZWFsV2lkdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvLnZpZGVvV2lkdGg7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRSZWFsSGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWRlby52aWRlb0hlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgX2NhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgICAgICAgICAgICAgIF9jYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0SW5wdXRTdHJlYW0oY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIF9jb25maWcgPSBjb25maWc7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzcmMnLCAodHlwZW9mIGNvbmZpZy5zcmMgIT09ICd1bmRlZmluZWQnKSA/IGNvbmZpZy5zcmMgOiAnJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlkZW8uZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDb25maWcoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb25maWc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwYXVzZSgpIHtcbiAgICAgICAgICAgICAgICB2aWRlby5wYXVzZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGxheSgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG4gICAgICAgICAgICAgICAgdmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChfY29uZmlnPy50eXBlICE9PSAnTGl2ZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2N1cnJlbnRUaW1lJywgdGltZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmLCBib29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9ldmVudE5hbWVzLmluZGV4T2YoZXZlbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9ldmVudEhhbmRsZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2V2ZW50SGFuZGxlcnNbZXZlbnRdLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZiwgYm9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICAgICAgICAgIF9ldmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHRyaWdnZXIoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGo7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICdjYW5yZWNvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRTaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbal0uYXBwbHkoaW5wdXRTdHJlYW0sIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0VG9wUmlnaHQodG9wUmlnaHQpIHtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnkgPSB0b3BSaWdodC55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0VG9wUmlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90b3BSaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldENhbnZhc1NpemUoc2l6ZSkge1xuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBzaXplLng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHNpemUueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldENhbnZhc1NpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jYW52YXNTaXplO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RnJhbWUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlucHV0U3RyZWFtO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSh2aWRlbyk6IElucHV0U3RyZWFtIHtcbiAgICAgICAgaWYgKHZpZGVvKSB7XG4gICAgICAgICAgICB2aWRlby5zZXRBdHRyaWJ1dGUoJ2F1dG9wbGF5JywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aGF0ID0gaW5wdXRTdHJlYW1GYWN0b3J5LmNyZWF0ZVZpZGVvU3RyZWFtKHZpZGVvKTtcbiAgICAgICAgdGhhdC5lbmRlZCA9IGZ1bmN0aW9uIGVuZGVkKCk6IGZhbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IHNpemU6IG51bWJlcjsgc2VxdWVuY2U6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIGxldCBwYXVzZWQgPSB0cnVlO1xuICAgICAgICBsZXQgbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpbWdBcnJheTogYW55W10gfCBudWxsID0gbnVsbDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAxO1xuICAgICAgICBsZXQgYmFzZVVybDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0OiBudW1iZXI7XG4gICAgICAgIGNvbnN0IF9ldmVudE5hbWVzID0gWydjYW5yZWNvcmQnLCAnZW5kZWQnXTtcbiAgICAgICAgY29uc3QgX2V2ZW50SGFuZGxlcnM6IEV2ZW50SGFuZGxlckxpc3QgPSB7fTtcbiAgICAgICAgY29uc3QgX3RvcFJpZ2h0OiBQb2ludCA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1BvaW50JyB9O1xuICAgICAgICBjb25zdCBfY2FudmFzU2l6ZTogWFlTaXplID0geyB4OiAwLCB5OiAwLCB0eXBlOiAnWFlTaXplJyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGxvYWRJbWFnZXMoKTogdm9pZCB7XG4gICAgICAgICAgICBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEltYWdlTG9hZGVyLmxvYWQoYmFzZVVybCwgKGltZ3M6IEFycmF5PHsgdGFnczogYW55OyBpbWc6IEhUTUxJbWFnZUVsZW1lbnR9PikgPT4ge1xuICAgICAgICAgICAgICAgIGltZ0FycmF5ID0gaW1ncztcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKGltZ3NbMF0udGFncyAmJiBpbWdzWzBdLnRhZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGltZ3NbMF0udGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGltZ3NbMF0uaW1nLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gaW1nc1swXS5pbWcud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCA9IGltZ3NbMF0uaW1nLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZFdpZHRoID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IF9jb25maWcuc2l6ZSA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSkgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZSA/IHdpZHRoIC8gaGVpZ2h0ID4gMSA/IE1hdGguZmxvb3IoKGhlaWdodCAvIHdpZHRoKSAqIF9jb25maWcuc2l6ZSkgOiBfY29uZmlnLnNpemUgOiBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbGN1bGF0ZWRXaWR0aDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FsY3VsYXRlZEhlaWdodDtcbiAgICAgICAgICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lSWR4ID0gMDtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0sIG9mZnNldCwgc2l6ZSwgX2NvbmZpZz8uc2VxdWVuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgajtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gX2V2ZW50SGFuZGxlcnNbZXZlbnROYW1lXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tqXS5hcHBseShpbnB1dFN0cmVhbSwgYXJncyBhcyBhbnkpOyAvLyBUT0RPOiB0eXBlc2NyaXB0IGNvbXBsYWlucyB0aGF0IGFueVtdIGlzIG5vdCB2YWxpZCBmb3IgYSBzZWNvbmQgYXJnIGZvciBhcHBseT8hXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYW55IGNvZGUgc2hhcmVkIHdpdGggdGhlIGZpcnN0IElucHV0U3RyZWFtIGFib3ZlIHNob3VsZCBiZSBzaGFyZWQgbm90IGNvcGllZFxuICAgICAgICAvLyBUT0RPOiBwdWJsaXNoRXZlbnQgbmVlZHMgYWNjZXNzIHRvIGlucHV0U3RyZWFtLCBidXQgaW5wdXRTdHJlYW0gbmVlZHMgYWNjZXNzIHRvIHB1Ymxpc2hFdmVudFxuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHdoeSBpdCdzIGEgJ3ZhcicsIHNvIGl0IGhvaXN0cyBiYWNrLiAgVGhpcyBpcyB1Z2x5LCBhbmQgc2hvdWxkIGJlIGNoYW5nZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcbiAgICAgICAgdmFyIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbSA9IHtcblxuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgobmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkV2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEhlaWdodChuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLnNlcXVlbmNlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gc3RyZWFtLnNyYztcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybCA9IHN0cmVhbS5zcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBzdHJlYW0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUb3BSaWdodCh0b3BSaWdodCkge1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC54ID0gdG9wUmlnaHQueDtcbiAgICAgICAgICAgICAgICBfdG9wUmlnaHQueSA9IHRvcFJpZ2h0Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRUb3BSaWdodCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RvcFJpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0Q2FudmFzU2l6ZShjYW52YXNTaXplKSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgICAgICBfY2FudmFzU2l6ZS55ID0gY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0Q2FudmFzU2l6ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NhbnZhc1NpemU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRGcmFtZSgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IGltZ0FycmF5Py5bZnJhbWVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVJZHggPCAoc2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFtZUlkeCsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hFdmVudCgnZW5kZWQnLCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsIi8vIFRPRE86IEl0J3MgcHJldHR5IGxpa2VseSB0aGF0IHRoaXMgc2hhcmVzIGNvZGUgd2l0aCB0aGUgYnJvd3NlciB2ZXJzaW9uLCBpbnZlc3RpZ2F0ZSB0aGF0XG5pbXBvcnQgR2V0UGl4ZWxzIGZyb20gJ2dldC1waXhlbHMnO1xuaW1wb3J0IHsgSW5wdXRTdHJlYW1GYWN0b3J5LCBJbnB1dFN0cmVhbSwgRXZlbnRIYW5kbGVyTGlzdCB9IGZyb20gJy4vaW5wdXRfc3RyZWFtLmQnO1xuaW1wb3J0IHsgUG9pbnQsIFhZU2l6ZSB9IGZyb20gJy4uLy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuXG5jb25zdCBpbnB1dFN0cmVhbUZhY3Rvcnk6IElucHV0U3RyZWFtRmFjdG9yeSA9IHtcbiAgICBjcmVhdGVWaWRlb1N0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlVmlkZW9TdHJlYW0gbm90IGF2YWlsYWJsZScpO1xuICAgIH0sXG4gICAgY3JlYXRlTGl2ZVN0cmVhbSgpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY3JlYXRlTGl2ZVN0cmVhbSBub3QgYXZhaWxhYmxlJyk7XG4gICAgfSxcbiAgICBjcmVhdGVJbWFnZVN0cmVhbSgpOiBJbnB1dFN0cmVhbSB7XG4gICAgICAgIGxldCBfY29uZmlnOiB7IG1pbWU6IHN0cmluZzsgc2l6ZTogbnVtYmVyOyBzcmM6IGFueSB9IHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XG4gICAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogZnJhbWUgc2hvdWxkIGJlIGEgdHlwZSBOZEFycmF5LCBidXQgTmRBcnJheSBkb2Vzbid0IGhhdmUgdHMgZGVmaW5pdGlvbnNcbiAgICAgICAgLy8gVE9ETzogdGhlcmUgaXMgYSB0cy1uZGFycmF5IHRoYXQgbWlnaHQgd29yaywgdGhvdWdoXG4gICAgICAgIGxldCBmcmFtZTogYW55ID0gbnVsbDtcbiAgICAgICAgbGV0IGJhc2VVcmw6IHN0cmluZztcbiAgICAgICAgY29uc3QgZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuICAgICAgICBsZXQgY2FsY3VsYXRlZEhlaWdodDogbnVtYmVyO1xuICAgICAgICBjb25zdCBfZXZlbnROYW1lcyA9IFsnY2FucmVjb3JkJywgJ2VuZGVkJ107XG4gICAgICAgIGNvbnN0IF9ldmVudEhhbmRsZXJzOiBFdmVudEhhbmRsZXJMaXN0ID0ge307XG4gICAgICAgIGNvbnN0IF90b3BSaWdodDogUG9pbnQgPSB7IHg6IDAsIHk6IDAsIHR5cGU6ICdQb2ludCcgfTtcbiAgICAgICAgY29uc3QgX2NhbnZhc1NpemU6IFhZU2l6ZSA9IHsgeDogMCwgeTogMCwgdHlwZTogJ1hZU2l6ZScgfTtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi8gLy8gZmFsc2UgZXNsaW50IGVycm9ycz8gd2VpcmQuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBmcmFtZUlkeCA9IDA7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgICAgICAgZnVuY3Rpb24gbG9hZEltYWdlcygpOiB2b2lkIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbmV3LWNhcCAqL1xuICAgICAgICAgICAgR2V0UGl4ZWxzKGJhc2VVcmwsIF9jb25maWc/Lm1pbWUsIChlcnIsIHBpeGVscykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignKioqKiBxdWFnZ2EgbG9hZEltYWdlcyBlcnJvcjonLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yIGRlY29kaW5nIHBpeGVscyBpbiBsb2FkSW1hZ2VzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnKiBJbnB1dFN0cmVhbU5vZGUgcGl4ZWxzLnNoYXBlJywgcGl4ZWxzLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGZyYW1lID0gcGl4ZWxzO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdID0gcGl4ZWxzLnNoYXBlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IF9jb25maWc/LnNpemVcbiAgICAgICAgICAgICAgICAgICAgPyB3aWR0aCAvIGhlaWdodCA+IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX2NvbmZpZy5zaXplXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguZmxvb3IoKHdpZHRoIC8gaGVpZ2h0KSAqIF9jb25maWcuc2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB3aWR0aDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkSGVpZ2h0ID0gX2NvbmZpZz8uc2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IHdpZHRoIC8gaGVpZ2h0ID4gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKChoZWlnaHQgLyB3aWR0aCkgKiBfY29uZmlnLnNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF9jb25maWcuc2l6ZVxuICAgICAgICAgICAgICAgICAgICA6IGhlaWdodDtcblxuICAgICAgICAgICAgICAgIF9jYW52YXNTaXplLnggPSBjYWxjdWxhdGVkV2lkdGg7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IGNhbGN1bGF0ZWRIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoRXZlbnQoJ2NhbnJlY29yZCcsIFtdKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcHVibGlzaEV2ZW50KGV2ZW50TmFtZTogc3RyaW5nLCBhcmdzOiBBcnJheTxhbnk+KTogdm9pZCB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9IF9ldmVudEhhbmRsZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoYW5kbGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW2pdLmFwcGx5KGlucHV0U3RyZWFtLCBhcmdzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxuICAgICAgICB2YXIgaW5wdXRTdHJlYW06IElucHV0U3RyZWFtID0ge1xuICAgICAgICAgICAgdHJpZ2dlcjogcHVibGlzaEV2ZW50LFxuXG4gICAgICAgICAgICBnZXRXaWR0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFdpZHRoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0SGVpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkSGVpZ2h0O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0V2lkdGgodykge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IHc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRIZWlnaHQoaCkge1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRIZWlnaHQgPSBoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0UmVhbFdpZHRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFJlYWxIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldElucHV0U3RyZWFtKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBfY29uZmlnID0gc3RyZWFtO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgICAgICAgICAgYmFzZVVybCA9IF9jb25maWc/LnNyYztcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBsb2FkSW1hZ2VzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbmRlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kZWQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUoKSB7fSxcblxuICAgICAgICAgICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29uZmlnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGF1c2UoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsYXkoKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDdXJyZW50VGltZSh0aW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWVJZHggPSB0aW1lO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZikge1xuICAgICAgICAgICAgICAgIGlmIChfZXZlbnROYW1lcy5pbmRleE9mKGV2ZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZXZlbnRIYW5kbGVyc1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9ldmVudEhhbmRsZXJzW2V2ZW50XS5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNsZWFyRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfZXZlbnRIYW5kbGVycykuZm9yRWFjaCgoaW5kKSA9PiBkZWxldGUgX2V2ZW50SGFuZGxlcnNbaW5kXSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIHNldFRvcFJpZ2h0KHRvcFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgX3RvcFJpZ2h0LnggPSB0b3BSaWdodC54O1xuICAgICAgICAgICAgICAgIF90b3BSaWdodC55ID0gdG9wUmlnaHQueTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFRvcFJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdG9wUmlnaHQ7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRDYW52YXNTaXplKHN6KSB7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueCA9IHN6Lng7XG4gICAgICAgICAgICAgICAgX2NhbnZhc1NpemUueSA9IHN6Lnk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRDYW52YXNTaXplKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfY2FudmFzU2l6ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldEZyYW1lKCkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5wdXRTdHJlYW07XG4gICAgfSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlucHV0U3RyZWFtRmFjdG9yeTtcbiIsImltcG9ydCBCcm93c2VySW5wdXRTdHJlYW0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtX2Jyb3dzZXInO1xuaW1wb3J0IE5vZGVJbnB1dFN0cmVhbSBmcm9tICcuL2lucHV0X3N0cmVhbS9pbnB1dF9zdHJlYW1fbm9kZSc7XG5pbXBvcnQgdHlwZSB7IElucHV0U3RyZWFtIH0gZnJvbSAnLi9pbnB1dF9zdHJlYW0vaW5wdXRfc3RyZWFtLmQnO1xuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VySW5wdXRTdHJlYW07XG5leHBvcnQgeyBOb2RlSW5wdXRTdHJlYW0gfTtcbmV4cG9ydCB0eXBlIHsgSW5wdXRTdHJlYW0gfTtcbiIsImltcG9ydCBOb2RlRnJhbWVHcmFiYmVyIGZyb20gJy4vZnJhbWVfZ3JhYmJlcl9ub2RlJztcblxuaW1wb3J0IHtcbiAgICBpbWFnZVJlZixcbiAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhLFxuICAgIGNvbXB1dGVHcmF5LFxufSBmcm9tICcuLi9jb21tb24vY3ZfdXRpbHMnO1xuXG5jb25zdCBUT19SQURJQU5TID0gTWF0aC5QSSAvIDE4MDtcblxuZnVuY3Rpb24gYWRqdXN0Q2FudmFzU2l6ZShjYW52YXMsIHRhcmdldFNpemUpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoICE9PSB0YXJnZXRTaXplLngpIHtcbiAgICAgICAgaWYgKEVOVi5kZXZlbG9wbWVudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IGNhbnZhcy1zaXplIG5lZWRzIHRvIGJlIGFkanVzdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLndpZHRoID0gdGFyZ2V0U2l6ZS54O1xuICAgIH1cbiAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gdGFyZ2V0U2l6ZS55KSB7XG4gICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXQVJOSU5HOiBjYW52YXMtc2l6ZSBuZWVkcyB0byBiZSBhZGp1c3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRTaXplLnk7XG4gICAgfVxufVxuXG5jb25zdCBGcmFtZUdyYWJiZXIgPSB7fTtcblxuRnJhbWVHcmFiYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbnB1dFN0cmVhbSwgY2FudmFzKSB7XG4gICAgY29uc3QgX3RoYXQgPSB7fTtcbiAgICBjb25zdCBfc3RyZWFtQ29uZmlnID0gaW5wdXRTdHJlYW0uZ2V0Q29uZmlnKCk7XG4gICAgY29uc3QgX3ZpZGVvU2l6ZSA9IGltYWdlUmVmKGlucHV0U3RyZWFtLmdldFJlYWxXaWR0aCgpLCBpbnB1dFN0cmVhbS5nZXRSZWFsSGVpZ2h0KCkpO1xuICAgIGNvbnN0IF9jYW52YXNTaXplID0gaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpO1xuICAgIGNvbnN0IF9zaXplID0gaW1hZ2VSZWYoaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkpO1xuICAgIGNvbnN0IHRvcFJpZ2h0ID0gaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICBjb25zdCBfc3ggPSB0b3BSaWdodC54O1xuICAgIGNvbnN0IF9zeSA9IHRvcFJpZ2h0Lnk7XG4gICAgbGV0IF9jYW52YXM7XG4gICAgbGV0IF9jdHggPSBudWxsO1xuICAgIGxldCBfZGF0YSA9IG51bGw7XG5cbiAgICBfY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIF9jYW52YXMud2lkdGggPSBfY2FudmFzU2l6ZS54O1xuICAgIF9jYW52YXMuaGVpZ2h0ID0gX2NhbnZhc1NpemUueTtcbiAgICBfY3R4ID0gX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9kYXRhID0gbmV3IFVpbnQ4QXJyYXkoX3NpemUueCAqIF9zaXplLnkpO1xuICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyYW1lR3JhYmJlcicsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpemU6IF9zaXplLFxuICAgICAgICAgICAgdG9wUmlnaHQsXG4gICAgICAgICAgICB2aWRlb1NpemU6IF92aWRlb1NpemUsXG4gICAgICAgICAgICBjYW52YXNTaXplOiBfY2FudmFzU2l6ZSxcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZXMgdGhlIGdpdmVuIGFycmF5IGFzIGZyYW1lLWJ1ZmZlclxuICAgICAqL1xuICAgIF90aGF0LmF0dGFjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfZGF0YSA9IGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVzZWQgZnJhbWUtYnVmZmVyXG4gICAgICovXG4gICAgX3RoYXQuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgZnJhbWUgZnJvbSB0aGUgaW5wdXQtc3RyZWFtIGFuZCBwdXRzIGludG8gdGhlIGZyYW1lLWJ1ZmZlci5cbiAgICAgKiBUaGUgaW1hZ2UtZGF0YSBpcyBjb252ZXJ0ZWQgdG8gZ3JheS1zY2FsZSBhbmQgdGhlbiBoYWxmLXNhbXBsZWQgaWYgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBfdGhhdC5ncmFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkb0hhbGZTYW1wbGUgPSBfc3RyZWFtQ29uZmlnLmhhbGZTYW1wbGU7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gaW5wdXRTdHJlYW0uZ2V0RnJhbWUoKTtcbiAgICAgICAgbGV0IGRyYXdhYmxlID0gZnJhbWU7XG4gICAgICAgIGxldCBkcmF3QW5nbGUgPSAwO1xuICAgICAgICBsZXQgY3R4RGF0YTtcbiAgICAgICAgaWYgKGRyYXdhYmxlKSB7XG4gICAgICAgICAgICBhZGp1c3RDYW52YXNTaXplKF9jYW52YXMsIF9jYW52YXNTaXplKTtcbiAgICAgICAgICAgIGlmIChfc3RyZWFtQ29uZmlnLnR5cGUgPT09ICdJbWFnZVN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICBkcmF3YWJsZSA9IGZyYW1lLmltZztcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUudGFncyAmJiBmcmFtZS50YWdzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZnJhbWUudGFncy5vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdBbmdsZSA9IDkwICogVE9fUkFESUFOUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3QW5nbGUgPSAtOTAgKiBUT19SQURJQU5TO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZHJhd0FuZ2xlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoX2NhbnZhc1NpemUueCAvIDIsIF9jYW52YXNTaXplLnkgLyAyKTtcbiAgICAgICAgICAgICAgICBfY3R4LnJvdGF0ZShkcmF3QW5nbGUpO1xuICAgICAgICAgICAgICAgIF9jdHguZHJhd0ltYWdlKGRyYXdhYmxlLCAtX2NhbnZhc1NpemUueSAvIDIsIC1fY2FudmFzU2l6ZS54IC8gMiwgX2NhbnZhc1NpemUueSwgX2NhbnZhc1NpemUueCk7XG4gICAgICAgICAgICAgICAgX2N0eC5yb3RhdGUoLWRyYXdBbmdsZSk7XG4gICAgICAgICAgICAgICAgX2N0eC50cmFuc2xhdGUoLV9jYW52YXNTaXplLnggLyAyLCAtX2NhbnZhc1NpemUueSAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfY3R4LmRyYXdJbWFnZShkcmF3YWJsZSwgMCwgMCwgX2NhbnZhc1NpemUueCwgX2NhbnZhc1NpemUueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eERhdGEgPSBfY3R4LmdldEltYWdlRGF0YShfc3gsIF9zeSwgX3NpemUueCwgX3NpemUueSkuZGF0YTtcbiAgICAgICAgICAgIGlmIChkb0hhbGZTYW1wbGUpIHtcbiAgICAgICAgICAgICAgICBncmF5QW5kSGFsZlNhbXBsZUZyb21DYW52YXNEYXRhKGN0eERhdGEsIF9zaXplLCBfZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVHcmF5KGN0eERhdGEsIF9kYXRhLCBfc3RyZWFtQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgX3RoYXQuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9zaXplO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoYXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGcmFtZUdyYWJiZXI7XG5leHBvcnQgeyBOb2RlRnJhbWVHcmFiYmVyIH07XG4iLCIvKiBXb3JrZXIgZnVuY3Rpb25zLiBUaGVzZSBhcmUgc3RyYWlnaHQgZnJvbSB0aGUgb3JpZ2luYWwgcXVhZ2dhLmpzIGZpbGUuXG4gKiBOb3QgcHJlc2VudGx5IHVzZWQsIGFzIHdvcmtlciBzdXBwb3J0IGlzIG5vbi1mdW5jdGlvbmFsLiAgS2VlcGluZyB0aGVtIGFyb3VuZCB0ZW1wb3JhcmlseVxuICogdG8gcmVmZXIgdG8gdW50aWwgaXQgaXMgcmUtaW1wbGVtZW50ZWQuIFdlIG1heSBiZSBhYmxlIHRvIGZpeC91c2Ugc29tZSBvZiB0aGlzLlxuICovXG5cbmltcG9ydCB7IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gXCIuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYVwiO1xuXG4vLyBUT0RPOiBuZWVkIGEgdHlwZXNjcmlwdCBpbnRlcmZhY2UgZm9yIEZyYW1lR3JhYmJlclxuXG5pbnRlcmZhY2UgUVdvcmtlclRocmVhZCB7XG4gICAgaW1hZ2VEYXRhOiBVaW50OEFycmF5O1xuICAgIGJ1c3k6IGJvb2xlYW47XG4gICAgd29ya2VyOiBXb3JrZXI7XG59XG5cbmxldCB3b3JrZXJQb29sOiBBcnJheTxRV29ya2VyVGhyZWFkPiA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV29ya2VycyhmcmFtZUdyYWJiZXI6IGFueSkge1xuICAgIGxldCBhdmFpbGFibGVXb3JrZXI6IFFXb3JrZXJUaHJlYWQ7XG4gICAgaWYgKHdvcmtlclBvb2wubGVuZ3RoKSB7XG4gICAgICAgIGF2YWlsYWJsZVdvcmtlciA9IHdvcmtlclBvb2wuZmlsdGVyKCh3b3JrZXJUaHJlYWQpID0+ICF3b3JrZXJUaHJlYWQuYnVzeSlbMF07XG4gICAgICAgIGlmIChhdmFpbGFibGVXb3JrZXIpIHtcbiAgICAgICAgICAgIGZyYW1lR3JhYmJlci5hdHRhY2hEYXRhKGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEpO1xuICAgICAgICAgICAgaWYgKGZyYW1lR3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVXb3JrZXIuYnVzeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlV29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3Byb2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGF2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEsXG4gICAgICAgICAgICAgICAgfSwgW2F2YWlsYWJsZVdvcmtlci5pbWFnZURhdGEuYnVmZmVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29uZmlnRm9yV29ya2VyKGNvbmZpZzogUXVhZ2dhSlNDb25maWdPYmplY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb25maWcsXG4gICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAuLi5jb25maWcuaW5wdXRTdHJlYW0sXG4gICAgICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlKGZhY3RvcnkpIHtcbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICB2YXIgUXVhZ2dhID0gZmFjdG9yeSgpLmRlZmF1bHQ7XG4gICAgICAgIGlmICghUXVhZ2dhKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgJ2V2ZW50JzogJ2Vycm9yJywgbWVzc2FnZTogJ1F1YWdnYSBjb3VsZCBub3QgYmUgY3JlYXRlZCcgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4vLyBAdHMtaWdub3JlXG4gICAgdmFyIGltYWdlV3JhcHBlcjtcblxuLy8gQHRzLWlnbm9yZVxuICAgIGZ1bmN0aW9uIG9uUHJvY2Vzc2VkKHJlc3VsdCkge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICdldmVudCc6ICdwcm9jZXNzZWQnLFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaW1hZ2VEYXRhOiBpbWFnZVdyYXBwZXIuZGF0YSxcbiAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuLy8gQHRzLWlnbm9yZVxuICAgICAgICB9LCBbaW1hZ2VXcmFwcGVyLmRhdGEuYnVmZmVyXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd29ya2VySW50ZXJmYWNlUmVhZHkoKSB7XG4gICAgICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgJ2V2ZW50JzogJ2luaXRpYWxpemVkJyxcbi8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGltYWdlRGF0YTogaW1hZ2VXcmFwcGVyLmRhdGEsXG4vLyBAdHMtaWdub3JlXG4gICAgICAgIH0sIFtpbWFnZVdyYXBwZXIuZGF0YS5idWZmZXJdKTtcbiAgICB9XG5cbi8vIEB0cy1pZ25vcmVcbiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLmRhdGEuY21kID09PSAnaW5pdCcpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBlLmRhdGEuY29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIgPSBuZXcgUXVhZ2dhLkltYWdlV3JhcHBlcih7XG4gICAgICAgICAgICAgICAgeDogZS5kYXRhLnNpemUueCxcbiAgICAgICAgICAgICAgICB5OiBlLmRhdGEuc2l6ZS55LFxuICAgICAgICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgUXVhZ2dhLmluaXQoY29uZmlnLCB3b3JrZXJJbnRlcmZhY2VSZWFkeSwgaW1hZ2VXcmFwcGVyKTtcbiAgICAgICAgICAgIFF1YWdnYS5vblByb2Nlc3NlZChvblByb2Nlc3NlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3Byb2Nlc3MnKSB7XG4vLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpbWFnZVdyYXBwZXIuZGF0YSA9IG5ldyBVaW50OEFycmF5KGUuZGF0YS5pbWFnZURhdGEpO1xuICAgICAgICAgICAgUXVhZ2dhLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3NldFJlYWRlcnMnKSB7XG4gICAgICAgICAgICBRdWFnZ2Euc2V0UmVhZGVycyhlLmRhdGEucmVhZGVycyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmNtZCA9PT0gJ3JlZ2lzdGVyUmVhZGVyJykge1xuICAgICAgICAgICAgUXVhZ2dhLnJlZ2lzdGVyUmVhZGVyKGUuZGF0YS5uYW1lLCBlLmRhdGEucmVhZGVyKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlV29ya2VyQmxvYigpIHtcbiAgICB2YXIgYmxvYixcbiAgICAgICAgZmFjdG9yeVNvdXJjZTtcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBfX2ZhY3RvcnlTb3VyY2VfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBmYWN0b3J5U291cmNlID0gX19mYWN0b3J5U291cmNlX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgIGJsb2IgPSBuZXcgQmxvYihbJygnICsgd29ya2VySW50ZXJmYWNlLnRvU3RyaW5nKCkgKyAnKSgnICsgZmFjdG9yeVNvdXJjZSArICcpOyddLFxuICAgICAgICB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFdvcmtlcihjb25maWc6IFF1YWdnYUpTQ29uZmlnT2JqZWN0LCBpbnB1dFN0cmVhbTogYW55LCBjYjogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBibG9iVVJMID0gZ2VuZXJhdGVXb3JrZXJCbG9iKCk7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihibG9iVVJMKTtcblxuICAgIGNvbnN0IHdvcmtlclRocmVhZDogUVdvcmtlclRocmVhZCA9IHtcbiAgICAgICAgd29ya2VyLFxuICAgICAgICBpbWFnZURhdGE6IG5ldyBVaW50OEFycmF5KGlucHV0U3RyZWFtLmdldFdpZHRoKCkgKiBpbnB1dFN0cmVhbS5nZXRIZWlnaHQoKSksXG4gICAgICAgIGJ1c3k6IHRydWUsXG4gICAgfTtcblxuICAgIHdvcmtlclRocmVhZC53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gJ2luaXRpYWxpemVkJykge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChibG9iVVJMKTtcbiAgICAgICAgICAgIHdvcmtlclRocmVhZC5idXN5ID0gZmFsc2U7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2Iod29ya2VyVGhyZWFkKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEuZXZlbnQgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZS5kYXRhLmltYWdlRGF0YSk7XG4gICAgICAgICAgICB3b3JrZXJUaHJlYWQuYnVzeSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogaG93IHRvIHRocmVhZCBwdWJsaXNoUmVzdWx0IGludG8gaGVyZT9cbiAgICAgICAgICAgIC8vIHB1Ymxpc2hSZXN1bHQoZS5kYXRhLnJlc3VsdCwgd29ya2VyVGhyZWFkLmltYWdlRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBpZiAoRU5WLmRldmVsb3BtZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBlcnJvcjogJyArIGUuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3b3JrZXJUaHJlYWQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY21kOiAnaW5pdCcsXG4gICAgICAgIHNpemU6IHsgeDogaW5wdXRTdHJlYW0uZ2V0V2lkdGgoKSwgeTogaW5wdXRTdHJlYW0uZ2V0SGVpZ2h0KCkgfSxcbiAgICAgICAgaW1hZ2VEYXRhOiB3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLFxuICAgICAgICBjb25maWc6IGNvbmZpZ0Zvcldvcmtlcihjb25maWcpLFxuICAgIH0sIFt3b3JrZXJUaHJlYWQuaW1hZ2VEYXRhLmJ1ZmZlcl0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0V29ya2VyUG9vbChjYXBhY2l0eTogbnVtYmVyLCBjb25maWc/OiBRdWFnZ2FKU0NvbmZpZ09iamVjdCwgaW5wdXRTdHJlYW0/OiBhbnksIGNiPzogRnVuY3Rpb24pIHtcbiAgICBjb25zdCBpbmNyZWFzZUJ5ID0gY2FwYWNpdHkgLSB3b3JrZXJQb29sLmxlbmd0aDtcbiAgICBpZiAoaW5jcmVhc2VCeSA9PT0gMCAmJiBjYikge1xuICAgICAgICBjYigpO1xuICAgIH0gZWxzZSBpZiAoaW5jcmVhc2VCeSA8IDApIHtcbiAgICAgICAgY29uc3Qgd29ya2Vyc1RvVGVybWluYXRlID0gd29ya2VyUG9vbC5zbGljZShpbmNyZWFzZUJ5KTtcbiAgICAgICAgd29ya2Vyc1RvVGVybWluYXRlLmZvckVhY2goZnVuY3Rpb24gKHdvcmtlclRocmVhZCkge1xuICAgICAgICAgICAgd29ya2VyVGhyZWFkLndvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIGlmIChFTlYuZGV2ZWxvcG1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnV29ya2VyIHRlcm1pbmF0ZWQhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXJQb29sID0gd29ya2VyUG9vbC5zbGljZSgwLCBpbmNyZWFzZUJ5KTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd29ya2VySW5pdGlhbGl6ZWQgPSAod29ya2VyVGhyZWFkOiBRV29ya2VyVGhyZWFkKSA9PiB7XG4gICAgICAgICAgICB3b3JrZXJQb29sLnB1c2god29ya2VyVGhyZWFkKTtcbiAgICAgICAgICAgIGlmICh3b3JrZXJQb29sLmxlbmd0aCA+PSBjYXBhY2l0eSAmJiBjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmNyZWFzZUJ5OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbml0V29ya2VyKGNvbmZpZywgaW5wdXRTdHJlYW0sIHdvcmtlckluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdzZXRSZWFkZXJzJywgcmVhZGVycyB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclJlYWRlcihuYW1lOiBzdHJpbmcsIHJlYWRlcjogYW55KSB7XG4gICAgd29ya2VyUG9vbC5mb3JFYWNoKCh3b3JrZXJUaHJlYWQpID0+IHdvcmtlclRocmVhZC53b3JrZXIucG9zdE1lc3NhZ2UoeyBjbWQ6ICdyZWdpc3RlclJlYWRlcicsIG5hbWUsIHJlYWRlciB9KSk7XG59XG4iLCJpbXBvcnQgeyBJbnB1dFN0cmVhbVR5cGUgfSBmcm9tICcuLi8uLi90eXBlLWRlZmluaXRpb25zL3F1YWdnYS5kJztcblxuLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgYW4gSW5wdXRTdHJlYW0gdHlwZXNjcmlwdCBpbnRlcmZhY2UsIHNvIHdlIGRvbid0IGhhdmUgYW4gXCJhbnlcIiBpbiB0aGUgbmV4dCBsaW5lXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cElucHV0U3RyZWFtKHR5cGU6IElucHV0U3RyZWFtVHlwZSA9ICdMaXZlU3RyZWFtJywgdmlld3BvcnQ6IEVsZW1lbnQgfCBudWxsLCBJbnB1dFN0cmVhbTogYW55KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ1ZpZGVvU3RyZWFtJzoge1xuICAgICAgICAgICAgY29uc3QgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2aWRlbyxcbiAgICAgICAgICAgICAgICBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlVmlkZW9TdHJlYW0odmlkZW8pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdJbWFnZVN0cmVhbSc6XG4gICAgICAgICAgICByZXR1cm4geyBpbnB1dFN0cmVhbTogSW5wdXRTdHJlYW0uY3JlYXRlSW1hZ2VTdHJlYW0oKSB9O1xuICAgICAgICBjYXNlICdMaXZlU3RyZWFtJzoge1xuICAgICAgICAgICAgbGV0IHZpZGVvOiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICB2aWRlbyA9IHZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgaWYgKCF2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKHZpZGVvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZpZGVvLFxuICAgICAgICAgICAgICAgIGlucHV0U3RyZWFtOiBJbnB1dFN0cmVhbS5jcmVhdGVMaXZlU3RyZWFtKHZpZGVvKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCogc2V0dXBJbnB1dFN0cmVhbSBpbnZhbGlkIHR5cGUgJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmlkZW86IG51bGwsIGlucHV0U3RyZWFtOiBudWxsIH07XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vdHlwZS1kZWZpbml0aW9ucy9xdWFnZ2EuZCc7XG5cbmV4cG9ydCB0eXBlIEJveCA9IEFycmF5PFsgbnVtYmVyLCBudW1iZXIgXT47XG5cbmV4cG9ydCB0eXBlIExpbmUgPSBbIFBvaW50LCBQb2ludCBdO1xuXG5leHBvcnQgZnVuY3Rpb24gbW92ZUJveChib3g6IEJveCwgeE9mZnNldDogbnVtYmVyLCB5T2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICBsZXQgY29ybmVyID0gYm94Lmxlbmd0aDtcbiAgICB3aGlsZSAoY29ybmVyLS0pIHtcbiAgICAgICAgYm94W2Nvcm5lcl1bMF0gKz0geE9mZnNldDtcbiAgICAgICAgYm94W2Nvcm5lcl1bMV0gKz0geU9mZnNldDtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlTGluZShsaW5lOiBMaW5lLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIGxpbmVbMF0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMF0ueSArPSB5T2Zmc2V0O1xuICAgIGxpbmVbMV0ueCArPSB4T2Zmc2V0O1xuICAgIGxpbmVbMV0ueSArPSB5T2Zmc2V0O1xufVxuIiwiaW1wb3J0IHsgY2xvbmUgfSBmcm9tICdnbC12ZWMyJztcbmltcG9ydCB7IFF1YWdnYUNvbnRleHQgfSBmcm9tICcuLi9RdWFnZ2FDb250ZXh0JztcbmltcG9ydCBfaW5pdEJ1ZmZlcnMgZnJvbSAnLi9pbml0QnVmZmVycyc7XG5pbXBvcnQgX2dldFZpZXdQb3J0IGZyb20gJy4vZ2V0Vmlld1BvcnQnO1xuaW1wb3J0IEltYWdlV3JhcHBlciBmcm9tICcuLi9jb21tb24vaW1hZ2Vfd3JhcHBlcic7XG5pbXBvcnQgQmFyY29kZURlY29kZXIgZnJvbSAnLi4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IF9pbml0Q2FudmFzIGZyb20gJy4vaW5pdENhbnZhcyc7XG5pbXBvcnQgQmFyY29kZUxvY2F0b3IgZnJvbSAnLi4vbG9jYXRvci9iYXJjb2RlX2xvY2F0b3InO1xuaW1wb3J0IEJyb3dzZXJJbnB1dFN0cmVhbSwgeyBOb2RlSW5wdXRTdHJlYW0gfSBmcm9tICcuLi9pbnB1dC9pbnB1dF9zdHJlYW1fZmFjdG9yeSc7XG5pbXBvcnQgQnJvd3NlckZyYW1lR3JhYmJlciwgeyBOb2RlRnJhbWVHcmFiYmVyIH0gZnJvbSAnLi4vaW5wdXQvZnJhbWVfZ3JhYmJlcic7XG5pbXBvcnQgKiBhcyBRV29ya2VycyBmcm9tICcuL3F3b3JrZXInO1xuaW1wb3J0IHNldHVwSW5wdXRTdHJlYW0gZnJvbSAnLi9zZXR1cElucHV0U3RyZWFtJztcbmltcG9ydCBDYW1lcmFBY2Nlc3MgZnJvbSAnLi4vaW5wdXQvY2FtZXJhX2FjY2Vzcyc7XG5pbXBvcnQgeyBCYXJjb2RlSW5mbyB9IGZyb20gJy4uL3JlYWRlci9iYXJjb2RlX3JlYWRlcic7XG5pbXBvcnQgeyBtb3ZlTGluZSwgbW92ZUJveCB9IGZyb20gJy4vdHJhbnNmb3JtJztcbmltcG9ydCB7IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBRdWFnZ2FKU1JlYWRlckNvbmZpZyB9IGZyb20gJy4uLy4uL3R5cGUtZGVmaW5pdGlvbnMvcXVhZ2dhLmQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi9jb21tb24vZXZlbnRzJztcblxuY29uc3QgSW5wdXRTdHJlYW0gPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IE5vZGVJbnB1dFN0cmVhbSA6IEJyb3dzZXJJbnB1dFN0cmVhbTtcbmNvbnN0IEZyYW1lR3JhYmJlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gTm9kZUZyYW1lR3JhYmJlciA6IEJyb3dzZXJGcmFtZUdyYWJiZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YWdnYSB7XG4gICAgY29udGV4dDogUXVhZ2dhQ29udGV4dCA9IG5ldyBRdWFnZ2FDb250ZXh0KCk7XG5cbiAgICBpbml0QnVmZmVycyhpbWFnZVdyYXBwZXI/OiBJbWFnZVdyYXBwZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQuY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dEltYWdlV3JhcHBlciwgYm94U2l6ZSB9ID0gX2luaXRCdWZmZXJzKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgaW1hZ2VXcmFwcGVyLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNvbmZpZy5sb2NhdG9yLFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXIgPSBpbnB1dEltYWdlV3JhcHBlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJveFNpemUgPSBib3hTaXplO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcj86IEltYWdlV3JhcHBlcik6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKGltYWdlV3JhcHBlcik7XG4gICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyID0gQmFyY29kZURlY29kZXIuY3JlYXRlKHRoaXMuY29udGV4dC5jb25maWcuZGVjb2RlciwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBnZXRWaWV3UG9ydCgpOiBFbGVtZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZXh0LmNvbmZpZyB8fCAhdGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIHJldHVybiBfZ2V0Vmlld1BvcnQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZWFkeShjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0ucGxheSgpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGluaXRDYW52YXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IF9pbml0Q2FudmFzKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdHgsIGRvbSB9ID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmRvbS5pbWFnZSA9IGRvbS5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20ub3ZlcmxheSA9IGRvbS5vdmVybGF5O1xuICAgICAgICB0aGlzLmNvbnRleHQuY2FudmFzQ29udGFpbmVyLmN0eC5pbWFnZSA9IGN0eC5pbWFnZTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5jdHgub3ZlcmxheSA9IGN0eC5vdmVybGF5O1xuICAgIH1cblxuICAgIGNhblJlY29yZCA9IChjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBCYXJjb2RlTG9jYXRvci5jaGVja0ltYWdlQ29uc3RyYWludHModGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLCB0aGlzLmNvbnRleHQuY29uZmlnPy5sb2NhdG9yKTtcbiAgICAgICAgdGhpcy5pbml0Q2FudmFzKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIgPSBGcmFtZUdyYWJiZXIuY3JlYXRlKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmNhbnZhc0NvbnRhaW5lci5kb20uaW1hZ2UsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2wodGhpcy5jb250ZXh0LmNvbmZpZy5udW1PZldvcmtlcnMsXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuY29uZmlnLFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmlucHV0U3RyZWFtLFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5udW1PZldvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5KGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpbml0SW5wdXRTdHJlYW0oY2FsbGJhY2s6IChlcnI/OiBFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5jb25maWcgfHwgIXRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR5cGU6IGlucHV0VHlwZSwgY29uc3RyYWludHMgfSA9IHRoaXMuY29udGV4dC5jb25maWcuaW5wdXRTdHJlYW07XG4gICAgICAgIGNvbnN0IHsgdmlkZW8sIGlucHV0U3RyZWFtIH0gPSBzZXR1cElucHV0U3RyZWFtKGlucHV0VHlwZSwgdGhpcy5nZXRWaWV3UG9ydCgpLCBJbnB1dFN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gJ0xpdmVTdHJlYW0nICYmIHZpZGVvKSB7XG4gICAgICAgICAgICBDYW1lcmFBY2Nlc3MucmVxdWVzdCh2aWRlbywgY29uc3RyYWludHMpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gaW5wdXRTdHJlYW0udHJpZ2dlcignY2FucmVjb3JkJykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGNhbGxiYWNrKGVycikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0QXR0cmlidXRlKCdwcmVsb2FkJywgJ2F1dG8nKTtcbiAgICAgICAgaW5wdXRTdHJlYW0uc2V0SW5wdXRTdHJlYW0odGhpcy5jb250ZXh0LmNvbmZpZy5pbnB1dFN0cmVhbSk7XG4gICAgICAgIGlucHV0U3RyZWFtLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnJlY29yZCcsIHRoaXMuY2FuUmVjb3JkLmJpbmQodW5kZWZpbmVkLCBjYWxsYmFjaykpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbSA9IGlucHV0U3RyZWFtO1xuICAgIH1cblxuICAgIGdldEJvdW5kaW5nQm94ZXMoKTogQXJyYXk8QXJyYXk8bnVtYmVyPj4gfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb25maWc/LmxvY2F0ZSA/IEJhcmNvZGVMb2NhdG9yLmxvY2F0ZSgpXG4gICAgICAgICAgICA6IFtbXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbMF0pLFxuICAgICAgICAgICAgICAgIGNsb25lKHRoaXMuY29udGV4dC5ib3hTaXplWzFdKSxcbiAgICAgICAgICAgICAgICBjbG9uZSh0aGlzLmNvbnRleHQuYm94U2l6ZVsyXSksXG4gICAgICAgICAgICAgICAgY2xvbmUodGhpcy5jb250ZXh0LmJveFNpemVbM10pLFxuICAgICAgICAgICAgXV07XG4gICAgfVxuXG4gICAgLy8gVE9ETzogbmVlZCBhIHR5cGVzY3JpcHQgdHlwZSBmb3IgcmVzdWx0IGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICB0cmFuc2Zvcm1SZXN1bHQocmVzdWx0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0VG9wUmlnaHQoKTtcbiAgICAgICAgY29uc3QgeE9mZnNldCA9IHRvcFJpZ2h0Lng7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSB0b3BSaWdodC55O1xuXG4gICAgICAgIGlmICh4T2Zmc2V0ID09PSAwICYmIHlPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQuYmFyY29kZXMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEJhcmNvZGVJbmZvIG1heSBub3QgYmUgdGhlIHJpZ2h0IHR5cGUgaGVyZS5cbiAgICAgICAgICAgIHJlc3VsdC5iYXJjb2Rlcy5mb3JFYWNoKChiYXJjb2RlOiBCYXJjb2RlSW5mbykgPT4gdGhpcy50cmFuc2Zvcm1SZXN1bHQoYmFyY29kZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5saW5lICYmIHJlc3VsdC5saW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbW92ZUxpbmUocmVzdWx0LmxpbmUsIHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdC5ib3gpIHtcbiAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveCwgeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0LmJveGVzICYmIHJlc3VsdC5ib3hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1vdmVCb3gocmVzdWx0LmJveGVzW2ldLCB4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFkZFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0LCBpbWFnZURhdGE6IEFycmF5PG51bWJlcj4pOiB2b2lkIHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEgfHwgIXRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBkYXRhIHN0cnVjdHVyZSBob2xkcyBhIFwiYmFyY29kZXNcIiByZXN1bHQsIGlmIGFueS4uLlxuICAgICAgICBpZiAocmVzdWx0LmJhcmNvZGVzKSB7XG4gICAgICAgICAgICByZXN1bHQuYmFyY29kZXMuZmlsdGVyKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChiYXJjb2RlOiBRdWFnZ2FKU1Jlc3VsdE9iamVjdCkgPT4gdGhpcy5hZGRSZXN1bHQoYmFyY29kZSwgaW1hZ2VEYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmNvZGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXN1bHRDb2xsZWN0b3IuYWRkUmVzdWx0KFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5wdXRTdHJlYW0uZ2V0Q2FudmFzU2l6ZSgpLFxuICAgICAgICAgICAgICAgIHJlc3VsdC5jb2RlUmVzdWx0LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gICAgaGFzQ29kZVJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIShyZXN1bHQgJiYgKHJlc3VsdC5iYXJjb2Rlc1xuICAgICAgICAgICAgPyByZXN1bHQuYmFyY29kZXMuc29tZSgoYmFyY29kZSkgPT4gYmFyY29kZS5jb2RlUmVzdWx0KVxuICAgICAgICAgICAgOiByZXN1bHQuY29kZVJlc3VsdCkpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgcHVibGlzaFJlc3VsdChyZXN1bHQ6IFF1YWdnYUpTUmVzdWx0T2JqZWN0IHwgbnVsbCA9IG51bGwsIGltYWdlRGF0YT86IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcmVzdWx0VG9QdWJsaXNoOiBBcnJheTxRdWFnZ2FKU1Jlc3VsdE9iamVjdD4gfCBRdWFnZ2FKU1Jlc3VsdE9iamVjdCB8IG51bGwgPSByZXN1bHQ7XG5cbiAgICAgICAgaWYgKHJlc3VsdCAmJiB0aGlzLmNvbnRleHQub25VSVRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzdWx0KHJlc3VsdCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdFRvUHVibGlzaCA9IHJlc3VsdC5iYXJjb2RlcyB8fCByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMucHVibGlzaCgncHJvY2Vzc2VkJywgcmVzdWx0VG9QdWJsaXNoIGFzIG5ldmVyKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29kZVJlc3VsdChyZXN1bHQgYXMgUXVhZ2dhSlNSZXN1bHRPYmplY3QpKSB7XG4gICAgICAgICAgICBFdmVudHMucHVibGlzaCgnZGV0ZWN0ZWQnLCByZXN1bHRUb1B1Ymxpc2ggYXMgbmV2ZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9jYXRlQW5kRGVjb2RlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0Qm91bmRpbmdCb3hlcygpO1xuICAgICAgICBpZiAoYm94ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZVJlc3VsdCA9IHRoaXMuY29udGV4dC5kZWNvZGVyLmRlY29kZUZyb21Cb3VuZGluZ0JveGVzKGJveGVzKSB8fCB7fTtcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5ib3hlcyA9IGJveGVzO1xuICAgICAgICAgICAgdGhpcy5wdWJsaXNoUmVzdWx0KGRlY29kZVJlc3VsdCwgdGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlUmVzdWx0ID0gdGhpcy5jb250ZXh0LmRlY29kZXIuZGVjb2RlRnJvbUltYWdlKHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoaW1hZ2VSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2hSZXN1bHQoaW1hZ2VSZXN1bHQsIHRoaXMuY29udGV4dC5pbnB1dEltYWdlV3JhcHBlcj8uZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaFJlc3VsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlID0gKCk6IHZvaWQgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlcnNVcGRhdGVkID0gUVdvcmtlcnMudXBkYXRlV29ya2Vycyh0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyKTtcbiAgICAgICAgICAgIGlmICghd29ya2Vyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZnJhbWVncmFiYmVyLmF0dGFjaERhdGEodGhpcy5jb250ZXh0LmlucHV0SW1hZ2VXcmFwcGVyPy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3b3JrZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhdGVBbmREZWNvZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5mcmFtZWdyYWJiZXIuYXR0YWNoRGF0YSh0aGlzLmNvbnRleHQuaW5wdXRJbWFnZVdyYXBwZXI/LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZyYW1lZ3JhYmJlci5ncmFiKCk7XG4gICAgICAgICAgICB0aGlzLmxvY2F0ZUFuZERlY29kZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHN0YXJ0Q29udGludW91c1VwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgbGV0IG5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjb25zdCBkZWxheSA9IDEwMDAgLyAodGhpcy5jb250ZXh0LmNvbmZpZz8uZnJlcXVlbmN5IHx8IDYwKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgbmV3RnJhbWUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0IHx8IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmICghY29udGV4dC5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgbmV4dCArPSBkZWxheTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdGcmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgbmV3RnJhbWUocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cblxuICAgIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0Lm9uVUlUaHJlYWQgJiYgdGhpcy5jb250ZXh0LmNvbmZpZz8uaW5wdXRTdHJlYW0/LnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbnRpbnVvdXNVcGRhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHQuc3RvcHBlZCA9IHRydWU7XG4gICAgICAgIFFXb3JrZXJzLmFkanVzdFdvcmtlclBvb2woMCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuY29uZmlnPy5pbnB1dFN0cmVhbSAmJiB0aGlzLmNvbnRleHQuY29uZmlnLmlucHV0U3RyZWFtLnR5cGUgPT09ICdMaXZlU3RyZWFtJykge1xuICAgICAgICAgICAgQ2FtZXJhQWNjZXNzLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbnB1dFN0cmVhbS5jbGVhckV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFJlYWRlcnMocmVhZGVyczogQXJyYXk8UXVhZ2dhSlNSZWFkZXJDb25maWc+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuZGVjb2Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmRlY29kZXIuc2V0UmVhZGVycyhyZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBRV29ya2Vycy5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyUmVhZGVyKG5hbWU6IHN0cmluZywgcmVhZGVyOiBRdWFnZ2FKU1JlYWRlckNvbmZpZyk6IHZvaWQge1xuICAgICAgICBCYXJjb2RlRGVjb2Rlci5yZWdpc3RlclJlYWRlcihuYW1lLCByZWFkZXIpO1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0LmRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5kZWNvZGVyLnJlZ2lzdGVyUmVhZGVyKG5hbWUsIHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgUVdvcmtlcnMucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgVHlwZURlZnMgZnJvbSAnLi9jb21tb24vdHlwZWRlZnMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQgSW1hZ2VXcmFwcGVyIGZyb20gJy4vY29tbW9uL2ltYWdlX3dyYXBwZXInO1xuaW1wb3J0IEJhcmNvZGVEZWNvZGVyIGZyb20gJy4vZGVjb2Rlci9iYXJjb2RlX2RlY29kZXInO1xuaW1wb3J0IEJhcmNvZGVSZWFkZXIgZnJvbSAnLi9yZWFkZXIvYmFyY29kZV9yZWFkZXInO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2NvbW1vbi9ldmVudHMnO1xuaW1wb3J0IENhbWVyYUFjY2VzcyBmcm9tICcuL2lucHV0L2NhbWVyYV9hY2Nlc3MnO1xuaW1wb3J0IEltYWdlRGVidWcgZnJvbSAnLi9jb21tb24vaW1hZ2VfZGVidWcnO1xuaW1wb3J0IFJlc3VsdENvbGxlY3RvciBmcm9tICcuL2FuYWx5dGljcy9yZXN1bHRfY29sbGVjdG9yJztcbmltcG9ydCBDb25maWcgZnJvbSAnLi9jb25maWcvY29uZmlnJztcbmltcG9ydCB7IG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IFF1YWdnYSBmcm9tICcuL3F1YWdnYS9xdWFnZ2EnO1xuXG5jb25zdCBpbnN0YW5jZSA9IG5ldyBRdWFnZ2EoKTtcbmNvbnN0IF9jb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuY29uc3QgUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2UgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGNvbmZpZywgY2IsIGltYWdlV3JhcHBlciwgcXVhZ2dhSW5zdGFuY2UgPSBpbnN0YW5jZSkge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjYiA9IChlcnIpID0+IHsgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKCk7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0LmNvbmZpZyA9IG1lcmdlKHt9LCBDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIC8vIFRPRE8gIzE3OTogcGVuZGluZyByZXN0cnVjdHVyZSBpbiBJc3N1ZSAjMTc5LCB3ZSBhcmUgdGVtcCBkaXNhYmxpbmcgd29ya2Vyc1xuICAgICAgICBpZiAocXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID4gMCkge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuY29udGV4dC5jb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VXcmFwcGVyKSB7XG4gICAgICAgICAgICBxdWFnZ2FJbnN0YW5jZS5jb250ZXh0Lm9uVUlUaHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHF1YWdnYUluc3RhbmNlLmluaXRpYWxpemVEYXRhKGltYWdlV3JhcHBlcik7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2UuaW5pdElucHV0U3RyZWFtKGNiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXJ0KCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnN0b3AoKTtcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9jb250ZXh0LnN0b3BwZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25EZXRlY3RlZDogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2sgfHwgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGNhbGxiYWNrICE9PSAnb2JqZWN0JyB8fCAhY2FsbGJhY2suY2FsbGJhY2spKSkge1xuICAgICAgICAgICAgY29uc29sZS50cmFjZSgnKiB3YXJuaW5nOiBRdWFnZ2Eub25EZXRlY3RlZCBjYWxsZWQgd2l0aCBpbnZhbGlkIGNhbGxiYWNrLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50cy5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmRGV0ZWN0ZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoJ2RldGVjdGVkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25Qcm9jZXNzZWQ6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrIHx8ICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ29iamVjdCcgfHwgIWNhbGxiYWNrLmNhbGxiYWNrKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLm9uUHJvY2Vzc2VkIGNhbGxlZCB3aXRoIGludmFsaWQgY2FsbGJhY2ssIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgRXZlbnRzLnN1YnNjcmliZSgncHJvY2Vzc2VkJywgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmUHJvY2Vzc2VkOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgRXZlbnRzLnVuc3Vic2NyaWJlKCdwcm9jZXNzZWQnLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBzZXRSZWFkZXJzOiBmdW5jdGlvbiAocmVhZGVycykge1xuICAgICAgICBpZiAoIXJlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoJyogd2FybmluZzogUXVhZ2dhLnNldFJlYWRlcnMgY2FsbGVkIHdpdGggbm8gcmVhZGVycywgaWdub3JpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5zZXRSZWFkZXJzKHJlYWRlcnMpO1xuICAgIH0sXG4gICAgcmVnaXN0ZXJSZWFkZXI6IGZ1bmN0aW9uIChuYW1lLCByZWFkZXIpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyBuYW1lLCBpZ25vcmluZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLnRyYWNlKCcqIHdhcm5pbmc6IFF1YWdnYS5yZWdpc3RlclJlYWRlciBjYWxsZWQgd2l0aCBubyByZWFkZXIsIGlnbm9yaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UucmVnaXN0ZXJSZWFkZXIobmFtZSwgcmVhZGVyKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyUmVzdWx0Q29sbGVjdG9yOiBmdW5jdGlvbiAocmVzdWx0Q29sbGVjdG9yKSB7XG4gICAgICAgIGlmIChyZXN1bHRDb2xsZWN0b3IgJiYgdHlwZW9mIHJlc3VsdENvbGxlY3Rvci5hZGRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIF9jb250ZXh0LnJlc3VsdENvbGxlY3RvciA9IHJlc3VsdENvbGxlY3RvcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIF9jb250ZXh0LmNhbnZhc0NvbnRhaW5lcjtcbiAgICB9LFxuICAgIGRlY29kZVNpbmdsZTogZnVuY3Rpb24gKGNvbmZpZywgcmVzdWx0Q2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcXVhZ2dhSW5zdGFuY2UgPSBuZXcgUXVhZ2dhKCk7XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlKHtcbiAgICAgICAgICAgIGlucHV0U3RyZWFtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ltYWdlU3RyZWFtJyxcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2l6ZTogODAwLFxuICAgICAgICAgICAgICAgIHNyYzogY29uZmlnLnNyYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1PZldvcmtlcnM6IChFTlYuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRlYnVnKSA/IDAgOiAxLFxuICAgICAgICAgICAgbG9jYXRvcjoge1xuICAgICAgICAgICAgICAgIGhhbGZTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgLy8gVE9ETyAjMTc1OiByZXN0cnVjdHVyZSB3b3JrZXIgc3VwcG9ydCBzbyB0aGF0IGl0IHdpbGwgd29yayB3aXRoIHR5cGVzY3JpcHQgdXNpbmcgd29ya2VyLWxvYWRlclxuICAgICAgICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2xvYWRlcnMvd29ya2VyLWxvYWRlci9cbiAgICAgICAgaWYgKGNvbmZpZy5udW1PZldvcmtlcnMgPiAwKSB7XG4gICAgICAgICAgICBjb25maWcubnVtT2ZXb3JrZXJzID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3b3JrZXJzIHJlcXVpcmUgV29ya2VyIGFuZCBCbG9iIHN1cHBvcnQgcHJlc2VudGx5LCBzbyBpZiBubyBCbG9iIG9yIFdvcmtlciB0aGVuIHNldFxuICAgICAgICAvLyB3b3JrZXJzIHRvIDAuXG4gICAgICAgIGlmIChjb25maWcubnVtT2ZXb3JrZXJzID4gMCAmJiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBXb3JrZXIgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcqIG5vIFdvcmtlciBhbmQvb3IgQmxvYiBzdXBwb3J0IC0gZm9yY2luZyBudW1PZldvcmtlcnMgdG8gMCcpO1xuICAgICAgICAgICAgY29uZmlnLm51bU9mV29ya2VycyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0KGNvbmZpZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBFdmVudHMub25jZSgncHJvY2Vzc2VkJywgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdENhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Q2FsbGJhY2suY2FsbChudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZ2dhSW5zdGFuY2Uuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCBudWxsLCBxdWFnZ2FJbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBhZGQgdGhlIHVzdWFsbHkgZXhwZWN0ZWQgXCJkZWZhdWx0XCIgZm9yIHVzZSB3aXRoIHJlcXVpcmUsIGJ1aWxkIHN0ZXAgd29uJ3QgYWxsb3cgdXMgdG9cbiAgICAvLyB3cml0ZSB0byBtb2R1bGUuZXhwb3J0cyBzbyBkbyBpdCBoZXJlLlxuICAgIGdldCBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gUXVhZ2dhSlNTdGF0aWNJbnRlcmZhY2U7XG4gICAgfSxcbiAgICBCYXJjb2RlUmVhZGVyLFxuICAgIENhbWVyYUFjY2VzcyxcbiAgICBJbWFnZURlYnVnLFxuICAgIEltYWdlV3JhcHBlcixcbiAgICBSZXN1bHRDb2xsZWN0b3IsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBRdWFnZ2FKU1N0YXRpY0ludGVyZmFjZTtcbi8vIGV4cG9ydCBCYXJjb2RlUmVhZGVyIGFuZCBvdGhlciB1dGlsaXRpZXMgZm9yIGV4dGVybmFsIHBsdWdpbnNcbmV4cG9ydCB7XG4gICAgQmFyY29kZURlY29kZXIsXG4gICAgQmFyY29kZVJlYWRlcixcbiAgICBDYW1lcmFBY2Nlc3MsXG4gICAgSW1hZ2VEZWJ1ZyxcbiAgICBJbWFnZVdyYXBwZXIsXG4gICAgUmVzdWx0Q29sbGVjdG9yLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=